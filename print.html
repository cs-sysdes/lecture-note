<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSC.T364 Workshop on System Design -  Web programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<meta name="robots" content="noindex,nofollow,noarchive"/>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lecture note for Web programming course 2022 in CSC.T364 Workshop on System Design">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/highlight-line-numbers.css">
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">HOME</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演習資料 基礎編</li><li class="chapter-item expanded "><a href="01_preliminary.html">01: 演習のための準備</a></li><li class="chapter-item expanded "><a href="02_http_and_routing.html">02: HTTP通信とルーティング</a></li><li class="chapter-item expanded "><a href="03_web_application_framework.html">03: Webアプリケーションフレームワーク</a></li><li class="chapter-item expanded "><a href="04_state_management_v1.html">04: HTTP通信における状態管理 (1)</a></li><li class="chapter-item expanded "><div>05: HTTP通信における状態管理 (2)</div></li><li class="chapter-item expanded affix "><li class="part-title">演習資料 実践編</li><li class="chapter-item expanded "><div>06: タスクの登録・削除</div></li><li class="chapter-item expanded "><div>07: CSSによる装飾</div></li><li class="chapter-item expanded "><div>08: 検索機能</div></li><li class="chapter-item expanded "><div>09: アカウント管理機能 (1)</div></li><li class="chapter-item expanded "><div>10: アカウント管理機能 (2)</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CSC.T364 Workshop on System Design -  Web programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cs-sysdes/lecture-note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="システム設計演習---webプログラミング--"><a class="header" href="#システム設計演習---webプログラミング--">システム設計演習 - Webプログラミング -</a></h1>
<p>この資料は，情報工学系 システム設計演習 Webプログラミング の演習資料です．</p>
<p>資料は全 10 回からなり，<b>練習問題に取り組む時間やレポートをまとめる時間を含めて本演習全体を構成</b>するものとします．
前半 5 回は基礎編としてWebアプリケーションの動作原理やWebアプリケーションフレームワークの使い方などを主に扱います．
後半 5 回は実践編としてWebアプリケーションフレームワークを使用した簡単なタスク管理アプリケーションの開発を扱います．
演習内容にしたがって期末レポート課題を出題しますので，<b>各自のペースで計画的に進めてください</b>．</p>
<p>練習問題が設定されている場合がありますが，必ずしも期末レポート課題に関連する内容ではなく，単に理解度を推し量るものを含みます．</p>
<h2 id="開発環境など"><a class="header" href="#開発環境など">開発環境など</a></h2>
<p>この演習では <a href="https://go.dev">Go言語</a> によるプログラム開発，<a href="https://docker.com">Docker</a> を用いた仮想環境上でのプログラム実行を想定しています．
また，動作確認に Webブラウザ を使用します．
情報工学系演習室の端末には関連ソフトウェアがすでにインストールされていますので，すぐに開発を始めることができます．</p>
<p>個人所有PCなどで演習を行う場合，各自の端末に開発環境をセットアップしてもらう必要があります．
OSやエディタなどについて特に指定はありませんので，各自の慣れ親しんだ環境で開発を進めてもらって構いません．
Windows PC での開発を考えている方には， <a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> の使用を推奨します．</p>
<p>プログラムの実行に必要な Docker は，以下を参考に各自でインストールをお願いします．
この演習では基本的に Command Line Interface (CLI) での実行を想定しているため，ターミナルエミュレータ上で <code>docker-compose</code> コマンドが有効であることを確認してください．</p>
<div class="table-wrapper"><table><thead><tr><th>OS</th><th>参考サイト</th></tr></thead><tbody>
<tr><td>OS X</td><td><a href="https://brew.sh/index_ja">Homebrew</a> or <a href="https://docs.docker.jp/docker-for-mac/install.html">Docker Desktop for Mac</a></td></tr>
<tr><td>Windows (+WSL)</td><td><a href="https://docs.docker.jp/desktop/windows/wsl.html">Docker Desktop w/ WSL2</a></td></tr>
<tr><td>Ubuntu</td><td><a href="https://gihyo.jp/admin/serial/01/ubuntu-recipe/0719">DD4L on Ubuntu 22.04</a></td></tr>
</tbody></table>
</div>
<p>表中に掲載のない環境を愛用している方は自力解決のできる方々だと思いますので，各自で環境整備をお願いします．</p>
<p>基本的に Docker 上でのプログラム実行を想定しているため，Go言語のビルドツールはなくても大丈夫です．
ただし，使用するテキストエディタなどによっては <code>go</code> コマンドが実行できることを要求してくる場合があるため，必要に応じてインストールしておくとよいかもしれません．
インストール方法は <a href="https://go.dev/doc/install">Download and install - The Go programming language</a> を参照してください．</p>
<p>Go言語の基本的な書き方や Docker によるプログラムの実行方法については，<a href="01_preliminary.html">01: 演習のための準備</a> にて扱います．</p>
<h2 id="質問対応"><a class="header" href="#質問対応">質問対応</a></h2>
<p>この注意事項は<a href="http://cs-sysdes.github.io/#slack-workspace">授業Webサイト</a>に記載したものと同じです．</p>
<p>演習に関する質問は Slack にて随時受け付けますが，特に講義時間外については即レスを期待しないでください．
質問者本人だけでなく他の人を助けることにも繋がることも多いため，可能な限り #help チャネルを活用してオープンな場で質問をしてもらえると良いかと思います．
ただし，DM 等での質問や議論を妨げるものではありません．
DM 等で直接受けた質問であっても，重要な質問であると判断した場合には，匿名で #help チャネルに質問の内容と回答を掲載する場合があります．</p>
<p>質問時には，</p>
<ol>
<li>資料の<b>どの部分に取り組んでいる</b>のか．</li>
<li>なにが<b>目的とする動作</b> (理想的な挙動 or 出てほしい結果) なのか．</li>
<li>それを実現するために<b>なにをした</b>のか．</li>
<li>実際には<b>どうなっている</b> のか． (出力やエラーの内容など)</li>
</ol>
<p>を明らかにしてくれると非常に助かります．
一方で，質問の意図が掴みづらい場合にはこちらから掘り下げますので，気にしすぎず気楽に質問してください．</p>
<h2 id="おことわり"><a class="header" href="#おことわり">おことわり</a></h2>
<p>資料中に存在する誤り・不明瞭な説明は，すべて担当教員に責任があります．
誤りを発見された場合は，適切に修正・訂正を行いますので，ご一報ください．
また，不明瞭な点や改善すべき点などについても遠慮なくご報告いただければと思います．
特にWebアプリケーション開発の経験がある学生がいれば，未経験の人がつまずきそうな箇所などを指摘してもらえると助かります．
よりわかりやすい演習資料となるよう努力していきますので，ご協力のほどよろしくお願いいたします．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-演習のための準備"><a class="header" href="#01-演習のための準備">01: 演習のための準備</a></h1>
<p>第1回は，演習を進めるにあたって必要な以下の事項について説明します．</p>
<ol>
<li>Go言語プロジェクト</li>
<li>Dockerコンテナ上でのプログラムの実行</li>
<li>入門Go言語</li>
</ol>
<p>Dockerなどの開発環境のインストールおよび設定は済んでいるものと仮定しています．
まだの方は <a href="index.html">HOME - 開発環境など</a> を参考に開発環境を整えてから進んでください．</p>
<h2 id="go言語プロジェクト"><a class="header" href="#go言語プロジェクト">Go言語プロジェクト</a></h2>
<p>この演習では，扱う内容に応じて最低限のプログラムと実行環境の設定からなるプロジェクトテンプレートを配布し，資料の内容にしたがって配布したプロジェクト内のファイルを編集する形式で演習を進めます．
編集後のプロジェクトの提出などは求めません．</p>
<p>配布するプロジェクトテンプレートには，初期状態としてとりあえず動く程度のプログラムしか入っていません．
必要に応じて関数を定義したり，ファイルを分割したり，ディレクトリを新たに作ってファイルを移動したり，etc. といった作業が要求されます．
資料中にて新たなファイルの作成を指示する場合もありますが，基本的には各自の判断でファイル分割やディレクトリ (Go言語では特に「パッケージ」と呼びます) の切り分けなど，自由に編集して構いません．</p>
<h3 id="プロジェクトの取得"><a class="header" href="#プロジェクトの取得">プロジェクトの取得</a></h3>
<p>今回使用するプロジェクトを以下のURLよりダウンロードしてください．</p>
<p><a href="https://github.com/cs-sysdes/tutorial.go">https://github.com/cs-sysdes/tutorial.go</a></p>
<p>GitHub の扱いに慣れている方は直接 clone してもらって構いません．
そうでない方は，リンクからページを開き，下の画像の通り「Code」→「Download ZIP」と押すと，zip形式でプロジェクトをダウンロード可能です．
ダウンロードしたzipファイルを展開したら準備完了です．</p>
<p><img src="img/download.png" alt="How to download" /></p>
<p>今回使用する tutorial.go は，以下のファイル群で構成されています．</p>
<ul>
<li>README.md</li>
<li>Dockerfile</li>
<li>docker-compose.yml</li>
<li>go.mod</li>
<li>main.go</li>
</ul>
<p>Dockerfile および docker-compose.yml は，プログラム実行時に使用する仮想環境についての設定ファイルです．
演習内で編集することはないと思います．</p>
<p>go.mod は Go言語 の開発ツールである <code>go</code> コマンドによって参照されるプロジェクトの設定などに関するファイルです．
プロジェクト使用するコンパイラのバージョンを指定したり，依存する外部ライブラリの管理などを行うために必要なファイルです．
外部ライブラリの追加は <code>go</code> コマンドで実行することができるため，このファイルも直接編集する機会は少ないです．</p>
<p>main.go が今回の実行対象である Go言語 で書かれたプログラムです．
内容を以下に示しますが，おそらく Go言語 に触れたことがない人でも，実行すると何が起こるのか想像がつくのではないでしょうか．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<p>型の宣言方法や識別子の可視性など Go言語 特有のルールや機能も存在しますが，Go言語 はかなり C言語 に近い印象を個人的に持っています．
みんなが大好きな「ポインタ」もちゃんとあります．</p>
<h2 id="dockerコンテナ上でのプログラムの実行"><a class="header" href="#dockerコンテナ上でのプログラムの実行">Dockerコンテナ上でのプログラムの実行</a></h2>
<p>ここでは仮想環境上でプログラムを実行する方法を説明します．
Dockerの管理する仮想環境は一般に「コンテナ」と呼ばれるため，以降では単に「コンテナ」あるいは「Dockerコンテナ」と表記します．</p>
<p>この演習では基本的にコマンドライン上での実行を想定しています．
たとえば資料中に<code>$ echo &quot;Hello world!&quot;</code>と書かれている場合，これはコマンドライン上で <code>echo</code> コマンドを &quot;Hello world!&quot; という文字列を引数として実行することを意味します．
先頭の &quot;$&quot; を入力する必要はありません．</p>
<h3 id="コンテナの起動"><a class="header" href="#コンテナの起動">コンテナの起動</a></h3>
<p>いま <code>~/sysdes/tutorial.go</code> にダウンロードしたプロジェクトが展開されていると仮定しましょう．
このパスは各自の環境で置き換えてください．</p>
<p>ターミナルエミュレータを起動し，以下のコマンドを打ち込むことでコンテナを起動することができます．
&quot;#&quot; 以降はコメントなので入力する必要はありません．</p>
<pre><code class="language-sh">$ cd ~/sysdes/tutorial.go  # プロジェクトディレクトリへ移動
$ docker-compose up -d     # 仮想環境の起動
</code></pre>
<p>初回起動には少し時間がかかりますので，気長に待ちましょう．</p>
<p>「<code>docker-compose</code> コマンドが見つからない」といったエラーが出ている場合，Docker のインストールが正常に完了していない可能性があります．
Docker のインストールが完了していることや，コマンドへパスが通っていることなどを確認してください．
Mac や Linux では自動的にパスの通っている場所へ実行ファイルを配置してくれることが多いですが，特に WSL を使用せずに Windows のコマンドプロンプトで実行する場合にはパスの設定などが別途必要になることがあります．</p>
<div class="memo">
<code class="hljs">docker-compose</code> は通常複数のコンテナを管理するために使用します．
ここでは Go言語 実行環境として 1 つのコンテナしか扱っていませんが，演習後半 (実践編) では実際に複数のコンテナを同時に立ち上げます．
</div>
<h3 id="プログラムの実行"><a class="header" href="#プログラムの実行">プログラムの実行</a></h3>
<p>コンテナが起動しだら実際にプログラムを動かしてみましょう．</p>
<p>Go言語 は C言語 や Java などと同じコンパイラ型ですが，ビルドツールである <code>go</code> コマンドを使うことでプログラムを直接実行することができます．
ただし，ここでは Dockerコンテナ 上で実行するため，少し長いコマンドを打つ必要があります．
go.mod が存在するディレクトリ (<code>~/sysdes/tutorial.go</code>) 内にて以下のコマンドを実行してください．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
Hello world!
</code></pre>
<p>このコマンドは主に 2 つの部分からなります．<br>
前半部分：<code>docker-compose exec app</code> は，&quot;app&quot; と名付けられたコンテナ上でプログラムを実行するためのコマンドです．
詳細は省略しますが，プロジェクトディレクトリ内の docker-compose.yml を覗くと名前を設定している記述があり，名前を変更することも可能です．<br>
後半部分：<code>go run main.go</code> は，Go言語ビルドツールによって main.go ファイルを実行するためのコマンドです．
これらを組合わせることで，ローカル端末から &quot;app&quot; コンテナ上で main.go を実行し，その結果をローカル端末上で確認することができるようにしています．</p>
<div class="memo">
演習前半 (基礎編) の内容については，ローカルに Go言語 の実行環境を持っている人は単純に <code class="hljs">go run main.go</code> などとして直接実行する方が早いです．
演習後半 (実践編) において <code class="hljs">docker-compose</code> コマンドで複数のコンテナを起動順序の制約を守りながら並行して立ち上げる必要があるので，今のうちから慣れてもらうためにあえて面倒な方法を紹介しています．
</div>
<h3 id="仮想環境の停止"><a class="header" href="#仮想環境の停止">仮想環境の停止</a></h3>
<p>演習が終了したら，忘れずにコンテナを停止しましょう．</p>
<p>起動コマンドが <code>up</code> だったので，停止は <code>down</code> です．
プロジェクトディレクトリ (<code>~/sysdes/tutorial.go</code>) 内で以下のコマンドを実行してください．</p>
<pre><code class="language-sh">$ docker-compose down
</code></pre>
<p>停止時にも少し時間がかかる場合があります．
想環境の停止においてエラーが発生することはほとんどありませんが，たとえばプロジェクトのパスを変更 (ディレクトリの移動や名前の変更) してしまうと正常に停止できない場合があります．</p>
<div class="memo">
情報工学系演習室 (計算機室) の端末で演習を進めている方へのお願いです．
計算機室の端末では Docker 周りに一部不安定な挙動が見られます．
そのため，<b>演習が終了したらコンテナを停止した上で，必ず端末を再起動</b>してください．
ログアウトではなく，再起動でお願いします．
</div>
<p>以上の手順は演習を進める上で毎回使います．
忘れたらここを見直せば良いので頑張って覚える必要はないですが，たとえば <code>$ make start</code> で起動できるよう Makefile を設置するなど，各自で工夫をしてもよいと思います．</p>
<h2 id="入門go言語"><a class="header" href="#入門go言語">入門Go言語</a></h2>
<p>演習で使用するGo言語について簡単に勉強しましょう．</p>
<p>tutorial.go では画面に &quot;Hello world!&quot; と出力するプログラムを扱いました．
ここからは，これをベースとして色々な言語機能を説明し，プログラムを実際に変更して動かしてみることで，Go言語に入門 していきたいと思います．</p>
<p>すでにGo言語に慣れている人は，これ以降をスキップして <a href="02_http.html">第2回</a> に進んでもらって構いません．
お疲れさまでした．</p>
<h3 id="maingo-解説"><a class="header" href="#maingo-解説">main.go 解説</a></h3>
<p>初期状態の tutorial.go/main.go は以下のようになっています．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<p>1行目 <code>package main</code> はパッケージ宣言と呼び，この<b>ファイルが属するパッケージ</b>を明示しています．
Go言語 ではすべてのファイルが「パッケージ」に属しており，パッケージの集合を「モジュール」と呼んでいます．
すなわち，いままでプロジェクトと呼んでいたものは，tutorial.go という名のモジュールであるということになります．</p>
<p>main は特別なパッケージ名で，実行基点となる <b>main 関数が存在するファイルは必ず main パッケージ</b>に属している必要があります．
また，一つのパッケージに複数の main を配置することは可能ですが非推奨となっており，今回の場合ルートディレクトリに別の main 関数を持ったファイルを配置して main パッケージであると宣言すると，ビルドツールが文句を言います．
最近流行の Rust ほどではありませんが，Go言語 もビルドツールがなかなかお節介です．</p>
<p>3行目 <code>import &quot;fmt&quot;</code> は，このプログラムで<b>使用するパッケージをインポート</b>するための宣言です．
C言語 でいうところの <code>#include &lt;...&gt;</code> 文みたいなものだと考えてください．
なお，プログラム中で使用していないパッケージを import していると，コンパイラがエラーを出します．
警告ではなくエラーです．</p>
<p>5行目 <code>func main()</code> は，C言語 における <code>void main(void)</code> と同等と考えて差し支えありません．
Go言語 は C言語 と同様に <code>main</code> という識別子をもった関数を実行基点としています．
C言語 では普通 <code>int main(void)</code> と書きますが，Go言語 の main関数 は戻り値を持たないため，戻り値型の宣言がありません．</p>
<p>6行目 <code>fmt.Println(...)</code> は<b>標準出力へ文字列を出力する関数</b>を呼び出しています．
先ほど <code>fmt</code> パッケージを import したのは，ここで <code>fmt</code> パッケージ内の <code>Println</code> 関数を使用するためです．
パッケージ内の関数や変数といった識別子を呼び出す場合には，このように「<b>パッケージ名 + 識別子名</b>」の形式で記述します．</p>
<p><code>Println</code> 関数は，Java の <code>System.out.println</code> メソッドと同じものだと思ってください．
引数で与えた文字列を，改行付きで標準出力へ出力します．</p>
<p>以上が初期状態での main.go の内容になります．
ここからは，このファイルを編集しながら代表的な言語機能を見ていきましょう．</p>
<h3 id="変数と定数"><a class="header" href="#変数と定数">変数と定数</a></h3>
<p>いま文字列 &quot;Hello world!&quot; を直接 <code>fmt.Println</code> 関数に入力していますが，これを一旦変数に格納した上で関数に渡すよう変更してみましょう．</p>
<p>まず C言語 と最も異なるルールとして，Go言語 では<b>型を後置</b>します．
すなわち，Go言語 における変数宣言の基本的な形式は <code>var 変数名 型名</code> になります．
先頭の <code>var</code> はこれが変数宣言であることを意味し，そのあとに変数名，変数の型が続きます．</p>
<p>同じ型の変数を複数宣言する場合には，<code>var i, j, k int</code> などのようにまとめることができます．
さらに，異なる型の変数を複数宣言する場合には，以下のように <code>var</code> キーワードをグループ化することもできます．</p>
<pre><code class="language-go">var (
    i, j, k int
    v string
)
</code></pre>
<p>これらの機能は後ほど登場する <code>const</code> キーワードでも同様です．</p>
<h4 id="局所変数"><a class="header" href="#局所変数">局所変数</a></h4>
<p>具体的に main.go を変数を使って書き換えた例を示します．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var message string = &quot;Hello world!&quot;  // string型の変数messageを宣言し&quot;Hello world!&quot;を代入
    fmt.Println(message)
}
</code></pre>
<p>ただ変数を宣言し，値を代入しているだけですので，あまり迷うことはないかと思います．
ちなみに Go言語 では C言語 と同様に <code>//</code> や <code>/* */</code> によってコメントを記述可能です．</p>
<p>さて，Go言語 ではこれをもう少し効率的に書くことができます．
1 つ目の改善点として，変数の宣言と初期化 (代入) を同時に行う場合，型は初期値から推論できるので書く必要がありません．
つまり以下のような書き方が可能です．</p>
<pre><code class="language-go">// messageの型は書かなくても初期値からstringに推論される
var message = &quot;Hello world!&quot;
</code></pre>
<p>2 つ目の改善点として，<b>関数内や制御ブロック内などといった局所スコープ</b>に限り，以下のように書いても同じ意味になります．</p>
<pre><code class="language-go">// 下記は var message = &quot;Hello world&quot; と同等
message := &quot;Hello world!&quot;  // = ではなく := であることに注意!!
</code></pre>
<p>ここまでの理解から以下のコードが合法になることがわかります．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    message := &quot;Hello world!&quot;
    fmt.Println(message)
}
</code></pre>
<p>注意点として，<code>:=</code> では同じスコープ内で複数の同じ変数を束縛できません．
すなわち，以下のコードはコンパイルエラーになります．</p>
<pre><code class="language-go">func main() {
    message := &quot;Hello world!&quot;
    message := &quot;Hello, Masu!&quot;    // これはmessageの再定義なのでダメ
    message = &quot;Hello, Kazuya!&quot;   // これはmessageへの再代入 (既存の変数の変更) なのでOK
}
</code></pre>
<p>ただし，このルールには一部例外があります．
詳細は後日，おそらく演習内で例外的な状況が出てくると思いますので，そのときに説明を加えます．</p>
<h4 id="グローバル変数定数"><a class="header" href="#グローバル変数定数">グローバル変数・定数</a></h4>
<p>Go言語 では，C言語 と同様にグローバル変数を定義することができます．
ただし，<code>:=</code> を用いた略記法はグローバル変数では使用できないことに注意してください．</p>
<p>また，グローバル変数は定数としての利用を想定していることが多いかと思います．
そうした場合は，<code>var</code> を <code>const</code> に変えることで変数ではなく定数を宣言することができます．
グローバル定数を使って書いた例を以下に示します．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

const message = &quot;Hello world!&quot;  // 型推論は効く

func main() {
    fmt.Println(message)
}
</code></pre>
<p>定数は関数スコープ内などでも定義できますが，用途が限定されるためかあまり見かけたことがありません．
個人的には <code>const</code> 指定好きなので使いますが……</p>
<h3 id="関数"><a class="header" href="#関数">関数</a></h3>
<p>変数 (定数) が使えるようになったら，次は関数です．
いま <code>main</code> 関数の中は非常に単純ですが，コードが複雑化すると関数を分けたくなります．</p>
<p>Go言語 での関数の定義方法は <code>func 関数名(引数リスト) 戻り値型 { 処理の内容  }</code> となっています．
型は後置するルールなので，戻り値型も後ろになっています．</p>
<p>ここでは引数として名前を受け取り，挨拶を返す関数 <code>hello</code> を作成してみます．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    greet := hello(&quot;Masu&quot;)
    fmt.Println(greet)
}

func hello(name string) string {
    return fmt.Sprintf(&quot;Hello, %s!&quot;, name)
}
</code></pre>
<p>当然ながら引数リストでも型は後置するルールなので，<code>name string</code> で <code>name</code> という string 型の仮引数を設定しています．</p>
<p>C言語と同様に戻り値を返すには <code>return</code> キーワードを使用します．
<code>fmt.Sprintf</code> は C言語 の <code>sprintf</code> 関数 (<code>&lt;stdio.h&gt;</code>) と同じものです．</p>
<p>これを実行すると以下のような結果を得られるはずです．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
Hello, Masu!
</code></pre>
<p>Go言語 の戻り値には C言語 にはない機能があります．
たとえば，C言語の <code>printf</code> 関数が整数値を返すのと同様に．先ほどから使用している <code>fmt.Println</code> 関数も戻り値を持ちます．
普段はほとんど使いませんが，<code>fmt.Println</code> 関数の戻り値は <code>(int, error)</code> であると定義されています．
Go言語 ではこのように複数の戻り値を返すことができ，至る所でこの機能を使用しています．
万が一 <code>fmt.Println</code> 関数の戻り値を受け取りたい場合には，以下のように書く必要があります．</p>
<pre><code class="language-go">i, err := fmt.Println(&quot;Hello, Kazuya!&quot;)
</code></pre>
<p>ただし，常に両方の戻り値が必要というわけでもないと思うので，戻り値を破棄する特別な変数名として <code>_</code> (アンダースコア) が予約されています．
つまり，先ほどの例で第2戻り値のエラー情報だけ欲しい場合には，以下のように書けます．</p>
<pre><code class="language-go">_, err := fmt.Println(&quot;Hello, Kazuya!&quot;)
</code></pre>
<h3 id="識別子の命名規則と可視性"><a class="header" href="#識別子の命名規則と可視性">識別子の命名規則と可視性</a></h3>
<p>さきほど関数宣言で <code>hello</code> という識別子を使いました．
また，グローバル変数を定義する際も <code>message</code> という識別子を使いました．
何も変なところはないように思いますが，実は意識して<b>小文字から始まる識別子</b>を使いました．
一方で <code>fmt.Println</code> 関数は，<code>fmt</code> はパッケージ名なので無視するとして，関数名は<b>大文字から始まる識別子</b>になっています．</p>
<p>実は Go言語 では，変数や関数の識別子名として，<b>先頭が大文字である場合と小文字である場合を区別</b>します．
そして，これらを区別することで，<b>パッケージ外からの識別子の可視性</b>をコントロールしています．</p>
<p>具体的には，<code>fmt</code> パッケージ内にも先頭が小文字の識別子が存在しますが，これらの識別子を <code>main</code> パッケージから参照することはできません．
<b>小文字はじまりの識別子はパッケージローカル</b>，すなわち Java でいえば「アクセス修飾子なし」の状態であるということになります．
一方，<b>大文字はじまりの識別子は Java でいうところの public</b> になるため，<code>main</code> パッケージから <code>fmt.Println</code> 関数を参照することができるということです．</p>
<p>このルールは現在のところあまり意識する必要はありません．
ですが，今後プロジェクトが大きくなってパッケージを分割していく必要が生じた際に落とし穴になる可能性があるため，ここで説明をしました．
今後も必要に応じて触れる予定でいます．</p>
<h3 id="制御構造"><a class="header" href="#制御構造">制御構造</a></h3>
<p>複雑な処理を実行するために必要な機能である条件分岐と繰り返しについて説明します．</p>
<h4 id="条件分岐"><a class="header" href="#条件分岐">条件分岐</a></h4>
<p>条件分岐には，主に <code>if</code> および <code>switch</code> を使用します．</p>
<h5 id="条件分岐-1-if"><a class="header" href="#条件分岐-1-if">条件分岐 1: <code>if</code></a></h5>
<p><code>if</code> はC言語とほとんど同じですが，Go言語 では<b>条件節に丸括弧が不要</b>です．</p>
<pre><code class="language-go">// iは整数型の変数
if i % 2 == 0 {
    fmt.Println(&quot;Even!&quot;)
} else {
    fmt.Println(&quot;Odd!&quot;)
}
</code></pre>
<h5 id="条件分岐-2-switch"><a class="header" href="#条件分岐-2-switch">条件分岐 2: <code>switch</code></a></h5>
<p>次に <code>switch</code> ですが，通常の使い方はこちらもだいたい同じです．</p>
<pre><code class="language-go">// iは整数型の変数
switch i {
    case 42:
        fmt.Println(&quot;Answer to the Ultimate Question of Life, the Universe, and Everything&quot;)
    case 57:
        fmt.Println(&quot;Prime!&quot;)
    default:
        fmt.Println(&quot;Common number&quot;)
}
</code></pre>
<p><code>if</code> と同じように，<code>switch(i) {</code> ではなく <code>switch i {</code> と書けます．
ただし，C言語 との違いとしてデフォルトで fall through しないようになっています．
したがって，至る所に <code>break</code> と書く必要がありません．
一方で <code>break</code> の代わりに <code>fallthrough</code> と書くことで，わざと fall through させることもできます．</p>
<p>Go言語 の <code>switch</code> における便利な機能として，複数のマッチ対象を一度に書く機能があります．
また，対象は整数値に限定されず，他の型でも渡すことができます．
以下に具体例を示します．</p>
<pre><code class="language-go">// prefecture はstring型の変数
switch prefecture {
    case &quot;Hokkaido&quot;:
        return &quot;countryside&quot;
    case &quot;Tokyo&quot;, &quot;Yokohama&quot;:  // &quot;Tokyo&quot; か &quot;Yokohama&quot; の場合にマッチ
        return &quot;metropolis&quot;
    default:
        return &quot;unknown&quot;
}
</code></pre>
<p>さらに，Go言語 の <code>switch</code> は複数条件を持つ <code>if</code> として使用することもできます．</p>
<pre><code class="language-go">func Collatz(n int) bool {
    switch {    // 対象がないがtypoではない
        case n &lt; 1:
            return false
        case n == 1:
            return true
        case n % 2 == 0:
            return Collatz(n / 2)
        default:
            return Collatz(3 * n + 1)
    }
}
</code></pre>
<p>複数の <code>case</code> 条件を満たす場合には，より上に書かれたものが優先されます．
すべての <code>case</code> が実行されるわけではないので注意してください．</p>
<h4 id="繰り返し"><a class="header" href="#繰り返し">繰り返し</a></h4>
<p>繰り返しを表現するには <code>for</code> を使用します．
<code>while</code> はありません．</p>
<p>例として 1 から 100 までの整数を出力するプログラムを示します．</p>
<pre><code class="language-go">for i := 1; i &lt;= 100; i++ {
    fmt.Println(i)
}
</code></pre>
<p><code>for</code> も C言語 のものとほとんど同じですが，<code>if</code> と同様に丸括弧を書きません．
ここで，繰り返し変数の定義として <code>i := 1</code> を与えていますが，これは <code>for</code> スコープ内の局所変数なので <code>:=</code> による型推論を含めた初期化 + 定義が可能となっています．</p>
<p>より便利な例を見てみます．
Go言語 にも当然データ構造としての<b>配列</b>があるわけですが，配列のインデックスと要素を順に出力したい状況はよく発生します．
そうした場合，以下のように Java の拡張for文のような書き方ができます．</p>
<pre><code class="language-go">animals := []string{&quot;dog&quot;, &quot;cat&quot;, &quot;Tasmanian devil&quot;}
for i, a := range animals {
    fmt.Printf(&quot;%d: %s\n&quot;, i, a)
}
</code></pre>
<p>インデックス値が不要の場合には <code>_</code> で受けて破棄することで対応できます．</p>
<p>Go言語に <code>while</code> はありませんが，<code>for</code> によって <code>while</code> と同等のことが表現できます．</p>
<pre><code class="language-go">for i &lt; 10 { ... }  // while(i &lt; 10) に相当
for true { ... }    // while(true) に相当 (無限ループ)
</code></pre>
<p>特に 2 つめの無限ループに関しては特別な記法があり，条件節を省略して</p>
<pre><code class="language-go">for { ... }   // for true { ... } と同等
</code></pre>
<p>と書くだけで十分です．</p>
<h5 id="練習問題"><a class="header" href="#練習問題">練習問題</a></h5>
<p>ここまでの理解度を測るため，FizzBuzz問題を解いてみましょう．</p>
<p>手順として以下の要件を満たす関数を順に作成し，最後に組合せることで1〜30までの数値についてFizzBuzzを表示するプログラムを作成してください．</p>
<ol>
<li>3の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 3の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>5の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 5の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>15の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 15の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>出力すべき文字列を返す関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 3の倍数 であるが 5の倍数 でなければ <code>&quot;Fizz&quot;</code> を，3の倍数 でないが 5の倍数 であれば <code>&quot;Buzz&quot;</code> を，15の倍数 であれば <code>&quot;FizzBuzz&quot;</code> を，それ以外は入力値を文字列化して返す</li>
</ul>
</li>
</ol>
<div class="memo">
整数値を文字列化するには，<code class="hljs">fmt.Sprintf</code> 関数か，strconv パッケージ名の <code class="hljs">strconv.Iota</code> を使用するとよい．
</div>
<p><a href="https://gist.github.com/y7amura/262cbbc739017ca2713f4a95fba80731">ここから実装例が確認できます</a></p>
<h3 id="ポインタ"><a class="header" href="#ポインタ">ポインタ</a></h3>
<p>Go言語 にもポインタが存在し，役割や使い方などは C言語 のポインタとほぼ同じです．
ただし，Go言語 は GC (Garbage Collection) 機能を持つ言語なので，C言語 のポインタに比べれば制約も緩く，やや扱いやすいものになっています．</p>
<div class="memo">
本演習に限らず，ポインタの概念が怪しい人は「手続き型プログラミング 発展」などの資料を見直し，復習しておくことを推奨します．
</div>
<p>Go言語 のポインタ変数は，C言語 と同様に型名にアスタリスクを付けることで宣言が可能です．
ただし，型宣言の方法が異なったように，ポインタ変数の型宣言もまた C言語 とは異なり，たとえば整数型ポインタであれば <code>*int</code> のように<b>型名の前にアスタリスク</b>がつきます．</p>
<p>また C言語 と同様に，通常の変数に &amp; (アンパサンド) を付けることで，その変数へのポインタを取得できます．
逆にポインタから値を参照したいときも，C言語 と同様にアスタリスクによるデリファレンスが可能です．</p>
<p>これまでの関係を整理すると，以下のようになります．</p>
<pre><code class="language-go">var i int = 0
var p *int = &amp;i  // 変数iのポインタを取得
var j int = *p   // ポインタ変数pを経由して変数iの値を取得
</code></pre>
<p>とりあえずポインタ変数を確保して，後から値を代入したい場合には組み込み関数 <code>new</code> を使うと良いです．</p>
<pre><code class="language-go">var p *int
p = new(*int)

*p = 1
</code></pre>
<p><code>new</code> を使うため誤解が生じるかもしれませんが，<code>free</code> はありません．
ポインタ変数 <code>p</code> は，不要になれば GC によって勝手に解放されます．</p>
<p>C言語 では無効なポインタ値として <code>NULL</code> が定義されていましたが，Go言語 では <code>nil</code> になります．
Go言語 では，未初期化のポインタ変数は <code>nil</code> を指すことが言語仕様上決まっています．</p>
<p>また，GC がある言語であるため，以下のコードが Go言語 では合法になります．</p>
<pre><code class="language-go">func NewInt() *int {
    p := 1
    return &amp;p
}

var p *int
p = NewInt()
</code></pre>
<p>このコードは関数スタックに積まれた局所変数のポインタを返しているので，C言語では合法ではありません．
一方 Go言語 では，これは特にエラーもなく動きます．
実際，Go言語 のコードでは局所変数のポインタどころか即値のポインタすら関数外へ return するようなコードがよく見られます．
代表的な例としては，次のセクションで説明する構造体を関数ローカルで定義し，そのまま return するコードです．</p>
<pre><code class="language-go">type Person struct {
    Name string
    Age int
}

func NewPerson(name string, age int) *Person {
    return &amp;Person{ name, age }
}
</code></pre>
<p>C言語 としてみるとなんだか不思議なコードですが，Go言語 では割と普通に見かけます．</p>
<h5 id="練習問題-1"><a class="header" href="#練習問題-1">練習問題</a></h5>
<p>次のコードがどういう出力になるか考え，実装して確かめてみよ．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func IncrementV(v int) {
    v = v + 1
}

func IncrementP(p *int) {
    *p = *p + 1
}

func main() {
    v := 0

    IncrementV(v)
    fmt.Printf(&quot;v = %d\n&quot;, v)

    p := &amp;v
    IncrementP(p)
    fmt.Printf(&quot;v = %d\n&quot;, v)
}
</code></pre>
<h3 id="配列とスライス"><a class="header" href="#配列とスライス">配列とスライス</a></h3>
<p>同じ型の複数の値をまとめて扱うためのデータ構造として<b>配列</b>と<b>スライス</b>が存在します．
Go言語 において通常「<b>配列</b>」と呼ぶものは「固定長配列」を意味しており，これは決められた長さを持つデータ構造です．
一方で，「<b>スライス</b>」は一般に「可変長配列」と呼ばれるものであり，こちらはその名の通り長さを変えることができます．</p>
<h4 id="配列"><a class="header" href="#配列">配列</a></h4>
<p>配列 (固定長配列) 定義の基本形は <code>var 変数名 [長さ]型</code> になります．
また，初期値を直接与える場合には，<code>変数名 := [...]型 { 初期値のリスト }</code> というように長さを推論させることができます．
したがって，配列の型としての記法は <code>[長さ]型</code> であり，この点からも長さを指定する必要があることがわかります．</p>
<p><code>var 変数名 [長さ]型</code> の形式で定義された配列は，指定された長さの分だけ型ごとに決められたデフォルト値ですべての要素が初期化されます．
すなわち，以下の例において <code>a1</code> と <code>a2</code> はすべての要素が等しい 2 つの異なる配列ということになります．</p>
<pre><code class="language-go">var a1 [5]int
a2 := [...]int{0, 0, 0, 0, 0}
</code></pre>
<p>配列中の特定の要素は，C言語と同様に <code>変数名[インデックス値]</code> でアクセス可能です．
他の多くの言語と同様に，0-based indexing になっています．</p>
<pre><code class="language-go">a := [...]int{1, 2, 3, 4, 5}
fmt.Println(a[0])  //=&gt; 1
</code></pre>
<p>Go言語はすべての変数が値として扱われるため，配列もいわゆる値型と呼ばれるような挙動をします．
すなわち，以下のコードにおいて <code>a2</code> は <code>a1</code> のコピーになり，両変数は別の領域にあるデータを指します．</p>
<pre><code class="language-go">a1 := [...]int {1, 2, 3, 4}  // 新しい長さ4の配列
a2 := a1                     // a1と同じ内容の新しい長さ4の配列
</code></pre>
<h4 id="スライス"><a class="header" href="#スライス">スライス</a></h4>
<p>スライス (可変長配列) 定義の基本形は <code>var 変数名 []型</code> となり，配列定義から長さの指定が消えた形となっています．
初期値を直接与える場合も長さの指定がないため，<code>変数名 := []型 { 初期値のリスト }</code> という表現になります．
スライスの型としての記法は <code>[]型</code> です．</p>
<p><code>var 変数名 []型</code> の形式で定義されたスライスは，サイズが 0 になります．
つまり，なにも入っていない状態です．
スライスも配列と同様に <code>変数名[インデックス]</code> の形式で各要素にアクセスできますが，サイズ 0 のスライスにアクセスした場合，どのようなインデックス値に対しても範囲外アクセスによりプログラムが異常終了します．</p>
<p><code>var 変数名 []型</code> の形式で定義したスライスは，組み込み関数 <code>make</code> によって指定したサイズのスライスとして確保しなおすことができます．
組み込み関数 <code>make</code> は引数として型，サイズ，キャパシティの 3 つをとりますが，キャパシティは省略可能です．
キャパシティを省略した場合，おそらくサイズに依存して適切なキャパシティが自動設定されます．</p>
<pre><code class="language-go">var array []int         // これはサイズ0の整数型スライス
array = make([]int, 5)  // ここでサイズ5の整数型スライスになる (キャパシティは自動設定)
</code></pre>
<div class="memo">
これは教員自身が Go言語 でプログラムを書くとき (年に1回くらいのイベント) によくやることなのですが，スライスを使った周辺でプログラムが落ちる場合はだいたいサイズ 0 のまま使おうとして範囲外アクセスで落ちていることが多いです．
スライスを宣言した周辺でプログラムが異常停止する場合は，このミスを疑ってみると良いかもしれません．
</div>
<p>スライスも値ではあるのですが，いわゆる参照型のような挙動をします．
スライスはメモリ上での先頭アドレス・サイズ・キャパシティを持っているようなデータ構造なので，スライスのコピーはこれらの値のコピーを意味します．
つまり，以下のコードにおいて <code>a2</code> は <code>a1</code> の持つ先頭アドレス・サイズ・キャパシティの値をコピーしたものであるため，指している先頭アドレスは同じとなり，実質的に同じものを指す変数となります．</p>
<pre><code class="language-go">a1 := []int {1, 2, 3, 4}  // a1が持つのは，先頭要素のアドレス，サイズ，キャパシティ
a2 := a1                  // a2が持つのは，a1の先頭要素のアドレス，サイズ，キャパシティ
</code></pre>
<p>スライスは可変長であるため，組み込み関数 <code>append</code> を使って要素を追加し，スライスの長さを変えることができます．
<code>append</code> 関数は追加する要素を複数とることができ，追加後のスライスを返します．</p>
<pre><code>a1 := []int{1, 2, 3, 4}
a1 = append(a1, 5, 6, 7)    //=&gt; a1 == [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>ここで注意すべきこととして，追加前の <code>a1</code> が指していた先頭要素のアドレスと追加後の <code>a1</code> が指す先頭要素のアドレスが一致する保証はありません．
要素を追加した結果として <code>a1</code> のキャパシティを超えてしまう場合，新たなキャパシティで <code>a1</code> を再確保することでスライスの伸長を行うためです．
すなわち，<code>append</code> 関数はメモリアロケーションを発生させる可能性があり，場合によってはパフォーマンスに影響が出ることもあります．</p>
<p>追加には <code>append</code> 関数がある一方で，削除する関数はありません．
Go言語 では Python のように<b>部分スライス</b>を取得できるので削除関数を自作することはできます．</p>
<h3 id="構造体"><a class="header" href="#構造体">構造体</a></h3>
<p>複数の型をまとめた複合型を作りたい場合，Go言語 では<b>構造体</b>を使用します．
C言語 の構造体と同じものです．</p>
<p>構造体を定義するには <code>struct</code> キーワードを使用します．
たとえば，文字列型の名前と整数型の年齢をフィールドに持つ構造体の定義は以下のようになります．</p>
<pre><code class="language-go">struct {
    Name string
    Age int
}
</code></pre>
<p>C言語 では構造体を定義する際に構造体名を与えないといけませんでしたが，Go言語 では不要です．
これはそのまま型として機能するので，次のような変数宣言が可能です．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}
</code></pre>
<p>構造体変数は以下のように，波括弧を用いてそれぞれのフィールドに代入する値を指定することで初期化できます．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}{
    &quot;Tech-chan&quot;,
    5,            // 最後のフィールド値のあとに改行を入れる場合，ここのカンマは必要
}
</code></pre>
<p>また，フィールド名を指定して初期化することもできます．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}{
    Name: &quot;Tech-chan&quot;,
    Age: 5,             // 最後のフィールド値のあとに改行を入れる場合，ここのカンマは必要
}
</code></pre>
<p>フィールド名を指定した初期化方法は，フィールドの宣言順序に依存せずに構造体を初期化したい場合や，一部のフィールドにだけ値を与えたい場合などに有効です．</p>
<p>構造体変数のフィールドへは，Java のインスタンス変数などと同様に <code>.</code> (ドット) でアクセスできます．</p>
<pre><code class="language-go">fmt.Println(person.Name)  //=&gt; Tech-chan
</code></pre>
<p>構造体変数がポインタの場合，C言語 ではアロー演算子 <code>-&gt;</code> を使用する必要がありましたが，Go言語 では <code>.</code> (ドット) のままで大丈夫です．</p>
<pre><code class="language-go">p := &amp;person
fmt.Println(p.Name)  //=&gt; Tech-chan
</code></pre>
<p>さて，ここで Go言語 の識別子の表記と可視性の規則を思い出してみましょう．
<b>小文字はじまりはパッケージローカル</b>で，<b>大文字はじまりは外部パッケージからも参照可能</b>というルールでした．
ここまで何気なくフィールド名を大文字で書いてきましたが，この識別子の命名規則はフィールド名にも適用されます．
すなわち，フィールド名を小文字はじまりで設定した場合，外部パッケージでは構造体変数のフィールドへアクセスできなってしまいます．
この機能を上手に使うと<b>カプセル化</b>を実現できますが，特に構造体のフィール変数については，慣れないうちは間違い防止のためにすべて大文字はじまりで書いておく方が安全かもしれません．</p>
<h3 id="型の別名とメソッド"><a class="header" href="#型の別名とメソッド">型の別名とメソッド</a></h3>
<p>構造体の定義方法はわかりましたが，同じ構造体型を複数の場所で何度も使用する場合に，毎回すべてのフィールド定義を書くのは面倒です．
Go言語 には<b>型に別名をつける</b>機能があるので，これを使って少し楽をしましょう．</p>
<p>型へ別名をつけるためには <code>type 別名 元の型</code> という構文を使用します．
C言語 の <code>typedef</code> のようなものだと思ってください．</p>
<p><code>type</code> キーワードを使って先ほど定義した構造体に <code>Person</code> という型名をつけてみます．</p>
<pre><code class="language-go">type Person struct {
    Name string
    Age int
}

person := &amp;Person{
    Name: &quot;Tech-chan&quot;,
    Age: 5,
}
</code></pre>
<p>だいぶ見慣れた表現になったのではないでしょうか．</p>
<p><code>type</code> キーワードにはもう一つ特殊な機能があります．
同一パッケージ内で <code>type</code> キーワードによって別名を付けた型には，<b>メソッド</b>と呼ばれる特殊な形式の関数を紐づけることができるようになります．
Go言語 には Java のような <code>class</code> はありませんが，この機能を使うことでオブジェクト指向的な機能をを実現することができます．</p>
<p>たとえば，構造体 <code>Person</code> に文字列へ変換するメソッド <code>ToString</code>，および，年齢を 1 歳増やすメソッド <code>GetOlder</code> を実装してみます．</p>
<pre><code class="language-go">type Person {
    Name string
    Age int
}

func (p Person) ToString() string {
    return fmt.Sprintf(&quot;Name: %s, Age: %d&quot;, p.Name, p.Age)
}

func (p *Person) GetOlder() {
    p.Age = p.Age + 1
}
</code></pre>
<p>メソッドはこのように <code>func (変数名 型) 関数名(引数リスト) 戻り値型 {}</code> の形式で定義することができます．
関数名の前に配置する変数を一般に<b>レシーバ</b>といいます．
レシーバには値型あるいはポインタ型が設定でき，レシーバの内容を変更したい場合にはポインタ型を使用する必要があります．</p>
<p>メソッドの呼び出しは Java などと同様に以下のように行うことができます．</p>
<pre><code class="language-go">person := Person{
    Name: &quot;Tech-chan&quot;,
    Age: 5,
}

fmt.Println(person.ToString())  //=&gt; Name: Tech-chan, Age: 5

person.GetOlder()
fmt.Println(person.ToString())  //=&gt; Name: Tech-chan, Age: 6
</code></pre>
<p>フィールドへのアクセスと同様に，レシーバをポインタ型で定義した場合であっても，そのままドットでアクセスすることができます．便利．</p>
<div class="memo">
構造体が大きい場合も，変更の有無に関わらずポインタ型とするのが良いでしょう．
レシーバとして値型を設定すると，メソッド呼び出しのたびに構造体のコピーが発生するため，パフォーマンス低下の原因になります．
また，こうした事情からレシーバは常にポインタ型にする開発者もいます．
とはいえ，値型とすることで予期せぬ変更を防ぐことができる利点もあるため，適切に使い分ける方が良い気はします．
</div>
<p>さきほど <code>type</code> キーワードは型に別名をつけることができると書きました．
その機能を使用して構造体に名前をつけたわけですが，考えてみれば構造体以外の型でも別名はつけられます．
さらに別名をつけた型には (同じパッケージ内において) メソッドを定義できるというわけです．</p>
<p>つまり，これができます．</p>
<pre><code class="language-go">type MyInt int

func (i MyInt) ToString() string {
    return fmt.Sprintf(&quot;%d&quot;, i)
}

fmt.Println(MyInt(5).ToString())  //=&gt; 5
</code></pre>
<p>ちなみに，7行目において <code>5.ToString()</code> と書くことはできません．
きちんと <code>MyInt</code> 型に変換してからメソッドを呼ぶ必要があります．
これくらいなら普通に <code>int</code> を引数とする関数を定義する方が良いですが，この機能は何かに使えるかもしれませんね．</p>
<!--
### パッケージ
最後に Go言語 の文法ではなく．パッケージの仕組みについて簡単に整理しておきます．

冒頭でも述べた通り，Go言語 ではすべてのファイルが何かしらのパッケージに属し，パッケージの集合であるモジュールが 1 つのプロジェクトになります．
特殊なパッケージである `main` を除いて，パッケージ名には一般にファイルが存在するディレクトリの名前を付けるのが一般的です．
-->
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>駆け足で非常に浅い Go言語 の入門書ですが，最低限必要になりそうな機能は網羅できたと思います．
Go言語 は慣れると割と書きやすい言語ですが，慣れるまでは変な機能も多く，コンパイラの文句も多いので苦労するかと思います．
これ以降の資料でも可能な限り補足はしていくつもりですが，必要に応じてこのページを見返したり，教員へ質問したり，あるいは自身で調べたりなどによって対応してください．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-http通信とルーティング"><a class="header" href="#02-http通信とルーティング">02: HTTP通信とルーティング</a></h1>
<p>今回から本格的にWebアプリケーションを構築するための基礎技術に触れていきます．</p>
<p>第2回は，特に以下の内容について扱います．</p>
<ol>
<li>Webアプリケーションの基本的な動作</li>
<li>Web通信の決まりごと (Hypertext Transfer Protocol; HTTP)</li>
<li>アクセス先の制御 (ルーティング)</li>
</ol>
<p>また今回の資料は，前回配布したプロジェクトとは異なる新たなプロジェクトをベースとして演習を進めます．
以下のリンクより新しいプロジェクト httpserver.go をダウンロードし，演習が進められるよう展開・配置してください．</p>
<p><a href="https://github.com/cs-sysdes/httpserver.go">https://github.com/cs-sysdes/httpserver.go</a></p>
<p>ダウンロード方法は <a href="01_preliminary.html">前回の資料</a> を参照してください．</p>
<h2 id="webアプリケーションの基本的な動作"><a class="header" href="#webアプリケーションの基本的な動作">Webアプリケーションの基本的な動作</a></h2>
<p><b>Web技術</b>を基盤としたアプリケーションを総称して「Webアプリケーション」と呼びます．
Webアプリケーションは，一般に <b>Client-Server model</b> と呼ばれるアプリケーション形態をとり，Client側アプリケーション (Client-side application) と Server側アプリケーション (Server-side application) という2つのアプリケーションによって構成されます．
基本動作として <b>Client からの要求 (リクエスト)</b>に対して <b>Server が応答 (レスポンス)</b>を返す形式で目的の処理を実行します．</p>
<p><img src="img/webapp_flow.png" alt="Client-Server model" /></p>
<p>Client-side アプリケーションには <b>Webブラウザ</b> を採用する場合が多いですが，場合によって専用のアプリケーションを提供する場合もあります．
たとえば，Twitter社は自社のサービスとして Webブラウザ上で Tweet を閲覧可能な Twitter Web App を提供していますが，スマホ用にネイティブアプリケーションとして Twitter for Android や Twitter for iPhone などを提供しています．
また，サードパーティ製アプリケーションまで含めると，PC用あるいはタブレット用アプリケーションなど，さまざまなものが提供されています．
本演習では Client-side アプリケーションには Webブラウザ を採用するため，各自で Client-side アプリケーションを構築してもらう必要はありません．</p>
<p>Server-side アプリケーションは Client-side アプリケーションからのリクエストをもとに，必要に応じて内部状態の更新などを行い，Client-side アプリケーションにレスポンスを返します．
アプリケーションの目的に応じてデータベースや認証システムなど，他の外部サービスと連携して処理を行う場合もあります．
本演習で主に扱うのは，こちらの Server-side アプリケーションになります．</p>
<h3 id="server-side-アプリケーションの実行"><a class="header" href="#server-side-アプリケーションの実行">Server-side アプリケーションの実行</a></h3>
<p><a href="https://github.com/cs-sysdes/httpserver.go">今回配布するプロジェクト</a>は，Server-side アプリケーションとして最低限の通信機能と動作ログを標準出力へ書き出す機能のみをもつプログラムになります．
本ページの以降の説明では，このプログラムを編集し，Webアプリケーションの動作について学びます．</p>
<p>前回と同様に <code>~/sysdes/httpserver.go</code> にダウンロードしたプロジェクトが展開されていると仮定します．
このパスは各自の環境で置き換えてください．</p>
<p>ターミナルエミュレータを起動し，Dockerコンテナを起動します．</p>
<pre><code class="language-sh">$ cd ~/sysdes/httpserver.go
$ docker-compose up -d
</code></pre>
<p>プログラムを起動し，2行目ようなログが表示されることを確認してください．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
2022/10/08 03:30:00 Listen:  [::]:8000
</code></pre>
<p>冒頭のタイムスタンプや <code>[::]</code> の部分は実行タイミングや環境によって異なる場合があります．</p>
<p>このプログラムは Server-side アプリケーションなので，起動すると Client-side アプリケーションからの接続を待機します．
したがって，なにか処理をさせるためには，Client-side アプリケーションからリクエストを送信する必要があります．
先ほど述べた通り，本演習では Client-side アプリケーションとしてWebブラウザを使用することとしているので，ChromeなどのWebブラウザからリクエストを送信してみましょう．</p>
<p>Webブラウザを開き，URL欄に <code>localhost:8000</code> あるいは <code>127.0.0.1:8000</code> と打ち込んでエンターを押してみましょう．
プログラム側のログは以下のような状態となるはずです．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
2022/10/08 03:30:00 Listen:  [::]:8000
2022/10/08 03:35:31 Connected by  172.19.0.1.41888
2022/10/08 03:35:31 Connected by  172.19.0.1.41892
2022/10/08 03:35:32 Connected by  172.19.0.1.41896
</code></pre>
<p>先ほどと同様に，冒頭のタイムスタンプや <code>172.19.0.1:41888</code> の部分，出力されるログの数は実行タイミングや環境によって異なります．</p>
<p>これらのログは，Client-side アプリケーションからのリクエストを受信したことを意味します．
この例のように，1 度しかアクセスしていないのに複数のログが出る場合がありますが，使用するWebブラウザによってこの辺の挙動は変わりますので，いまはあまり気にしなくて良いです．</p>
<p>プログラムの方ではリクエストを受け取ったことをログから確認できました．
一方で，Webブラウザの方はどうなっているでしょうか．</p>
<p>おそらく，通常の動作だと「ページが動作していない」などのエラーが表示されていると思います．
たとえば，教員の端末では以下のような表示になっています．</p>
<p><img src="img/invalid_response.png" alt="Error page" /></p>
<p>現段階では，<b>これは正常な動作結果</b>ですので，安心してください．</p>
<p>このエラー画面に代えて，Webブラウザ上に ”Hello world&quot; と表示することを次の目標とします．</p>
<h3 id="server-side-アプリケーションの停止"><a class="header" href="#server-side-アプリケーションの停止">Server-side アプリケーションの停止</a></h3>
<p>具体的なプログラムの開発に移る前に，プログラムの停止方法を説明します．</p>
<p>今回以降において実行する Server-side アプリケーションは，基本的に Client-side からのリクエストを待ち受け，リクエストに対してレスポンスを返す動作を繰り返し行うプログラムになります．
したがって，初期状態では停止する方法を実装していません．
停止できなければプログラムを変更して再起動することもできないので，どうにかして停止する必要があります．</p>
<p>停止方法は簡単で，ターミナルエミュレータ上で強制停止シグナルを送信することでプログラムを強制的に落とします．
強制停止シグナルを送信するには，プログラムを実行しているターミナルエミュレータ上で，<code>Ctrl-c</code> を入力します．
すなわち，キーボード上の <code>Ctrl</code> ボタンとアルファベットの <code>c</code> を同時押しすることで，プログラムを停止することができます．</p>
<h3 id="httpservergomaingo-概観"><a class="header" href="#httpservergomaingo-概観">httpserver.go/main.go 概観</a></h3>
<p>ここで，どうやらうまく動いていないらしいプログラムの中身を簡単に解説します．
スクロールしながら資料を追うのは難しいと思うので，各自の手元で main.go を開きながら進めると良いかと思います．</p>
<p>main.go には以下のように Server-side アプリケーションが実装されています．</p>
<p><span class="filename">httpserver.go/main.go</span></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net&quot; // standard network package
)

func main() {
	// config
	port := 8000
	protocol := &quot;tcp&quot;

	// resolve TCP address
	addr, err := net.ResolveTCPAddr(protocol, fmt.Sprintf(&quot;:%d&quot;, port))
	if err != nil {
		log.Fatalln(err)
	}

	// get TCP socket
	socket, err := net.ListenTCP(protocol, addr)
	if err != nil {
		log.Fatalln(err)
	}
	log.Println(&quot;Listen: &quot;, socket.Addr().String())

	// keep listening
	for {
		// wait for connection
		conn, err := socket.Accept()
		if err != nil {
			log.Println(err)
			continue
		}
		log.Println(&quot;Connected by &quot;, conn.RemoteAddr().String())

		// yield connection to concurrent process
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	// close connection when this function ends
	defer conn.Close()

	// write response
	conn.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<p><a href="01_preliminary.html">前回</a>触れなかった機能として，3--7行目のように，Go言語の import 文は変数宣言などと同じように複数のパッケージを丸括弧でグループ化して一括で宣言することができます．</p>
<p>9--40行目の <code>main</code> 関数では，Web通信用にソケットを開き (15, 21行目)，外部からの接続を待機しています (28--39行目)．</p>
<p>このプログラムでは，30行目で受け取った外部からの接続 <code>conn</code> を，38行目で <code>handleConnection</code> に渡し，具体的なリクエストおよびレスポンスの処理は <code>handleConnection</code> 関数内で行うよう設計しています．
したがって，これから <code>handleConnection</code> 関数を適切に実装することで，正しく応答する Server-side アプリケーションを開発していきます．</p>
<p>プログラム全体を見渡してみると，以下のような頻出する表現があることに気付きます．</p>
<pre><code class="language-go">if err != nil {
    ...  // 何かしらの処理
}
</code></pre>
<p>これは Go言語 を書く上でおそらく一番よく使うであろう<b>エラーハンドリング</b>を行う記述パターンになります．</p>
<p>たとえば15行目では，与えられたポート番号 (<code>port := 8000</code>) から通信ソケットのアドレスを取得していますが，与えられた文字列が正しいフォーマットではない場合などに，<code>net.ResolveTCPAddr</code> 関数はエラーになります．
Go言語には Java の try-catch のような言語機能がないため，エラーの有無は一般に関数の戻り値として通知されます．
エラーが発生した場合，<code>net.ResolveTCPAddr</code> 関数は第2戻り値としてエラーを伝達するため，第2戻り値を受ける <code>err</code> が <code>nil</code> ではないとき，それはエラーが発生していることを示します．</p>
<p><span class="filename">httpserver.go/main.go (15--18行目 抜粋)</span></p>
<pre><code class="language-go">addr, err := net.ResolveTCPAddr(protocol, fmt.Sprintf(&quot;:%d&quot;, port))   // ここでエラーが発生した場合
if err != nil {                                                       // ここで err != nil となり
    ...                                                               // ここに記述された処理が実行される
}
</code></pre>
<p>このように，Go言語では処理が失敗する可能性がある関数はエラーの有無を表す <code>error</code> 型の戻り値を返すのが一般的です．
<code>error</code> 型の戻り値は，エラーがない，すなわち関数の処理が正常に終了した場合には <code>nil</code> になります．
そうでない場合，すなわち，関数の処理に失敗した場合には，エラー情報を含む <code>error</code> 型の値になります．
したがって，<code>error</code> 型の戻り値の <code>nil</code> 判定を行って，エラーの有無を調べるのが一種の記述パターンになっています．</p>
<p>ところで，<a href="01_preliminary.html">前回</a>の資料中で，通常 <code>:=</code> による変数定義は複数回できないが例外もあるという話をしたかと思います．
今回の <code>err</code> の定義がその例外で，たとえば <code>main</code> 関数の中では，15行目と21行目に同じスコープ内で複数回 <code>err</code> を定義しているように見えます．
これについては，この書き方を許容しないと <code>err</code> のように使い回される可能性がある変数を最初に <code>var err error</code> などと定義しなくてはならず不便なので，例外として許されています．
注意すべきは，<code>err</code> の他に別の新たな変数も同時に定義されているという点で，Go言語 ではこの場合に限り複数回同じ変数を定義しても良いということになっています．
つまり，以下のコードは <code>err</code> 以外に新たな変数が定義されていないので，コンパイルエラーになります．</p>
<pre><code class="language-go">func f() {
    err := ThisCanReturnError()
    err := ThisCanAlsoReturnError()
}
</code></pre>
<p>こういうケースでは，以下のように局所スコープを利用すると良いでしょう．</p>
<pre><code class="language-go">if err := ThisCanReturnError(); err != nil {
    ...
}
</code></pre>
<p>少し話が逸れましたが，最後に38行目の <code>handleConnection</code> 関数を呼び出す記述について見てみます．
この行では関数呼び出しとして通常通り <code>handleConnection(conn)</code> とは書かずに，冒頭に <code>go</code> キーワードを付与して <code>go handleConnection(conn)</code> として関数呼び出しを行っています．
この記述は Go言語 特有のもので，<code>handleConnection</code> 関数を goroutine という機能を使用して<b>並行実行</b>するための記述法です．
すなわち，<code>handleConnection</code> 関数は <code>main</code> 関数の実行とは独立して並行的に処理され，<code>main</code> 関数は <code>handleConnection</code> 関数の結果を待たずに次の処理へとプログラムの実行を進めます．
したがって，<code>handleConnection</code> 関数の実行によって <code>main</code> 関数の実行が妨げられることが (普通は) ないので，<code>main</code> 関数は次々と外部からの接続受けて <code>handleConnection</code> へ渡すといった動作を絶え間なく行うことができます．</p>
<div class="memo">
Go言語 は並行処理を記述しやすいよう設計されたプログラミング言語であり，C言語であれば <code class="hljs">fork</code> を用いたり，Java であれば <code class="hljs">Thread</code> を使って書かなくてはいけないプログラムの並行実行を，<code class="hljs go">go</code> キーワードを付与した関数呼び出しという形で簡単に実行できるようになっています．
goroutine は面白い機能ですが，この演習において理解すべき言語機能というわけではないですし，かなり奥深い内容になってしまうため，詳細な説明は省略します．
</div>
<p>44行目の <code>defer</code> キーワードも Go言語 の面白い機能の一つで，<code>defer</code> キーワードを付けて記述された関数呼び出しは，スコープを抜ける際に実行されるようになります．
要するに関数呼び出しの予約機能みたいなものです．
<code>conn</code> 変数は外部との接続を表す変数であり，Java でファイル操作を行った時と同様に，使い終わったら <code>Close</code> してやる必要があります．
関数の最後に <code>conn.Close()</code> と記述しても同じことですが，できれば変数宣言の近くに <code>Close</code> 指定がある方がプログラムの見通しが良いため，<code>defer</code> を使って事前予約すると良いでしょう．</p>
<p>Go言語 の機能に関する説明もしたため長くなりましたが，このプログラムの一番重要な部分として，47行目において <code>conn</code> にバイト列を書き込んでいるのが確認できます．
ここも Java でファイル操作を行った時と同様に，<code>Write</code> 関数によって接続元，すなわち Client-side アプリケーションにバイト列で応答を返すことができます．
ただし，さきほど動かしてみてわかった通り，Webブラウザには &quot;Hello world.&quot; などとは表示されませんでした．
この原理について以降で説明していきます．</p>
<h2 id="web通信の決まりごと-hypertext-transfer-protocol-http"><a class="header" href="#web通信の決まりごと-hypertext-transfer-protocol-http">Web通信の決まりごと (Hypertext Transfer Protocol; HTTP)</a></h2>
<p>Webアプリケーションは Client-side アプリケーションからの <b>リクエスト (Request)</b> に対し，Server-side アプリケーションが <b>レスポンス (Response)</b> を返す形で成り立っています．
このとき，リクエストおよびレスポンスにはそれぞれ決められた形式 (フォーマット) が存在し，こうした形式などを定めた<b>Web通信における約束事 (プロトコル)</b> を <b>Hypertext Transfer Protocol (HTTP)</b> と呼びます．
HTTP は TCP (Transmission Control Protocol) 上で定められたプロトコルであり，TCP/IPモデルでは第4層「アプリケーション層」，OSI参照モデルでは第7層「アプリケーション層」に位置します．</p>
<p>HTTP は本来 HTML や XML といったWeb通信においてやり取りされる Hypertext と呼ばれるデータ形式を扱うためのプロトコルです．
しかしながら，現実的には画像データや音声データ，映像データなど，Web上で利用される様々な形式のデータ送受信に使用されています．</p>
<p>HTTP は通信技術の向上とともに新たなバージョンがいくつか出されています．
代表的なものとして HTTP/1.1，HTTP/2 などがあり，最近では HTTP/3 が正式に標準化されました (2022年6月6日)．
長きにわたって HTTP/1.1 が最も使用率の高いプロトコルでしたが，近年 HTTP2 の使用率が 50% を超えたらしいです (2021年1月)．</p>
<div class="memo">
一般にネットワーク上を流れるデータはすべて<b>バイト列</b>として表現されるため，Web通信におけるリクエストもレスポンスもデータとしては単なるバイト列として扱われます．
通信されるデータが単なるバイト列なので，さまざまなアプリケーションが好き勝手な形式でリクエストを送ったり，あるいはレスポンスを返したりしてしまうと，アプリケーション開発者としては非常に困ったことになります．
特にWebブラウザのような汎用アプリケーションでは，さまざまな Server-side アプリケーションがそれぞれ独自の形式でレスポンスを返してくるとなると，サービスごとのレスポンス形式を個別に知っておく必要があり，これは相当面倒です．
予めデータのフォーマットを定めておき，それに従わないデータは無視して良いということにすると，なにかと便利なわけです．
<p>よくWebサイトなどのURLの先頭についている <code>http:</code> というのは，HTTPに従った通信であることを明示するものです．
最近では <code>https:</code> とする方が一般的となっていますが，これは HTTP Secure と呼ばれる暗号化された通信経路上で HTTP 通信を行うより安全なプロトコルを表すものです．</p>
</div>
<p>HTTP では，リクエストおよびレスポンスそれぞれについて特定の形式に則って通信を行うよう定めています．
それぞれを一般に <b>HTTPリクエスト</b> および <b>HTTPレスポンス</b> と呼びます．
配布したプログラムがうまく動かなかったのは，どうやらこの辺が原因ではないかと推測できます．</p>
<h3 id="httpリクエスト"><a class="header" href="#httpリクエスト">HTTPリクエスト</a></h3>
<p>HTTPリクエストは，Client-side アプリケーションから Server-side アプリケーションへ送信するリクエストの形式を定めます．
通常は Webブラウザ などが自動的に生成するため，自分で記述する必要はありません．
ただし，専用の Client-side アプリケーションを開発し使用する場合には，サーバへの通信がこの形式に従うよう自身で実装する必要がある場合もあります．</p>
<p>代表的なHTTPリクエストの例を示します．</p>
<pre><code class="language-txt">GET /index.html HTTP/1.1
HOST: 127.0.0.1
Connection: keep-alive

</code></pre>
<pre><code class="language-txt">POST /login HTTP/1.1
`&lt;METHOD&gt;`，`&lt;PATH&gt;`，`&lt;VERSION&gt;` はスペース区切りで識別されます．
したがって，それぞれの項目はスペースを含まない文字列になります．
HOST: 127.0.0.1
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content: multipart/form-data
Content-Length: 38

user=titech&amp;passwd=extremelysafepasswd
</code></pre>
<p>これらの形式を統一的に記述すると以下のようになります．</p>
<pre><code class="language-txt">&lt;METHOD&gt; &lt;PATH&gt; &lt;VERSION&gt;
&lt;HTTP_HEADERS&gt;

&lt;BODY&gt;
</code></pre>
<p>1行目の <code>&lt;METHOD&gt; &lt;PATH&gt; &lt;VERSION&gt;</code> は，<b>リクエストの種類</b>，<b>リクエスト先</b>，および使用する <b>HTTPのバージョン</b> を指定します．
<code>&lt;METHOD&gt;</code> の部分は特に <b>リクエストメソッド</b> と呼ばれ，GET や POST の他に，PUT，DELETE，UPDATE などいくつかの種類が定義されています．
<code>&lt;PATH&gt;</code> の部分はリクエストを送信する対象であるリソースを指定します．
<code>&lt;VERSION&gt;</code> 部分は主に HTTP/1.1 あるいは HTTP/2 である場合が多く，バージョンによって使用できる機能に若干の違いがあるため，ここの指定によって特定の機能が有効か無効かを確認します．
<code>&lt;METHOD&gt;</code>，<code>&lt;PATH&gt;</code>，<code>&lt;VERSION&gt;</code> はスペース区切りで識別されます．
したがって，それぞれの項目はスペースを含まない文字列になります．</p>
<p>2行目の <code>&lt;HTTP_HEADERS&gt;</code> はHTTP/1.1以降で有効になった機能であり，サーバ側へリクエストに関するメタ情報を送る役割を持ちます．
形式として，1行に1つの「key」と「value」のペアを記述でき，<code>&lt;key&gt;: &lt;value&gt;</code> のようにコロン区切りで記述します．
ここは複数行にわたってメタ情報を載せることができ，以下の通り役割によって分類されたいくつかのヘッダ情報を組合せて記述されることが多くなっています．</p>
<ul>
<li>Request headers
<ul>
<li>リクエストに直接関わる情報</li>
<li>HOST や User-Agent といった key が該当する</li>
</ul>
</li>
<li>General headers
<ul>
<li>通信設定などの情報</li>
</ul>
</li>
<li>Representation headers
<ul>
<li><code>&lt;BODY&gt;</code> の形式などに関わる情報</li>
</ul>
</li>
</ul>
<p><code>&lt;HTTP_HEADERS&gt;</code> と <code>&lt;BODY&gt;</code> の間の空行は必須です．
この空行が存在することで，リクエスト中のどこからが <code>&lt;BODY&gt;</code> であるかを判断します．</p>
<p><code>&lt;BODY&gt;</code> はリクエストとしてサーバへ送信される情報そのものを載せる区画になります．
リクエストメソッドが GET である場合には一般に <code>&lt;BODY&gt;</code> は空，すなわちなにも記述されずに送られることが多いですが，もちろん GET リクエストにも <code>&lt;BODY&gt;</code> を載せることはできます．
また，<code>&lt;BODY&gt;</code> の長さ (バイト長) がわからなければ Server-side アプリケーションでどこまで読むべきかを判定できない場合があるため，<code>&lt;REQUEST_HEADERS&gt;</code> 上に <code>Content-Length</code> を key とする長さ情報を付与して送るのが一般的です．</p>
<div class="memo">
<code class="hljs">Content-Length</code> に設定される値は <code class="hljs">&lt;BODY&gt;</code> の<b>byte長</b>であり<b>見かけの文字数とは必ずしも一致しない</b>ことに注意が必要です．
特に日本語などのマルチバイト文字を扱う場合，1文字を複数バイトで表現するため，見かけの文字数とbyte長は一般に一致しません．
</div>
<h5 id="練習問題-2-1"><a class="header" href="#練習問題-2-1">練習問題 2-1</a></h5>
<p>実際にWebブラウザから送られてくるHTTPリクエストを観察してみましょう．</p>
<p>httpserver.go/main.go 内の <code>handleConnection</code> 関数を以下のように編集した上で，プログラムを実行してください．
Webブラウザからのアクセスに対してどのようなログが表示されるか観察し，Webブラウザがたしかに形式的に正しいHTTPリクエストを送信していることを確かめてください．</p>
<pre><code class="language-go">func handleConnection(conn net.Conn) {
    // close connection when this function ends
    defer conn.Close()

    buf := make([]byte, 1024)
    conn.Read(buf)

    log.Printf(&quot;Request\n----------\n%s\n----------&quot;, string(buf))

    // write response
    conn.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<p>このプログラムは，<code>buf := make([]byte, 1024)</code> にてリクエストを読み込むための領域を1024バイト分だけ確保し，<code>conn.Read(buf)</code> によってリクエスト全体を <code>buf</code> へ読み込んでいます．
<code>net.Conn.Read</code> メソッドは本来戻り値として読み込んだ byte 長とエラー情報を返しますが，ここでは特に使用しないため無視しています．
<code>log.Printf</code> 関数によってリクエストの内容を整形してログとして出力しますが，<code>buf</code> は <code>[]byte</code> 型の変数であるため <code>string(buf)</code> として文字列へ変換して渡しています．
なお，今回の例ではおそらく1024バイトもあれば足りるであろうと考えて読み込み処理について少し手を抜いていますが，本来はより長いリクエストにも対応できるよう工夫する必要があります．</p>
<h3 id="httpレスポンス"><a class="header" href="#httpレスポンス">HTTPレスポンス</a></h3>
<p>HTTPレスポンスは，Server-side アプリケーションから Client-side アプリケーションへ送信するレスポンスの形式を定めます．
ここまで来たらお気づきだと思いますが，配布したプログラムはHTTPレスポンスとして定められた形式に従った応答を返していないため，Webブラウザ上にて何も表示されない状態となっています．</p>
<p>HTTPレスポンスは以下の形式をとります．</p>
<pre><code class="language-txt">&lt;VERSION&gt; &lt;STATUS_CODE&gt; &lt;REASON_PHRASE&gt;
&lt;HTTP_HEADERS&gt;

&lt;BODY&gt;
</code></pre>
<p>1行目の <code>&lt;VERSION&gt; &lt;STATUS_CODE&gt; &lt;REASON_PHRASE&gt;</code> は <b>Status line</b> と呼ばれ，リクエストに対する処理の状態 (処理の成功・失敗など) を Client-side アプリケーションへ通知します．
<code>&lt;VERSION&gt;</code> はHTTPリクエストと同様に使用するプロトコルのバージョンを宣言します．
<code>&lt;STATUS_CODE&gt;</code> および <code>&lt;REASON_PHRASE&gt;</code> には，リクエスト処理の状態に応じて予め定義された数値と文字列のペアを書き込みます．
よく見かける例としては，<code>200 OK</code> や <code>404 Not Found</code> などが挙げられます．
HTTPリクエストの1行目と同様に，<code>&lt;VERSION&gt;</code>，<code>&lt;STATUS_CODE&gt;</code>，<code>&lt;REASON_PHRASE&gt;</code> はスペース区切りで識別され，<code>&lt;VERSION&gt;</code> はスペースを含まない文字列，<code>&lt;STATUS_CODE&gt;</code> は3桁の整数値で定義されます．
<code>&lt;REASON_PHRASE&gt;</code> については，末尾であり解釈時に曖昧性をもたないため，空白を含むことを許容した文字列とされています．
有効な <code>&lt;STATUS_CODE&gt;</code> と <code>&lt;REASON_PHRASE&gt;</code> の組合せについては，<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.1">RFC7231</a> に定義されています．</p>
<p><code>&lt;HTTP_HEADRS&gt;</code> および <code>&lt;BODY&gt;</code> については，HTTPリクエストと同様です．
また，HTTPリクエストと同様に <code>&lt;HTTP_HEADERS&gt;</code> と <code>&lt;BODY&gt;</code> の間の空行は必須です．
Webブラウザでは一般に <code>&lt;BODY&gt;</code> の部分が画面上に表示されます．</p>
<p>HTTPリクエストの形式がわかったところで，配布したプログラムを修正してWebブラウザ上に &quot;Hello world.&quot; を表示できるようにしてみましょう．
この項目は以下の通り練習問題とします．</p>
<h5 id="練習問題-2-2"><a class="header" href="#練習問題-2-2">練習問題 2-2</a></h5>
<p>配布したプロジェクト httpserver.go について，適切なHTTPレスポンスを返すようプログラムを修正し，Webブラウザ上に &quot;Hello world.&quot; の文字列を表示できるようにします．
なお，この練習問題は以下のヒントを参考に各自で解いてみましょう．</p>
<ul>
<li>HTTPレスポンスは <code>net.Conn.Write</code> メソッドを使用することで，バイト列として Client-side アプリケーションへ書き出すことができる．具体的には，配布プログラム中の <code>handleConnection</code> 関数内に記述された <code>conn.Write</code> のメソッド呼び出しを真似すると良い．</li>
<li>HTTPレスポンスの <code>&lt;HTTP_HEADERS&gt;</code> として <code>&lt;BODY&gt;</code> の長さを指定すること．このとき Go言語 において，<code>[]byte</code> 型の長さ (byte長) は Python と同様に組み込み関数 <code>len</code> によって取得できる．</li>
</ul>
<h2 id="アクセス先の制御-ルーティング"><a class="header" href="#アクセス先の制御-ルーティング">アクセス先の制御 (ルーティング)</a></h2>
<p>多くのWebアプリケーションは，HTTPリクエストの内容に応じて様々な処理を行います．
こうしたリクエストの内容に応じた処理の分岐を一般に <b>ルーティング (Routing)</b> と呼びます．</p>
<p>ルーティングはWebアプリケーションの使いやすさに影響を与えるのはもちろんとして，開発にも影響を及ぼします．
適切なルーティングが為されていない場合，アプリケーションが実行すべき処理の流れが追いづらく，使う側および作る側の双方にとって嬉しくない状態となってしまいます．</p>
<p>通常のルーティングでは，HTTPリクエストの持つアクセスメソッド <code>&lt;METHOD&gt;</code> とアクセスパス <code>&lt;PATH&gt;</code> の組合せに基づいて処理を分岐します．
すなわち，たとえば <code>/</code> に対する GETリクエスト と <code>/</code> に対する POSTリクエストとでは別の処理を実行するなど，同じパスでもメソッドの違いによって処理を変えることが可能です．</p>
<p>ルーティングについては，単純にHTTPリクエスト中の <code>&lt;METHOD&gt;</code> と <code>&lt;PATH&gt;</code> を確認し，<b>条件分岐</b>によって処理を変えているだけと考えることができます．
したがって，ここでは実際に以下の練習問題に取り組んでもらい，ルーティングの理解を深めるとともに Go言語 により一層慣れるための機会にしてもらえればと思います．</p>
<h5 id="練習問題-2-3"><a class="header" href="#練習問題-2-3">練習問題 2-3</a></h5>
<p>以下の仕様を満たすようルーティングを実装し，動作確認をしてください．
なお，現在までの内容ではWebブラウザから送信されるリクエストのメソッドは基本的に GET になってしまうため，ここではメソッドの違いによるルーティングは考慮しなくてよいものとします．</p>
<ul>
<li>Webブラウザから <code>localhost:8000/hello</code> にアクセスした場合，&quot;Hello world.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/bye</code> にアクセスした場合，&quot;Good bye.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/hello.jp</code> にアクセスした場合，日本語で &quot;こんにちは&quot; と表示される．</li>
<li>Webブラウザから上記以外のリソースにアクセスした場合，ページが見つからない旨を Client-side に通知する．</li>
</ul>
<p>なお，この練習問題も以下のヒントをもとに各自で解いてみましょう．</p>
<ul>
<li>文字列の分割は <code>strings</code> パッケージ内の <code>strings.Split</code> 関数にて行うことができる．この関数は，第1引数として文字列，第2引数として区切り文字を受け取り，文字列のスライスを返す．</li>
<li>アクセス先のパス (<code>/hello</code> など) は，HTTPリクエストの1行目に記述されている．</li>
<li>Go言語 での条件分岐には，<code>if</code> または <code>switch</code> を使用する．</li>
</ul>
<div class="memo">
今後演習を進めていくにあたり，標準ライブラリやサードパーティライブラリにどのような関数・構造体・メソッドが定義されているかを調べる必要が出てくるかと思います．
Go言語 では便利なことに，だいたいのパッケージを網羅したWebサイトが存在し，関数の定義や場合によってはサンプルコードなどを調べることができます．<br>
<a href="https://pkg.go.dev">Go言語パッケージドキュメントサイト</a>
</div>
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<p>今回はWebアプリケーションを支えるWeb通信の仕組みについて扱いました．
配布したプログラムは最低限の機能しか持たないため，これをベースとしてWebアプリケーションを構築するのはかなり難しいと感じたかもしれません．</p>
<p>次回は，Webアプリケーション開発をより簡単にする仕組みについて触れます．
また，Client-side アプリケーションから Server-side アプリケーションへ情報を送信する方法について扱い，より実用的なアプリケーションを開発できる体制を整えていきます．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-webアプリケーションフレームワーク"><a class="header" href="#03-webアプリケーションフレームワーク">03: Webアプリケーションフレームワーク</a></h1>
<p><a href="02_http_and_routing.html">前回</a>は，Webアプリケーションを支えるHTTP通信の仕組みや，アプリケーション開発時に使用するであろう基本的なルーティングの方法について扱いました．</p>
<p>今回は以下の内容を通して，開発効率の向上およびユーザとのインタラクションについて扱います．</p>
<ol>
<li>Web Applicaion Framework</li>
<li>Hypertext Markup Language (HTML)</li>
<li>formタグを用いたHTTP POST</li>
</ol>
<p>また今回から3回に分けて，新たなプロジェクトをベースとして演習を進めます．
以下のリンクより新しいプロジェクト formapp.go をダウンロードし，演習が進められるよう展開・配置してください．</p>
<p><a href="https://github.com/cs-sysdes/formapp.go">https://github.com/cs-sysdes/formapp.go</a></p>
<p>ダウンロード方法は <a href="01_preliminary.html">第1回資料</a> を参照してください．</p>
<h2 id="web-application-framework"><a class="header" href="#web-application-framework">Web Application Framework</a></h2>
<p>前回配布したプログラムは基礎的なHTTPサーバ機能しか持たず，ルーティングのために自分でHTTPリクエストを解析したり，適切なHTTPレスポンスを返すようヘッダ情報を追加したりといった処理を自分で実装する必要がありました．
今後，より複雑な機能を持った実用的なWebアプリケーションを開発していくにあたって，こうした処理を開発者自身が毎回行うのは面倒ですし，ミスが起こりやすく非効率的です．</p>
<p>こうしたWebアプリケーション開発において常に必要となる共通処理をまとめたライブラリや，必要に応じて開発を支援する仕組みなどを集めたものを，一般に <b>Web Application Framework (WAF)</b> あるいは単に Web Framework と呼びます．
多くのWAFは適切なHTTPレスポンスを簡単に返すことができる仕組みや，HTMLページの生成を補助する仕組みを持っており，Webアプリケーション開発において面倒な部分を肩代わりしてくれます．</p>
<p>現代のWebアプリケーション開発においてはなにかしらのWAFをベースに開発が行われている場合が多いです．
有名どころでは以下のようなWAFが対応する各プログラミング言語と組合せて実際に使われています．</p>
<div class="table-wrapper"><table><thead><tr><th>WAF</th><th>Language</th></tr></thead><tbody>
<tr><td>Drogon</td><td>C++</td></tr>
<tr><td>Spring</td><td>Java</td></tr>
<tr><td>Play</td><td>Java,Scala</td></tr>
<tr><td>Rails</td><td>Ruby</td></tr>
<tr><td>Laravel</td><td>PHP</td></tr>
<tr><td>Phoenix</td><td>Elixir</td></tr>
<tr><td>Django</td><td>Python</td></tr>
</tbody></table>
</div>
<p>一方で，Go言語 は Google によって開発がすすめられた比較的新しい言語である背景から，Web周りのサポートが他の言語と比べても非常に充実しています．
実際WAFに頼らなくても，標準パッケージ <code>net/http</code> だけでも十分にWebアプリケーションの開発が可能です．
Go言語に対応するWAFには <code>net/http</code> パッケージに薄い wrapper を追加する程度のものも多く，こういった点からも標準パッケージによるサポートの強さがわかります．</p>
<p>以下ではまず，標準パッケージ <code>net/http</code> を用いたHTTPサーバ実装の例を示します，
この例の中で <code>net/http</code> の便利さを理解してもらった上で，実は少し使いづらい部分なども紹介し，以降の演習にて扱う Go言語 向けのWAF: <a href="https://github.com/gin-gonic/gin">Gin</a> を導入します．</p>
<h3 id="標準パッケージ-nethttp"><a class="header" href="#標準パッケージ-nethttp">標準パッケージ <code>net/http</code></a></h3>
<p><code>net/http</code> パッケージを使用して，<a href="02_http_and_routing.html">前回資料</a> と同様に localhost:8000/ に GET リクエストが来た場合に &quot;Hello world.&quot; を表示するWebサーバを構築してみます．
具体的には，以下のようなコードになります．
これは説明の都合上示した例ですので，今回配布した formapp.go 内に以下を実装する必要はありません．</p>
<pre><code class="language-go">package main

import &quot;net/http&quot;

func main() {
    http.HandleFunc(&quot;/&quot;, rootHandler)
    http.ListenAndServe(&quot;:8000&quot;, nil)
}

func rootHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL != &quot;/&quot; {
        w.WriteHeader(http.StatusNotFound)
        return
    }
    if r.Method != &quot;GET&quot; {
        w.WriteHeader(http.StatusMethodNotFound)
        return
    }
    w.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<div class="memo">
蛇足ですが，11 行目および 15 行目の条件分岐ですが，こうした場合はおそらく <code class="hljs go">switch</code> を使った方が楽でしょう．
</div>
<p>一見して <code>main</code> 関数がすっきりしたことがわかります．
前回配布したプログラムでは，通信を受けるソケットを用意したり，接続を待ち受けたりといった動作をすべて記述していましたが，今回の例ではそうした面倒な記述がすべて 7 行目の <code>http.ListenAndServe</code> 関数呼び出しにて済んでいます．</p>
<p>また，<code>net/http</code> パッケージはルーティングの機能を<b>パスと対応する処理のペア</b>を登録する形式で提供しています．
6 行目に示す <code>http.HandleFunc</code> 関数は引数としてパスと指定された形式のコールバック関数を受け取り，リクエストパスが &quot;/&quot; であるリクエストは <code>rootHandler</code> 関数に処理を任せるものとしてルーティング設定を登録します．</p>
<p>コールバック関数として登録される <code>rootHandler</code> 関数は，引数として <code>http.ResponseWriter</code> および <code>*http.Request</code> の 2 つの構造体をとります．</p>
<p>第1引数である <code>http.ResponseWriter</code> 型の変数 <code>w</code> は，HTTPレスポンスとしてヘッダ情報や BODY を書き込むための変数であり，12 行目や 16 行目のように<code>http.ResponseWriter.WriteHeader</code> メソッドによって BODY が空のヘッダ情報だけを返すことができたり，19 行目のように <code>http.ResponseWriter.Write</code> メソッドによって BODY を含めたレスポンスを返すことができます．
なお，<code>http.ResponseWriter.Write</code> 関数は，引数によって渡された BODY に喜寿されるべきバイト列から自動で <code>Content-Length</code> の値を計算し，HTTP header としてレスポンスに含めてくれます．</p>
<p>第2引数である <code>*http.Request</code> 型の変数 <code>r</code> は，HTTPリクエストを格納している変数であり，パスやメソッドなどの情報はすでにパースされて構造体のメンバとして保存されています．
前回のプログラムでは自分で <code>strings.Split</code> 関数などを用いてメソッドの種類やパスを取得する必要がありましたが，<code>http.Request</code> を介することで，<code>http.Request.Method</code> や <code>http.Request.URL</code> などによってメソッドやパスを直接参照することができるようになっています．</p>
<p>ここまでを見ると，<code>net/http</code> パッケージはこれだけでも十分に便利な気がしてきます．
一方で，11 行目の条件分岐について何か違和感がないでしょうか．
6 行目ですでに &quot;/&quot; に対するルーティングとしてパスを検査しているにもかかわらず，再びここでパスを検査しています．
一見すると無意味な条件分岐にも見えますが，実はきちんと意味のある条件分岐です．</p>
<p>6 行目 <code>http.HandleFunc</code> 関数の第1引数は，<strong>最長一致</strong> の原則を採用しています．
すなわち，6 行目の設定だけでは，&quot;/&quot; が引っかかるのはもちろんですが &quot;/hello&quot; や &quot;/bye&quot; でも先頭の &quot;/&quot; は一致しているので <code>rootHandler</code> 関数が呼び出されてしまいます．
ここでは，&quot;/&quot; だけに限定して &quot;Hello world.&quot; を返したいので，11 行目のように正確なパス検査を入れる必要があります．
また，メソッドによる分岐も 15 行目のように <code>http.Request.Method</code> を参照して設定する必要があります．</p>
<p>このように <code>net/http</code> パッケージは<a href="02_http_and_routing.html">前回</a>配布した httpserver.go よりは便利ですが，いろいろと足りない部分などがあります．
特に <code>net/http</code> パッケージの持つルーティング機能はやや遅い (計算コストが高い) ことが知られており，こうしたちょっとした面倒さやアプリケーションの応答速度などを気にする場合には，さらに別のWAFの使用が検討されます．</p>
<h3 id="gin-web-framework"><a class="header" href="#gin-web-framework">Gin Web Framework</a></h3>
<p><a href="https://github.com/gin-gonic/gin">Gin</a> は Go言語 によって記述された代表的WAFの1つです．
基礎的なHTTPサーバ機能として，標準パッケージ <code>net/http</code> に代えて <a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> を使用し，高速に動作するよう設計されています．</p>
<p>Gin を用いて先ほど示した localhost:8000/ へのGETリクエストに対して &quot;Hello world.&quot; を返すHTTPサーバを実装した例を以下に示します．
なお，この例は今回配布した formapp.go が持つ main.go ファイルを簡略化したものになっています．</p>
<pre><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;  // ginパッケージをimport
)

func main() {
    engine := gin.Default()
    engine.GET(&quot;/&quot;, rootHandler)
    engine.Run(&quot;:8000&quot;, nil)
}

func rootHandler(ctx *gin.Context) {
    ctx.String(http.StatusOK, &quot;Hello world.&quot;)
}
</code></pre>
<p><code>main</code> 関数に注目すると，<code>net/http</code> パッケージを使用した場合とほとんど変わりません．
ただし 10 行目のように，Gin ではHTTPメソッドを指定したルーティングを記述することができます．
また <code>net/http</code> の場合とは異なり，パスとして &quot;/&quot; と指定した場合，これは基本的に &quot;/&quot; にしかマッチしません．
これにより，先ほどのように追加条件をコールバック関数側で記述する必要がなくなるため，&quot;/&quot; へのGETリクエストに対して呼び出されるコールバック関数 <code>handleRoot</code> (14--16行目) をかなり簡単に書くことができます．</p>
<p>コールバック関数の形式も先ほどとは異なり，引数として <code>*gin.Context</code> 型の変数のみをとる関数になります．
<code>gin.Context</code> は，HTTPリクエストとHTTPレスポンスを合わせたような構造体だと理解しておけば良いかと思います．
今回は文字列として &quot;Hello world.&quot; を返したいので，15行目のように <code>gin.Context.String</code> メソッドを用いてHTTPレスポンスの種類と内容を指定しています．
より具体的に書けば，Content-Type として String = text/plain を指定し，BODYとして &quot;Hello world.&quot; を持つHTTPレスポンスを生成します．
当然ながら，Content-Length は自動計算されます．</p>
<p>Gin はこのようにライブラリとして便利な機能を提供するだけではなく，Framework として開発を支援する機能をいくつか提供します．
代表的な機能の一つに Middleware の挿入という機能があり，以下のようにルーティングの前後にアプリケーション全体で共通する処理を挟むこむことができます．
この機能により，たとえばユーザ認証を必要とするアプリケーションではルーティング前に認証処理を挟むことによってルーティング後の特定の処理と全体での共通処理を分離でき，見通しの良いアプリケーションの設計が可能になります．
この演習中に middleware に触れるところまで進めるかはわかりませんが，こういうこともできるということだけ頭の片隅に置いておくとよいでしょう．</p>
<p><img src="img/middleware.png" alt="Middlewares on Gin framework" /></p>
<p>Go言語 で記述されたWAFとしては，他にも <a href="https://github.com/labstack/echo">Echo</a> などが有名ですが，本演習では Gin を扱うこととします．
Echo にも Gin と同様に middleware を扱う仕組みが存在し，全体的な使用感も Gin と大きく差があるわけではありません．</p>
<h5 id="練習問題-3-1"><a class="header" href="#練習問題-3-1">練習問題 3-1</a></h5>
<p>formapp.go/main.go を編集し，<a href="02_http_and_routing.html">前回資料</a>において示した 練習問題 2-3 の内容を，Gin を用いてプログラムしてみましょう．
具体的には，以下の要求を満たすよう formapp.go/main.go を編集してください．</p>
<ul>
<li>Webブラウザから <code>localhost:8000/hello</code> にアクセスした場合，&quot;Hello world.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/bye</code> にアクセスした場合，&quot;Good bye.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/hello.jp</code> にアクセスした場合，日本語で &quot;こんにちは&quot; と表示される．</li>
</ul>
<p>Gin を使用する場合，1つのルーティング (HTTPメソッドとパスの組) に対して対応する1つのコールバック関数を定義する必要があります．
必要に応じてコールバック関数を新たに定義し，ルーティングのルールを追加することで目的の処理を実装することができます．
関数名などは特に指定しませんが，わかりやすい名前を付けると良いでしょう．</p>
<h2 id="hypertext-markup-language-html"><a class="header" href="#hypertext-markup-language-html">Hypertext Markup Language (HTML)</a></h2>
<p>ここまでのプログラムは文字列を Client-side に返してきました．
したがって，Webブラウザ上に表示される結果も単なる文字列であり，なかなかに質素なものだったと思います．
一方で，たとえばこの演習資料のように，多くのWebページには見出しやリンク，パラグラフなどが存在しています．
ここでは，こうした構造化された文書を Client-side に返す方法について扱います．</p>
<p>Webサイトのように電子デバイス上での閲覧を想定した，複数のテキストを即時利用可能な形式でリンクした文書形式を一般に <b>Hypertext</b> と呼びます．
またこうした Hypertext を記述するための形式言語を <b>Hypertext Markup Language (HTML)</b> と呼び，Webページは通常このHTMLによって記述されます．</p>
<p>HTMLでは文書を原則として木構造で表現し，木構造を構成する節や葉は <b>タグ (tag)</b> によって文書構造中に配置されます．
例としてWebブラウザに &quot;Hello world.&quot; とだけ表示するHTMLを以下に示します．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        Hello world.
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>1 行目の <code>&lt;!DOCTYPE html&gt;</code> は<strong>文書型宣言</strong>と呼ばれ，これはタグではありません．
ここではこの文書がHTML，より具体的にはHTML5によって書かれていることを宣言しており，HTMLのバージョンによって書き方が少し異なります．
現在ではHTML5を使用するのが標準ですので，他のバージョンの書き方は特に覚えなくてもよいでしょう．</p>
<p>2 行目の <code>&lt;html&gt;</code> は，HTML要素と呼ばれる木構造における根の役割を持つ要素の宣言をするタグです．
この <code>&lt;html&gt;</code> タグは 6 行目の <code>&lt;/html&gt;</code> とペアになっており，一般に前者を「開始タグ」，後者を「閉じタグ」などと呼びます．
HTMLにおける節や葉の多くは開始タグと閉じタグのペアで構成され，タグが入れ子 (ネスト)  になっている場合は外側のタグが親，内側のタグが子となる親子関係を表します．
たとえば，3 行目に出現する <code>&lt;body&gt;</code> タグは <code>&lt;html&gt;</code> タグの子になります．
したがって，このHTMLは <code>&lt;html&gt;</code> 要素が根であり，唯一の葉として <code>&lt;body&gt;</code> 要素を持つ木構造であることがわかります．
注意点として，HTMLには一部単独で存在することのできるタグがあり，こうしたタグは基本的に子要素を持たないため，木構造における節になることがありません．</p>
<p><code>&lt;body&gt;</code> はBody要素と呼ばれ，Webブラウザが画面上に表示する文書パーツを表します．
このHTMLはBody要素内にプレーンテキストで &quot;Hello world.&quot; だけを持つので，Webブラウザ上に &quot;Hello world.&quot; と表示するだけのものとなります．
HTMLは基本的にインデントを無視するので，&quot;Hello world.&quot; の前に余計なスペースが入ることはありません (インデントを含めて見た目通り出力する方法もあります)．</p>
<p>多くの場合HTML文書にはBody要素のほかにHead要素と呼ばれるパーツが配置され，たとえば以下のような形式をしています．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;formapp.go&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello world.
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>&lt;head&gt;</code> タグによってHTML要素直下に配置されるHead要素は，通常そのままWebブラウザ上に表示されることはありません．
Head要素はそのページを構成するメタ情報などを記載する場所とされており，たとえば 4 行目の <code>&lt;title&gt;</code> タグはWebブラウザのタブ上などに表示するWebページのタイトルを設定するための記述です．
この他にも，ページ全体の文字コードの指定や関連する外部ファイルの取り込みに関する情報が記載されている場合が多いです．</p>
<p>試しにこの演習資料のHTMLソースコードを眺めてみると良いかもしれません．
Webブラウザによって方法が異なりますが，だいたいの場合ページ上で右クリックをすると出現するメニュー内に「このページのソースを表示」などの項目があると思います．
割と複雑なHTMLが表示されますが，当然すべて教員が心を込めて手入力した温もりあるHTMLというわけではありません．
一部実際に手動入力している部分もありますが，ほとんど自動生成です．</p>
<p>HTMLで使用できるタグには様々な種類があり，それぞれ特定の用途が定められています．
なかには文書中における役割を明示するタグなどもあり，こうしたタグを適切に使用することで文書に対して意味的な構造を与えることも可能です．
詳細は <a href="https://w3schools.com/html/default.asp">HTML | w3schools.com</a> などを参考に各自で学習を進めて下さい．</p>
<p>WebブラウザはこうしたHTML文書を解析し，画面上に描画する機能をもったアプリケーションです．
しかしながら，HTMLの機能だけでは人間に優しい表示を制御することは難しいので，JavaScript や CSS などを併用してより可読性が高く使いやすいWebページにできるよう開発者が努力しています．</p>
<h3 id="ginでhtmlを返す"><a class="header" href="#ginでhtmlを返す">GinでHTMLを返す</a></h3>
<p>それではこれまで無機質な文字列だけを返していたプログラムを編集し，HTMLを返してみます．
とりあえず，HTMLを文字列として直接プログラム中に埋め込めば目的は達成できそうです．</p>
<pre><code class="language-go">func rootHandler(ctx *gin.Context) {
    ctx.String(http.StatusOK, &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;...&quot;)
}
</code></pre>
<p>この方法には明らかな問題があります．
<code>gin.Context.String</code> メソッドは HTTP header に <code>Content-Type: text/plain</code> を設定してしまうため，WebブラウザによってはHTML文書ではなく単なるプレーンテキストとして認識されてしまい，正しく描画されないことがあります．
正しいレスポンスとして設定されるべきは <code>Content-Type: text/html</code> です．
また，HTMLを文字列として書くとシンタックスハイライトも効かないし書くの怠いですよね．
Content-Type を変更する方法はいくつか存在しますが，もっと良い方法があればそちらを使いたいです．</p>
<p>より良さそうな方法として，返したいHTML文書を別ファイルで用意し，そのファイルをプログラム中で読み込んでHTTPレスポンスとして返す方法を考えます．
formapp.go/templates の中に，すでにいくつかのサンプルHTML文書を配置していますので，これを使いましょう．
たとえば以下のような形式になると良さそうです．</p>
<pre><code class="language-go">// このコードは嘘のコードです
func rootHandler(ctx *gin.Context) {
    html := file.Read(&quot;templates/hello.html&quot;)
    ctx.String(http.StatusOK, html)
}
</code></pre>
<p>先ほどよりは筋がよさそうですが，Gin は Web Framework としてもっと良い方法を提供しています．
以下のコードでは <code>package main</code> などの共通部分を省略しています．</p>
<pre><code class="language-go">func main() {
    engine := gin.Default()
    engine.LoadHTMLGlob(&quot;templates/*.html&quot;)
    engine.GET(&quot;/&quot;, rootHandler)
    engine.Run(&quot;:8000&quot;, nil)
}

func rootHandler(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;hello.html&quot;, nil)
}
</code></pre>
<p>重要な変更点は 3 行目 <code>engine.LoadHTMLGlob(&quot;templates/*.html&quot;)</code> および 9 行目 <code>ctx.HTML(http.StatusOK, &quot;hello.html&quot;, nil)</code> の2点です．</p>
<p>9 行目のHTTPレスポンスを設定している部分から説明します．
先ほどまでのプログラムでは，<code>gin.Context.String</code> メソッドを使用して <code>Content-Type: text/plain</code> となる文字列データをHTTPレスポンスに設定していました．
一方今回は，<code>gin.Context.HTML</code> メソッドを使用することで，<code>Content-Type: text/html</code> となるHTML文書をレスポンスに設定しています．
<code>gin.Context.HTML</code> メソッドは，第1引数としてHTTPステータスコード，第2引数として返すHTML文書のファイル名を取ります．
第3引数は今回使用しないので <code>nil</code> を渡しています．
このメソッドは第1引数で渡されたHTTPステータスコードをともなって，第2引数で渡されたファイルに従って生成したHTML文書をHTTPレスポンスとして返します．
すなわち，先ほど紹介したファイルを読み込んで返すという動作ができているということになります．</p>
<p><code>gin.Context.HTML</code> ではファイル名を渡しましたが，このファイル名から当該ファイルを見つけるための設定が 3 行目の <code>engine.LoadHTMLGlob(&quot;templates/*.html&quot;)</code> になります．
この関数は templates ディレクトリ内のHTMLファイルをアプリケーションに登録し，ファイル名からの検索対象に含めるために呼び出しています．
すなわち，ここで登録したファイルであれば <code>gin.Context.HTML</code> メソッドからファイル名によって使用することができるということです．</p>
<p>この方法は Gin Web Framework 特有の方法ですが，他のFrameworkでも同様の方法が提供されていることが多いと思われます．</p>
<h5 id="練習問題-3-2"><a class="header" href="#練習問題-3-2">練習問題 3-2</a></h5>
<p>練習問題 3-1 の内容を，それぞれ対応するHTMLファイルを作成したうえで，<code>gin.Context.HTML</code> メソッドによってHTML文書を返す方法に書き変えてみましょう．</p>
<h2 id="formタグを用いたhttp-post"><a class="header" href="#formタグを用いたhttp-post">formタグを用いたHTTP POST</a></h2>
<p>Server-side から Client-side へHTML文書を送ることができるようになったので，今度は逆に Client-side から何かしらの入力情報を Server-side に送ってみます．
こうした情報送信にはHTMLタグの一つである <code>form</code> タグが使用できます．
<code>form</code> タグの使い方を見るため，プログラムに少し修正を加えます．</p>
<p><code>main</code> 関数内に以下のルーティングを登録してください．</p>
<pre><code class="language-go">engine.GET(&quot;/name-form&quot;, nameFormHandler)
engine.POST(&quot;/register-name&quot;, registerNameHandler)
</code></pre>
<p>また，以下の関数をファイル内に定義してください．</p>
<pre><code class="language-go">func nameFormHandler(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;name_form.html&quot;, nil)
}

func registerNameHandler(ctx *gin.Context) {
    body, _ := ctx.GetRawData()
    ctx.String(http.StatusOK, string(body))
}
</code></pre>
<p>Webブラウザから localhost:8000/name-form にアクセスすると，以下のような入力画面が表示されるはずです．
入力欄に適当な名前を入力後，送信ボタンを押してどうなるか観察してみましょう．
このとき，入力として英数字のみを入れた場合と，漢字やひらがな，スペース (空白文字) などを含めた場合とで結果に違いが出るか確認してください．</p>
<p>例として，入力欄に「東工大」といれて送信した場合，次の画面に以下のような表示が出ると思います．</p>
<pre><code>name=%E6%9D%B1%E5%B7%A5%E5%A4%A7
</code></pre>
<p>これについて次の節で説明します．</p>
<h3 id="content-type-applicationx-www-form-urlencoded"><a class="header" href="#content-type-applicationx-www-form-urlencoded">Content-Type: application/x-www-form-urlencoded</a></h3>
<p><code>form</code>タグから送られたデータは，基本的に <code>key=value&amp;key2=value2&amp;...</code> という形式でサーバへ送信されます．
今回の例では，<code>form</code> タグから <code>name</code> という key で入力値を送っているため，<code>name=&lt;入力値&gt;</code> という形でサーバへ情報が送られてきます．</p>
<p>このとき，HTTPではURLなどの文字列において，たとえばスペースや「@」などの通常使用できない文字が存在します．
こうした文字は通信可能な形式に変換 (encode) された上で送信されるため，正しく解釈するには受信側で逆変換 (decode) してやる必要があります．
日本語のようなマルチバイト文字は基本的に<code>%..</code>のような形式に変換されるため，「東工大」と入力したものをそのまま表示しようとすると怪しい文字列になるわけです．</p>
<p>逆変換のためには，たとえば Java では <code>java.net.URLDecoder</code> というクラスなどが用意されていますが，Go言語ではより扱いを簡単にするために，<code>gin.Context</code> のメソッドとして指定した key に対応する value を自動的に逆変換して返す <code>GetPostForm</code> メソッドが存在します．
したがって，<code>registerNameHandler</code> 関数を以下のように書き変えると適切な表示に変換されるはずです．</p>
<pre><code class="language-go">func registerNameHandler(ctx *gin.Context) {
    name, _ := ctx.GetPostForm(&quot;name&quot;)
    ctx.String(http.StatusOK, name)
}
</code></pre>
<p>このメソッドが存在することによって，<code>key1=value1&amp;key2=value2&amp;key3=value3</code> などのような情報が送られてきた場合でも，&quot;&amp;&quot; で分割して decode して...などとしなくても簡単に目的の値を取り出すことができます．
なお，<code>gin.Context.GetPostForm</code> メソッドは，指定した key が存在しない場合に第2戻り値として <code>false</code> を返すため，これを使用して key の存在判定を行うことができます．</p>
<h3 id="htmlへの値の埋め込み"><a class="header" href="#htmlへの値の埋め込み">HTMLへの値の埋め込み</a></h3>
<p><code>registerNameHandler</code> は送られてきた入力値を文字列で返しているだけなので，これをHTMLで返すように変更しましょう．
Go言語のHTMLテンプレート機能には，HTMLファイル中に変数の値などを埋め込む機能があるため，これを使用してHTML文書中に送信されてきた名前情報を入れてみます．</p>
<p>templates/result.html は以下のようなHTML文書 (のテンプレート) になっています．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Result | formapp.go&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;入力結果&lt;/h1&gt;
        &lt;dl&gt;
            &lt;dt&gt;名前&lt;/dt&gt;
            &lt;dd&gt;{{ .Name }}&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>詳しい構造の説明は省略しますが，10 行目に見慣れない表現 <code>{{ .Name }}</code> があります．
これはHTML文書中に変数の値を埋め込むための構文です．
このHTMLテンプレートを使用して，入力結果をHTMLで返す <code>registerNameHandler</code> 関数の例を以下に示します．</p>
<pre><code class="language-go">func registerNameHandler(ctx *gin.Context) {
    name, _ := ctx.GetPostForm(&quot;name&quot;)
    ctx.HTML(http.StatusOK, &quot;result.html&quot;, gin.H{&quot;Name&quot;: name})
}
</code></pre>
<p>基本的には &quot;Hello world.&quot; を表示したときの例と同じですが，<code>gin.Context.HTML</code> の第3引数として <code>nil</code> ではなく <code>gin.H{&quot;Name&quot;: name}</code> を渡しています．
<code>gin.H</code> 関数は単純な連想配列 (HashMap) を提供する関数で，ここでは &quot;Name&quot; という key に変数 <code>name</code> の値を紐づけています．
key と指定される &quot;Name&quot; は templates/result.html 中の <code>{{ .Name }}</code> と同じである必要があります．
すなわち，<code>{{ .Name }}</code> は渡された連想配列から key として &quot;Name&quot; に対応する値を受け取り，その場に展開するコードとして働きます．</p>
<p>簡単ですが，これで Client-side から Server-side への情報送信およびHTMLの整形方法を扱ったことになります．</p>
<h5 id="練習問題-3-3"><a class="header" href="#練習問題-3-3">練習問題 3-3</a></h5>
<p><code>&lt;form&gt;</code> タグでは <code>action</code> 属性で送信先，<code>method</code> 属性でHTTPリクエストメソッドの種類を指定できます．
では，いま <code>action=&quot;POST&quot;</code> となっている場所を <code>action=&quot;GET&quot;</code> とした場合，どういった変化が起こるか，確認してみてください．</p>
<h2 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h2>
<p>今回はより実践的なWebアプリケーション開発のためのフレームワークについて扱いました．
また，HTMLを返すことでWebページとして表示できるようにし，同時に Client-side から Server-side へ情報を送信する方法を扱いました．</p>
<p>次回から2回に分けて，通信ごとに情報を記憶しておく方法を扱います．
HTTP通信は基本的に記憶を持たないため，前回の通信時にどういった状態であったかという情報を次の通信時まで保持するためには工夫が必要です．
この工夫として2種類の方法を2回に分けて扱います．</p>
<p>次回以降も formapp.go を使用しますので，削除しないよう気を付けてください．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-http通信における状態管理-1"><a class="header" href="#04-http通信における状態管理-1">04: HTTP通信における状態管理 (1)</a></h1>
<p><a href="03_web_application_framework.html">前回</a>は，より効率的にWebアプリケーション開発を進める仕組みとしてWeb Application Frame について扱いました．
基礎編最後の2回は，実践的なWebアプリケーション開発のために必要な状態管理について扱います．</p>
<p>内容に入る前に，今回開発するアプリケーション formapp.go の仕様を以下のリンクより確認してください．</p>
<p>仕様書：<a href="https://cs-sysdes.github.io/formapp.html">https://cs-sysdes.github.io/formapp.html</a></p>
<p>仕様書に示す通り，formapp.go は 5 つの画面からなるアプリケーションです．
本来であれば 1 画面でまとめてすべての情報を入力できる程度のものですが，練習のため個別の入力画面としています．
示された仕様から，formapp.go は <strong>5.確認画面</strong> において <strong>1～4 の画面において入力した情報を参照</strong>する必要があることがわかります．</p>
<p><strong>04: 状態管理 (1)</strong> および <strong>05: 状態管理 (2)</strong> では，この挙動を実現する上で解決しなければいけない状態管理に関する課題を説明し，その解決方法を実装します．
なお，ここで<strong>状態</strong>とはユーザのログイン状態やリクエストに関する一時的な記憶など，比較的短時間で変化し得るものを仮定しています．</p>
<p>今回は特に以下の内容を通して状態管理に関する課題を理解し，1 つ目の解決方法を実装していきます．</p>
<ol>
<li>事前準備: パッケージ分割</li>
<li>HTTP通信のステートレス性</li>
<li>状態管理手法 (1): ステートレス方式</li>
</ol>
<p>引き続き formapp.go をベースプロジェクトとして使用します．
前回の練習問題などにおいてすでに修正を加えているかと思いますが，初期状態に戻す必要はありません．
複数機能の開発を行うため，まずは Go言語 におけるパッケージ分割 (ソースコード分割) の方法について説明し，状態管理のための準備を整えます．</p>
<p>これ以降，提示するコードに関して以下に注意してください．</p>
<ul>
<li>package 宣言を省略するなど，ソースコードの一部を抜粋している場合があります．</li>
<li>表記中の <code>...</code> はコードの省略を意味します．</li>
<li>提示したコードの n 行目などと指定した場合は，本資料上での行数を意味しています．
多くの場合，実際のソースコード上での行数と一致するものではありません．</li>
</ul>
<h2 id="事前準備-パッケージ分割"><a class="header" href="#事前準備-パッケージ分割">事前準備: パッケージ分割</a></h2>
<p>これから複数の機能を実装していくにあたり，すべてを formapp.go/main.go の中に記述していると，プログラム全体の見通しが悪くなりミスを発見しづらくなるなど，あまり良いことはありません．
C言語 や Java，その他の言語を用いる場合においても，ある程度の規模になるとソースコードを機能や役割ごとに分割し，プログラムの構造を整理する必要が生じます．
ここでは Go言語 においてソースコード分割 (パッケージ分割) の方法を簡単に説明し，以降の演習に備えます．</p>
<p>いま formapp.go/main.go が以下の状態であると仮定して話を進めます．
各自で修正した部分がある場合でも，元に戻す必要はありません．
現在の手元のソースコードの状態と読み換えて資料を進めてください．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.GET(&quot;/&quot;, rootHandler)
    ...
}

func rootHandler(ctx *gin.Context) {
    ...
}
</code></pre>
<p>ここでは <code>rootHandler</code> 関数を <code>service</code> パッケージに分割することにします．
前回の練習課題などで他にも定義した関数があれば，それらもついでに移動しましょう．</p>
<h3 id="service-パッケージへの関数定義の移動"><a class="header" href="#service-パッケージへの関数定義の移動">service パッケージへの関数定義の移動</a></h3>
<p>ディレクトリ名がパッケージ名となるので，まず formapp.go/service というディレクトリを作成します．
また，作成したディレクトリ下に適当な名前を付けたGo言語ソースファイルを配置します．
ここでは formapp.go/service/handler.go とでもしておきましょう．
ファイル名は基本的にパッケージの import などに影響を与えないため，わかりやすい名前であれば特に制限はありません．</p>
<p>作成したソースファイルにプログラムを書き込みます．</p>
<p><span class="filename">formapp.go/service/handler.go</span></p>
<pre><code class="language-go">package service

import (
    &quot;github.com/gin-gonic/gin&quot;
)

func RootHandler(ctx *gin.Context) {
    ...
}
</code></pre>
<p>1行目のパッケージ宣言は，このファイルが属するパッケージ名として <code>service</code> を宣言しています．
パッケージ宣言は直上のディレクトリ名のみを宣言し，Java のようにすべてのパッケージ階層を宣言する必要はありません．</p>
<p>コールバック関数作成時に Gin によって提供される構造体 <code>gin.Context</code> を使用するため，Gin のパッケージを import します．
他にも関数内で使用するパッケージがある場合には，ここで明示的に import する必要があります．
たとえば標準パッケージ <code>fmt</code> を使用する場合，たとえ main.go 内で <code>fmt</code> を import していても，こちらのファイルには適用されないので，ここで再度 import する必要があります．</p>
<p>7行目において関数 <code>RootHandler</code> を定義しています．
<a href="01_preliminary.html">第1回</a>でも触れたように，Go言語では<strong>識別子の先頭が大文字の場合のみ他のパッケージから可視</strong>であるため，<code>rootHandler</code> ではなく <code>RootHandler</code> とする必要があります．</p>
<p>さて，関数定義を新たなパッケージ <code>service</code> へ移動したので，main.go の方も手直しが必要です．</p>
<h3 id="service-パッケージの利用"><a class="header" href="#service-パッケージの利用">service パッケージの利用</a></h3>
<p><code>main</code> パッケージから <code>service</code> パッケージを利用するには，これを import する必要があります．
また，ルーティング時に指定するコールバック関数も，<code>service</code> パッケージにより提供されるものに変更しなくてはいけません．</p>
<p>修正後の formapp.go/main.go を以下に示します．
主な変更点は 8 行目と 13 行目です．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
    &quot;formapp.go/service&quot;
)

func main() {
    ...
    engine.GET(&quot;/&quot;, service.RootHandler)
    ...
}

// rootHandler関数の定義はserviceパッケージへ移動済み
</code></pre>
<p>8行目において先ほど作成した <code>service</code> パッケージを import し，使用可能にしています．
Go言語では，C言語のように <code>import &quot;./service&quot;</code> などとして import することができません．
標準パッケージ以外のパッケージを使用する場合，必ず<strong>モジュール名から使用するパッケージ名までのパスを記述</strong>する必要があります．
今回の場合モジュール名は <code>formapp.go</code> ですので，import 文には &quot;formapp.go/service&quot; を指定しています．
なお，モジュール名は formapp.go/go.mod の1行目に <code>mod formapp.go</code> として宣言しています．</p>
<p>13行目において &quot;/&quot; への GET アクセスに対し <code>service.RootHandler</code> を呼び出すルーティング設定をしています．
<code>RootHandler</code> 関数は <code>service</code> パッケージ内の関数なので，このように指定する必要があります．</p>
<div class="memo">
github.com/gin-gonic/gin はモジュール名ですが，パッケージ名は gin です．
github.com/gin-gonic の部分は GitHub 上でのユーザディレクトリのようなものなので，実質的にモジュールのルートディレクトリは gin になります．
Go言語ではこのようにモジュールルートもパッケージになります．
一方で，パッケージ名として '.' (ドット) は使用できない文字なので，本演習のようにルートディレクトリとして formapp.go などと名前を付けてしまうと，そのままパッケージ名として採用できなくなります．
</div>
<p>パッケージ分割の方法がわかったところで，今回のメイントピックである状態管理について見ていきます．</p>
<h2 id="http通信のステートレス性"><a class="header" href="#http通信のステートレス性">HTTP通信のステートレス性</a></h2>
<p>WebアプリケーションはHTTP通信によって Client-side と Server-side が情報をやり取りし，目的のタスクを実行するアプリケーションです．
したがって，WebアプリケーションはHTTP通信の持つ制限や制約に縛られます．
HTTP通信が持つ制約の中でも，Webアプリケーション開発において大きな課題となるのが，<strong>ステートレス性</strong>という性質です．</p>
<p>HTTP通信のステートレス性とは，簡単に言えば<strong>個々の通信でやりとりした情報や状態は何もしなければ次の通信に引き継がれない</strong>という性質です．</p>
<p><img src="img/http_stateless_communication.png" alt="Stateless communication on HTTP" /></p>
<p>いま作成したい formapp.go の仕様で考えると，この性質によって「1. 名前入力画面」で入力された情報は<strong>アプリケーションが何もしなければ</strong>次の「2. 生年月日入力画面」へは引き継がれず，最終的に「5. 確認画面」で表示することもできません．
すなわち，HTTP通信自体はこうした情報を自動で保持する仕組みはなく，<strong>アプリケーションの責任</strong>において保持しなければいけないということになります．</p>
<p>Webアプリケーションにおける状態管理とは，1つのリクエストと1つのレスポンスの対からなる通信について，<strong>複数の通信間で状態 (情報) を引き継ぐ</strong>ことを意味します．
複数の通信間で状態を引き継ぐためには，<strong>どこかに引き継ぎたい状態を保存</strong>しておき，<strong>通信のたびに保存していた状態を確認</strong>することができれば良いでしょう．</p>
<p>このとき，どこに状態を保存するかによって大きく2つの方式を考えることができます．
これらの方式を，本演習では「<strong>ステートレス方式</strong>」および「<strong>セッション方式</strong>」と呼ぶこととします．</p>
<p>両方式の違いを以下に簡単にまとめます．</p>
<div class="table-wrapper">
<table style="width: 100%">
    <thead>
        <tr>
            <th style="width: 40%">ステートレス方式</th>
            <th style="width: 20%"></th>
            <th style="width: 40%">セッション方式</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="width: 40%">通信上に載せる</td>
            <td style="width: 20%; text-align: center">状態の保存</td>
            <td style="width: 40%">Server-side アプリケーションが記憶</td>
        </tr>
        <tr>
            <td style="width: 40%">Server が状態を記憶する必要がなく，通信相手を区別する仕組みも不要</td>
            <td style="width: 20%; text-align: center">利点</td>
            <td style="width: 40%">通信量が扱う状態のデータサイズに依存しにくい</td>
        </tr>
        <tr>
            <td style="width: 40%">扱う状態のデータサイズに依存して通信料が増える</td>
            <td style="width: 20%; text-align: center">欠点</td>
            <td style="width: 40%">複数 Client からの並行アクセスに対し通信相手を弁別する仕組みが必要</td>
        </tr>
    </tbody>
</table>
</div>
<div class="memo">
「ステートレス方式」および「セッション方式」という名称は便宜上のものであり，一般的な呼称ではないことに注意．
</div>
<p>今回は特に「ステートレス方式」について実装を進め，次回「セッション方式」を扱います．</p>
<h2 id="状態管理手法-1-ステートレス方式"><a class="header" href="#状態管理手法-1-ステートレス方式">状態管理手法 (1): ステートレス方式</a></h2>
<p>ステートレス方式は，Server-side アプリケーションが状態を持たない (= ステートレス) ことから，このような名称を便宜上与えています．
Server-side アプリケーションが情報を持たない代わりに，ステートレス方式では毎回の通信にこれまでのすべての状態を載せることで，複数の通信間での状態の引き継ぎを実現しています．</p>
<p>formapp.go におけるステートレス方式を図示すると以下のようになります．</p>
<p><img src="img/formapp_stateless.png" alt="Stateless communication in formapp.go" /></p>
<p>図中に示すように，各通信に前の通信で得た情報を毎回しつこく載せ続けることによって，Server-side が記憶を持っていなくとも，<strong>通信の内容を見ればすべての状態を把握可能</strong>な仕組みを作ることができます．</p>
<p>それでは実際にステートレス方式で formapp.go を実装してみましょう．</p>
<h3 id="仮ルーティングの設定"><a class="header" href="#仮ルーティングの設定">仮ルーティングの設定</a></h3>
<p>はじめに formapp.go/main.go 内にルーティングのみ先に定義してしまいましょう．
formapp.go の仕様において最低限必要なルーティング設定は以下の 5 つです．</p>
<ul>
<li>スタート画面を表示 (GET) するルート</li>
<li>スタート画面からのPOSTを受け取るルート</li>
<li>名前入力画面からのPOSTと受け取るルート</li>
<li>生年月日入力画面からのPOSTを受け取るルート</li>
<li>メッセージ入力画面からのPOSTを受け取るルート</li>
</ul>
<p>ここで，名前入力画面，生年月日入力画面，メッセージ入力画面，確認画面を表示するルートは不要である点に注意してください．
これらの画面は，前の画面からのPOSTリクエストに対するレスポンスとして返すことができるため，別途GETメソッドによるアクセスを考える必要がありません．
また，確認画面からスタート画面に戻る際は，form タグでスタート画面への GET メソッドを送信するか，単にリンクとすることで対応可能です．</p>
<p>これらのルーティングを先に設定してしまいましょう．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.GET(&quot;/stateless/start&quot;, notImplemented)
    engine.POST(&quot;/stateless/start&quot;, notImplemented)
    engine.POST(&quot;/stateless/name&quot;, notImplemented)
    engine.POST(&quot;/stateless/birthday&quot;, notImplemented)
    engine.POST(&quot;/stateless/message&quot;, notImplemented)
    ...
}

func notImplemented(ctx *gin.Context) {
    msg := fmt.Sprintf(&quot;%s to %s is not implemented yet&quot;, ctx.Request.Method, ctx.Request.URL)
    ctx.String(http.StatusNotImplemented, msg)
}
</code></pre>
<p>ルーティングを設定する際，10行目のような未実装であることを通知するだけの関数などを仮配置しておくと便利です．</p>
<h3 id="スタート画面"><a class="header" href="#スタート画面">スタート画面</a></h3>
<p>仕様書に従って 1. スタート画面 を作成します．
この画面はステートレス方式とセッション方式でほとんど共通ですので，templates/start.html などとして以下のボタンを設置したページを配置します．
なお，<code>&lt;body&gt;</code> タグなどは省略していますので，各自で適宜記述してください．</p>
<p><span class="filename">formapp.go/templates/start.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;{{ .Target }}&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;アンケート開始&lt;/label&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;start&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p>ここで，1行目において <code>action=&quot;{{ .Target }}&quot;</code> としてPOST先を変更できるようにしています．
こうすることで，ステートレス方式でもセッション方式でも，このテンプレートを使い回せるようにしています．</p>
<p>次にスタート画面へのGETアクセスを受ける関数を作成します．</p>
<p>ここからステートレス方式の実装を進めるにあたり，次回セッション方式を実装する際と関数名の衝突が発生しないよう新しいパッケージを作成しておきます．
ここでは先ほど作成した formapp.go/service ディレクトリの下に stateless ディレクトリを作成し，<code>stateless</code> パッケージとして機能を実装していくこととします．</p>
<p>Go言語 のソースファイルとして先ほど作成した stateless ディレクトリに適当な名前のファイルを作成します．
ここでは formapp.go/service/stateless/handler.go としておきましょう．</p>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">package stateless

import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

func Start(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;start.html&quot;, gin.H{ &quot;Target&quot;: &quot;/stateless/start&quot; })
}
</code></pre>
<p>ここではスタート画面における POST 先を /stateless/start としています．</p>
<p>formapp.go/main.go を修正し，スタート画面への GET リクエストを飛ばせるようにしてみましょう．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">import (
    ...
    &quot;formapp.go/service/stateless&quot;  // statelessパッケージを使用
)
func main() {
    ...
    engine.GET(&quot;/stateless/start&quot;, stateless.Start)
    engine.POST(&quot;/stateless/start&quot;, notImplemented)
    ...
}
</code></pre>
<p>3 行目の記述によって，<code>stateless</code> パッケージを呼び出せるようにしています．
<code>stateless</code> パッケージ内の関数などを使用する場合は，Javaのように <code>service.stateless.Start</code> とするのではなく，単に <code>stateless.Start</code> で呼び出すことができます (7行目参照)．
このルールでは別々のモジュールで定義された同じパッケージ名で衝突が容易に発生するように思いますが，Go言語では import 時にパッケージに別名をつけることができるため，それほど問題にはなりません．</p>
<p>アプリケーションを起動し，Web ブラウザから http://localhost:8000/stateless/start へアクセスしてみましょう．
スタート画面が表示されれば成功です．</p>
<h3 id="名前入力画面"><a class="header" href="#名前入力画面">名前入力画面</a></h3>
<p>ここではまだ前のページから引き継ぐべき状態がありません．
したがって，スタート画面と同様にセッション方式でも使用できるよう名前入力画面を作成します．</p>
<p><span class="filename">formapp.go/templates/name-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;{{ .Target }}&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;名前: &lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;next&quot;&gt;&lt;input&gt;
&lt;/form&gt;
</code></pre>
<p>関数を追加します．
少しわかりづらいですが，ここはスタート画面からの POST を受け取って名前入力画面を返す部分なので，まだ特に情報は送られてきません．
<code>Target</code> の設定に注意してください．</p>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">...

func NameForm(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;name-form.html&quot;, gin.H{ &quot;Target&quot;: &quot;/stateless/name&quot; })
}
</code></pre>
<p>ルーティングも更新します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/stateless/start&quot;, stateless.NameForm)
    ...
}
</code></pre>
<p>ここでも一度，動作確認をしてみましょう．</p>
<h3 id="生年月日入力画面"><a class="header" href="#生年月日入力画面">生年月日入力画面</a></h3>
<p>ここからは前の画面で入力した情報を状態として引き継いでいく必要があります．</p>
<p>まずはこれまで通り素直に生年月日入力画面を作ってみましょう．
ただし，ここからはセッション方式とやや記述内容が異なってくるため，区別できるようなファイル名としておきます．</p>
<p><span class="filename">templates/stateless-birthday-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;/stateless/birthday&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;生年月日: &lt;/label&gt;
    &lt;input type=&quot;date&quot; name=&quot;birthday&quot; value=&quot;2011-10-22&quot;&gt;&lt;/input&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p><code>input[type=date]</code> は日付を扱うための input タグです．
また，一般に input タグは <code>value=&quot;...&quot;</code> とすることで初期値を設定でき，<code>input[type=date]</code> の場合は <code>&quot;2011-10-22&quot;</code> と記述しておくと 2022年10月22日 が初期値として設定されます．</p>
<p>さて，ステートレス方式では通信に状態を載せるのですが，このままでは名前情報を載せておく場所がありません．
状態を引き継ぐためには状態を載せる場所を確保する必要があるため，その場所を <code>input[type=hidden]</code> タグによってつくります．
上記のテンプレートファイルを以下のように修正します．</p>
<p><span class="filename">templates/stateless-birthday-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;/stateless/birthday&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;生年月日: &lt;/label&gt;
    &lt;input type=&quot;date&quot; name=&quot;birthday&quot; value=&quot;2011-10-22&quot;&gt;&lt;/input&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;{{ .Name }}&quot;&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p>変更点は 4 行目です．
この記述により，生年月日入力画面に名前情報を埋め込むことができました．
<code>input[type=hidden]</code> は，HTML における通常の input タグのように情報を送信することができますが，Webブラウザ上には表示されません．
したがって，このように通信に情報を載せるための手段として活用することができます．</p>
<p>名前入力を受け取り，生年月日入力フォームを返す関数を formapp.go/service/stateless/handler.go へ追加します．
この関数は /stateless/name への POST を受け取って生年月日入力画面を返す関数なので，以下の 2 つのタスクを実行します．</p>
<ol>
<li>リクエストから名前情報を抜き出す</li>
<li>名前情報を埋め込んだ生年月日入力画面を返す</li>
</ol>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">...

func BirthdayForm(ctx *gin.Context) {
    name, exist := ctx.GetPostForm(&quot;name&quot;)
    if !exist {
        ctx.String(http.StatusBadRequest, &quot;parameter 'name' is not provided&quot;)
    }
    ctx.HTML(http.StatusOK, &quot;stateless-birthday-form.html&quot;, gin.H{ &quot;Name&quot;: name })
}
</code></pre>
<p>念のためエラー処理 (5--7行目) を挟んでいますが，本質的には POST されたデータから名前情報を抜き取り，templates/stateless-birthday-form.html に埋め込んで Client へ返すという動作を実行するものです．</p>
<p>ルーティングを更新します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/stateless/name&quot;, stateless.BirthdayForm)
    ...
}
</code></pre>
<p>ここまでの動作確認を行いましょう．
前述の通り <code>input[type=hidden]</code> は通常 Webブラウザ 上では表示されません．
たしかに名前情報が状態として埋め込まれていることを確認するには，HTMLソースを確認する必要があります．
多くの Webブラウザ では，右クリックで出現するメニューから「ページのソースを表示」などの項目を選択することで，HTMLソースを確認することができます．</p>
<p>基本的にはこれを繰り返すだけですので，ステートレス方式での残りのページの実装は練習問題とします．
注意点として，生年月日入力画面では名前情報のみを引き継ぎましたが，メッセージ入力画面では当然ながら名前情報と生年月日情報の2つを引き継がなければなりません．
すなわち，メッセージ入力画面では <code>input[type=hidden]</code> フィールドが2つ存在することとなります．</p>
<p>このようにステートレス方式は，扱う情報が増えると情報を引き継ぐためのフィールドが増加し，結果として通信量が増える性質を持っています．
小さなデータを少しだけ引き継ぐ場合には問題にはなりませんが，大きなデータや大量のデータを引き継ぐには不向きだと言えます．</p>
<h5 id="練習問題-4-1"><a class="header" href="#練習問題-4-1">練習問題 4-1</a></h5>
<p>ここまでの内容をもとに，<a href="https://cs-sysdes.github.io/formapp.html">formapp.goの仕様</a>を満たすアプリケーションを開発してみましょう．
なお，複数行の文字列入力欄は <code>&lt;textarea&gt;</code> タグを使うことで実現できます．</p>
<h5 id="練習問題-4-2"><a class="header" href="#練習問題-4-2">練習問題 4-2</a></h5>
<p>追加機能として，各画面に一つ前の画面に戻る「back」ボタンを実装し，前画面での入力を修正できるようにしてみましょう．</p>
<h2 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h2>
<p>今回はWebアプリケーションにおける状態管理について，HTTP通信の制約からくる課題とその解決方法の一つとして「ステートレス方式」を扱いました．
次回は，もう一つの方法である「セッション方式」について扱います．</p>
<p>今回の内容は以上になります．
おつかれさまでした．</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/highlight-line-numbers.js"></script>
        <script type="text/javascript" src="theme/custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="ja" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSC.T364 Workshop on System Design -  Web programming</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta name="robots" content="noindex,nofollow,noarchive"/>

        <meta name="description" content="Lecture note for Web programming course 2022 in CSC.T364 Workshop on System Design">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/highlight-line-numbers.css">
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">HOME</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">演習資料 基礎編</li><li class="chapter-item expanded "><a href="01_preliminary.html">01: 演習のための準備</a></li><li class="chapter-item expanded "><a href="02_http_and_routing.html">02: HTTP通信とルーティング</a></li><li class="chapter-item expanded "><a href="03_web_application_framework.html">03: Webアプリケーションフレームワーク</a></li><li class="chapter-item expanded "><a href="04_state_management_v1.html">04: HTTP通信における状態管理 (1)</a></li><li class="chapter-item expanded "><a href="05_state_management_v2.html">05: HTTP通信における状態管理 (2)</a></li><li class="chapter-item expanded affix "><li class="part-title">演習資料 実践編</li><li class="chapter-item expanded "><a href="06_todolist.html">06: タスク管理アプリケーション</a></li><li class="chapter-item expanded "><a href="07_task_management.html">07: タスクの作成・編集・削除</a></li><li class="chapter-item expanded "><a href="08_search.html">08: 検索機能</a></li><li class="chapter-item expanded "><a href="09_account_management_1.html">09: アカウント管理機能 (1)</a></li><li class="chapter-item expanded "><a href="10_account_management_2.html">10: アカウント管理機能 (2)</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">補足資料</li><li class="chapter-item expanded "><a href="XX_reference.html">参考サイト</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CSC.T364 Workshop on System Design -  Web programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cs-sysdes/lecture-note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="システム設計演習---webプログラミング--"><a class="header" href="#システム設計演習---webプログラミング--">システム設計演習 - Webプログラミング -</a></h1>
<p>この資料は，情報工学系 システム設計演習 Webプログラミング の演習資料です．</p>
<p>資料は全 10 回からなり，<b>練習問題に取り組む時間やレポートをまとめる時間を含めて本演習全体を構成</b>するものとします．
前半 5 回は基礎編としてWebアプリケーションの動作原理やWebアプリケーションフレームワークの使い方などを主に扱います．
後半 5 回は実践編としてWebアプリケーションフレームワークを使用した簡単なタスク管理アプリケーションの開発を扱います．
演習内容にしたがって期末レポート課題を出題しますので，<b>各自のペースで計画的に進めてください</b>．</p>
<p>練習問題が設定されている場合がありますが，必ずしも期末レポート課題に関連する内容ではなく，単に理解度を推し量るものを含みます．</p>
<h2 id="開発環境など"><a class="header" href="#開発環境など">開発環境など</a></h2>
<p>この演習では <a href="https://go.dev">Go言語</a> によるプログラム開発，<a href="https://docker.com">Docker</a> を用いた仮想環境上でのプログラム実行を想定しています．
また，動作確認に Webブラウザ を使用します．
情報工学系演習室の端末には関連ソフトウェアがすでにインストールされていますので，すぐに開発を始めることができます．</p>
<p>個人所有PCなどで演習を行う場合，各自の端末に開発環境をセットアップしてもらう必要があります．
OSやエディタなどについて特に指定はありませんので，各自の慣れ親しんだ環境で開発を進めてもらって構いません．
Windows PC での開発を考えている方には， <a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> の使用を推奨します．</p>
<p>プログラムの実行に必要な Docker は，以下を参考に各自でインストールをお願いします．
この演習では基本的に Command Line Interface (CLI) での実行を想定しているため，ターミナルエミュレータ上で <code>docker-compose</code> コマンドが有効であることを確認してください．</p>
<div class="table-wrapper"><table><thead><tr><th>OS</th><th>参考サイト</th></tr></thead><tbody>
<tr><td>OS X</td><td><a href="https://brew.sh/index_ja">Homebrew</a> or <a href="https://docs.docker.jp/docker-for-mac/install.html">Docker Desktop for Mac</a></td></tr>
<tr><td>Windows (+WSL)</td><td><a href="https://docs.docker.jp/desktop/windows/wsl.html">Docker Desktop w/ WSL2</a></td></tr>
<tr><td>Ubuntu</td><td><a href="https://gihyo.jp/admin/serial/01/ubuntu-recipe/0719">DD4L on Ubuntu 22.04</a></td></tr>
</tbody></table>
</div>
<p>表中に掲載のない環境を愛用している方は自力解決のできる方々だと思いますので，各自で環境整備をお願いします．</p>
<p>基本的に Docker 上でのプログラム実行を想定しているため，Go言語のビルドツールはなくても大丈夫です．
ただし，使用するテキストエディタなどによっては <code>go</code> コマンドが実行できることを要求してくる場合があるため，必要に応じてインストールしておくとよいかもしれません．
インストール方法は <a href="https://go.dev/doc/install">Download and install - The Go programming language</a> を参照してください．</p>
<p>Go言語の基本的な書き方や Docker によるプログラムの実行方法については，<a href="01_preliminary.html">01: 演習のための準備</a> にて扱います．</p>
<h2 id="質問対応"><a class="header" href="#質問対応">質問対応</a></h2>
<p>この注意事項は<a href="http://cs-sysdes.github.io/#slack-workspace">授業Webサイト</a>に記載したものと同じです．</p>
<p>演習に関する質問は Slack にて随時受け付けますが，特に講義時間外については即レスを期待しないでください．
質問者本人だけでなく他の人を助けることにも繋がることも多いため，可能な限り #help チャネルを活用してオープンな場で質問をしてもらえると良いかと思います．
ただし，DM 等での質問や議論を妨げるものではありません．
DM 等で直接受けた質問であっても，重要な質問であると判断した場合には，匿名で #help チャネルに質問の内容と回答を掲載する場合があります．</p>
<p>質問時には，</p>
<ol>
<li>資料の<b>どの部分に取り組んでいる</b>のか．</li>
<li>なにが<b>目的とする動作</b> (理想的な挙動 or 出てほしい結果) なのか．</li>
<li>それを実現するために<b>なにをした</b>のか．</li>
<li>実際には<b>どうなっている</b> のか． (出力やエラーの内容など)</li>
</ol>
<p>を明らかにしてくれると非常に助かります．
一方で，質問の意図が掴みづらい場合にはこちらから掘り下げますので，気にしすぎず気楽に質問してください．</p>
<h2 id="おことわり"><a class="header" href="#おことわり">おことわり</a></h2>
<p>資料中に存在する誤り・不明瞭な説明は，すべて担当教員に責任があります．
誤りを発見された場合は，適切に修正・訂正を行いますので，ご一報ください．
また，不明瞭な点や改善すべき点などについても遠慮なくご報告いただければと思います．
特にWebアプリケーション開発の経験がある学生がいれば，未経験の人がつまずきそうな箇所などを指摘してもらえると助かります．
よりわかりやすい演習資料となるよう努力していきますので，ご協力のほどよろしくお願いいたします．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-演習のための準備"><a class="header" href="#01-演習のための準備">01: 演習のための準備</a></h1>
<p>第1回は，演習を進めるにあたって必要な以下の事項について説明します．</p>
<ol>
<li>Go言語プロジェクト</li>
<li>Dockerコンテナ上でのプログラムの実行</li>
<li>入門Go言語</li>
</ol>
<p>Dockerなどの開発環境のインストールおよび設定は済んでいるものと仮定しています．
まだの方は <a href="index.html">HOME - 開発環境など</a> を参考に開発環境を整えてから進んでください．</p>
<h2 id="go言語プロジェクト"><a class="header" href="#go言語プロジェクト">Go言語プロジェクト</a></h2>
<p>この演習では，扱う内容に応じて最低限のプログラムと実行環境の設定からなるプロジェクトテンプレートを配布し，資料の内容にしたがって配布したプロジェクト内のファイルを編集する形式で演習を進めます．
編集後のプロジェクトの提出などは求めません．</p>
<p>配布するプロジェクトテンプレートには，初期状態としてとりあえず動く程度のプログラムしか入っていません．
必要に応じて関数を定義したり，ファイルを分割したり，ディレクトリを新たに作ってファイルを移動したり，etc. といった作業が要求されます．
資料中にて新たなファイルの作成を指示する場合もありますが，基本的には各自の判断でファイル分割やディレクトリ (Go言語では特に「パッケージ」と呼びます) の切り分けなど，自由に編集して構いません．</p>
<h3 id="プロジェクトの取得"><a class="header" href="#プロジェクトの取得">プロジェクトの取得</a></h3>
<p>今回使用するプロジェクトを以下のURLよりダウンロードしてください．</p>
<p><a href="https://github.com/cs-sysdes/tutorial.go">https://github.com/cs-sysdes/tutorial.go</a></p>
<p>GitHub の扱いに慣れている方は直接 clone してもらって構いません．
そうでない方は，リンクからページを開き，下の画像の通り「Code」→「Download ZIP」と押すと，zip形式でプロジェクトをダウンロード可能です．
ダウンロードしたzipファイルを展開したら準備完了です．</p>
<p><img src="img/download.png" alt="How to download" /></p>
<p>今回使用する tutorial.go は，以下のファイル群で構成されています．</p>
<ul>
<li>README.md</li>
<li>Dockerfile</li>
<li>docker-compose.yml</li>
<li>go.mod</li>
<li>main.go</li>
</ul>
<p>Dockerfile および docker-compose.yml は，プログラム実行時に使用する仮想環境についての設定ファイルです．
演習内で編集することはないと思います．</p>
<p>go.mod は Go言語 の開発ツールである <code>go</code> コマンドによって参照されるプロジェクトの設定などに関するファイルです．
プロジェクト使用するコンパイラのバージョンを指定したり，依存する外部ライブラリの管理などを行うために必要なファイルです．
外部ライブラリの追加は <code>go</code> コマンドで実行することができるため，このファイルも直接編集する機会は少ないです．</p>
<p>main.go が今回の実行対象である Go言語 で書かれたプログラムです．
内容を以下に示しますが，おそらく Go言語 に触れたことがない人でも，実行すると何が起こるのか想像がつくのではないでしょうか．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<p>型の宣言方法や識別子の可視性など Go言語 特有のルールや機能も存在しますが，Go言語 はかなり C言語 に近い印象を個人的に持っています．
みんなが大好きな「ポインタ」もちゃんとあります．</p>
<h2 id="dockerコンテナ上でのプログラムの実行"><a class="header" href="#dockerコンテナ上でのプログラムの実行">Dockerコンテナ上でのプログラムの実行</a></h2>
<p>ここでは仮想環境上でプログラムを実行する方法を説明します．
Dockerの管理する仮想環境は一般に「コンテナ」と呼ばれるため，以降では単に「コンテナ」あるいは「Dockerコンテナ」と表記します．</p>
<p>この演習では基本的にコマンドライン上での実行を想定しています．
たとえば資料中に<code>$ echo &quot;Hello world!&quot;</code>と書かれている場合，これはコマンドライン上で <code>echo</code> コマンドを &quot;Hello world!&quot; という文字列を引数として実行することを意味します．
先頭の &quot;$&quot; を入力する必要はありません．</p>
<h3 id="コンテナの起動"><a class="header" href="#コンテナの起動">コンテナの起動</a></h3>
<p>いま <code>~/sysdes/tutorial.go</code> にダウンロードしたプロジェクトが展開されていると仮定しましょう．
このパスは各自の環境で置き換えてください．</p>
<p>ターミナルエミュレータを起動し，以下のコマンドを打ち込むことでコンテナを起動することができます．
&quot;#&quot; 以降はコメントなので入力する必要はありません．</p>
<pre><code class="language-sh">$ cd ~/sysdes/tutorial.go  # プロジェクトディレクトリへ移動
$ docker-compose up -d     # 仮想環境の起動
</code></pre>
<p>初回起動には少し時間がかかりますので，気長に待ちましょう．</p>
<p>「<code>docker-compose</code> コマンドが見つからない」といったエラーが出ている場合，Docker のインストールが正常に完了していない可能性があります．
Docker のインストールが完了していることや，コマンドへパスが通っていることなどを確認してください．
Mac や Linux では自動的にパスの通っている場所へ実行ファイルを配置してくれることが多いですが，特に WSL を使用せずに Windows のコマンドプロンプトで実行する場合にはパスの設定などが別途必要になることがあります．</p>
<div class="memo">
<code class="hljs">docker-compose</code> は通常複数のコンテナを管理するために使用します．
ここでは Go言語 実行環境として 1 つのコンテナしか扱っていませんが，演習後半 (実践編) では実際に複数のコンテナを同時に立ち上げます．
</div>
<h3 id="プログラムの実行"><a class="header" href="#プログラムの実行">プログラムの実行</a></h3>
<p>コンテナが起動しだら実際にプログラムを動かしてみましょう．</p>
<p>Go言語 は C言語 や Java などと同じコンパイラ型ですが，ビルドツールである <code>go</code> コマンドを使うことでプログラムを直接実行することができます．
ただし，ここでは Dockerコンテナ 上で実行するため，少し長いコマンドを打つ必要があります．
go.mod が存在するディレクトリ (<code>~/sysdes/tutorial.go</code>) 内にて以下のコマンドを実行してください．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
Hello world!
</code></pre>
<p>このコマンドは主に 2 つの部分からなります．<br>
前半部分：<code>docker-compose exec app</code> は，&quot;app&quot; と名付けられたコンテナ上でプログラムを実行するためのコマンドです．
詳細は省略しますが，プロジェクトディレクトリ内の docker-compose.yml を覗くと名前を設定している記述があり，名前を変更することも可能です．<br>
後半部分：<code>go run main.go</code> は，Go言語ビルドツールによって main.go ファイルを実行するためのコマンドです．
これらを組合わせることで，ローカル端末から &quot;app&quot; コンテナ上で main.go を実行し，その結果をローカル端末上で確認することができるようにしています．</p>
<div class="memo">
演習前半 (基礎編) の内容については，ローカルに Go言語 の実行環境を持っている人は単純に <code class="hljs">go run main.go</code> などとして直接実行する方が早いです．
演習後半 (実践編) において <code class="hljs">docker-compose</code> コマンドで複数のコンテナを起動順序の制約を守りながら並行して立ち上げる必要があるので，今のうちから慣れてもらうためにあえて面倒な方法を紹介しています．
</div>
<h3 id="仮想環境の停止"><a class="header" href="#仮想環境の停止">仮想環境の停止</a></h3>
<p>演習が終了したら，忘れずにコンテナを停止しましょう．</p>
<p>起動コマンドが <code>up</code> だったので，停止は <code>down</code> です．
プロジェクトディレクトリ (<code>~/sysdes/tutorial.go</code>) 内で以下のコマンドを実行してください．</p>
<pre><code class="language-sh">$ docker-compose down
</code></pre>
<p>停止時にも少し時間がかかる場合があります．
想環境の停止においてエラーが発生することはほとんどありませんが，たとえばプロジェクトのパスを変更 (ディレクトリの移動や名前の変更) してしまうと正常に停止できない場合があります．</p>
<div class="memo">
情報工学系演習室 (計算機室) の端末で演習を進めている方へのお願いです．
計算機室の端末では Docker 周りに一部不安定な挙動が見られます．
そのため，<b>演習が終了したらコンテナを停止した上で，必ず端末を再起動</b>してください．
ログアウトではなく，再起動でお願いします．
</div>
<p>以上の手順は演習を進める上で毎回使います．
忘れたらここを見直せば良いので頑張って覚える必要はないですが，たとえば <code>$ make start</code> で起動できるよう Makefile を設置するなど，各自で工夫をしてもよいと思います．</p>
<h2 id="入門go言語"><a class="header" href="#入門go言語">入門Go言語</a></h2>
<p>演習で使用するGo言語について簡単に勉強しましょう．</p>
<p>tutorial.go では画面に &quot;Hello world!&quot; と出力するプログラムを扱いました．
ここからは，これをベースとして色々な言語機能を説明し，プログラムを実際に変更して動かしてみることで，Go言語に入門 していきたいと思います．</p>
<p>すでにGo言語に慣れている人は，これ以降をスキップして <a href="02_http.html">第2回</a> に進んでもらって構いません．
お疲れさまでした．</p>
<h3 id="maingo-解説"><a class="header" href="#maingo-解説">main.go 解説</a></h3>
<p>初期状態の tutorial.go/main.go は以下のようになっています．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello world!&quot;)
}
</code></pre>
<p>1行目 <code>package main</code> はパッケージ宣言と呼び，この<b>ファイルが属するパッケージ</b>を明示しています．
Go言語 ではすべてのファイルが「パッケージ」に属しており，パッケージの集合を「モジュール」と呼んでいます．
すなわち，いままでプロジェクトと呼んでいたものは，tutorial.go という名のモジュールであるということになります．</p>
<p>main は特別なパッケージ名で，実行基点となる <b>main 関数が存在するファイルは必ず main パッケージ</b>に属している必要があります．
また，一つのパッケージに複数の main を配置することは可能ですが非推奨となっており，今回の場合ルートディレクトリに別の main 関数を持ったファイルを配置して main パッケージであると宣言すると，ビルドツールが文句を言います．
最近流行の Rust ほどではありませんが，Go言語 もビルドツールがなかなかお節介です．</p>
<p>3行目 <code>import &quot;fmt&quot;</code> は，このプログラムで<b>使用するパッケージをインポート</b>するための宣言です．
C言語 でいうところの <code>#include &lt;...&gt;</code> 文みたいなものだと考えてください．
なお，プログラム中で使用していないパッケージを import していると，コンパイラがエラーを出します．
警告ではなくエラーです．</p>
<p>5行目 <code>func main()</code> は，C言語 における <code>void main(void)</code> と同等と考えて差し支えありません．
Go言語 は C言語 と同様に <code>main</code> という識別子をもった関数を実行基点としています．
C言語 では普通 <code>int main(void)</code> と書きますが，Go言語 の main関数 は戻り値を持たないため，戻り値型の宣言がありません．</p>
<p>6行目 <code>fmt.Println(...)</code> は<b>標準出力へ文字列を出力する関数</b>を呼び出しています．
先ほど <code>fmt</code> パッケージを import したのは，ここで <code>fmt</code> パッケージ内の <code>Println</code> 関数を使用するためです．
パッケージ内の関数や変数といった識別子を呼び出す場合には，このように「<b>パッケージ名 + 識別子名</b>」の形式で記述します．</p>
<p><code>Println</code> 関数は，Java の <code>System.out.println</code> メソッドと同じものだと思ってください．
引数で与えた文字列を，改行付きで標準出力へ出力します．</p>
<p>以上が初期状態での main.go の内容になります．
ここからは，このファイルを編集しながら代表的な言語機能を見ていきましょう．</p>
<h3 id="変数と定数"><a class="header" href="#変数と定数">変数と定数</a></h3>
<p>いま文字列 &quot;Hello world!&quot; を直接 <code>fmt.Println</code> 関数に入力していますが，これを一旦変数に格納した上で関数に渡すよう変更してみましょう．</p>
<p>まず C言語 と最も異なるルールとして，Go言語 では<b>型を後置</b>します．
すなわち，Go言語 における変数宣言の基本的な形式は <code>var 変数名 型名</code> になります．
先頭の <code>var</code> はこれが変数宣言であることを意味し，そのあとに変数名，変数の型が続きます．</p>
<p>同じ型の変数を複数宣言する場合には，<code>var i, j, k int</code> などのようにまとめることができます．
さらに，異なる型の変数を複数宣言する場合には，以下のように <code>var</code> キーワードをグループ化することもできます．</p>
<pre><code class="language-go">var (
    i, j, k int
    v string
)
</code></pre>
<p>これらの機能は後ほど登場する <code>const</code> キーワードでも同様です．</p>
<h4 id="局所変数"><a class="header" href="#局所変数">局所変数</a></h4>
<p>具体的に main.go を変数を使って書き換えた例を示します．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    var message string = &quot;Hello world!&quot;  // string型の変数messageを宣言し&quot;Hello world!&quot;を代入
    fmt.Println(message)
}
</code></pre>
<p>ただ変数を宣言し，値を代入しているだけですので，あまり迷うことはないかと思います．
ちなみに Go言語 では C言語 と同様に <code>//</code> や <code>/* */</code> によってコメントを記述可能です．</p>
<p>さて，Go言語 ではこれをもう少し効率的に書くことができます．
1 つ目の改善点として，変数の宣言と初期化 (代入) を同時に行う場合，型は初期値から推論できるので書く必要がありません．
つまり以下のような書き方が可能です．</p>
<pre><code class="language-go">// messageの型は書かなくても初期値からstringに推論される
var message = &quot;Hello world!&quot;
</code></pre>
<p>2 つ目の改善点として，<b>関数内や制御ブロック内などといった局所スコープ</b>に限り，以下のように書いても同じ意味になります．</p>
<pre><code class="language-go">// 下記は var message = &quot;Hello world&quot; と同等
message := &quot;Hello world!&quot;  // = ではなく := であることに注意!!
</code></pre>
<p>ここまでの理解から以下のコードが合法になることがわかります．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    message := &quot;Hello world!&quot;
    fmt.Println(message)
}
</code></pre>
<p>注意点として，<code>:=</code> では同じスコープ内で複数の同じ変数を束縛できません．
すなわち，以下のコードはコンパイルエラーになります．</p>
<pre><code class="language-go">func main() {
    message := &quot;Hello world!&quot;
    message := &quot;Hello, Masu!&quot;    // これはmessageの再定義なのでダメ
    message = &quot;Hello, Kazuya!&quot;   // これはmessageへの再代入 (既存の変数の変更) なのでOK
}
</code></pre>
<p>ただし，このルールには一部例外があります．
詳細は後日，おそらく演習内で例外的な状況が出てくると思いますので，そのときに説明を加えます．</p>
<h4 id="グローバル変数定数"><a class="header" href="#グローバル変数定数">グローバル変数・定数</a></h4>
<p>Go言語 では，C言語 と同様にグローバル変数を定義することができます．
ただし，<code>:=</code> を用いた略記法はグローバル変数では使用できないことに注意してください．</p>
<p>また，グローバル変数は定数としての利用を想定していることが多いかと思います．
そうした場合は，<code>var</code> を <code>const</code> に変えることで変数ではなく定数を宣言することができます．
グローバル定数を使って書いた例を以下に示します．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

const message = &quot;Hello world!&quot;  // 型推論は効く

func main() {
    fmt.Println(message)
}
</code></pre>
<p>定数は関数スコープ内などでも定義できますが，用途が限定されるためかあまり見かけたことがありません．
個人的には <code>const</code> 指定好きなので使いますが……</p>
<h3 id="関数"><a class="header" href="#関数">関数</a></h3>
<p>変数 (定数) が使えるようになったら，次は関数です．
いま <code>main</code> 関数の中は非常に単純ですが，コードが複雑化すると関数を分けたくなります．</p>
<p>Go言語 での関数の定義方法は <code>func 関数名(引数リスト) 戻り値型 { 処理の内容  }</code> となっています．
型は後置するルールなので，戻り値型も後ろになっています．</p>
<p>ここでは引数として名前を受け取り，挨拶を返す関数 <code>hello</code> を作成してみます．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    greet := hello(&quot;Masu&quot;)
    fmt.Println(greet)
}

func hello(name string) string {
    return fmt.Sprintf(&quot;Hello, %s!&quot;, name)
}
</code></pre>
<p>当然ながら引数リストでも型は後置するルールなので，<code>name string</code> で <code>name</code> という string 型の仮引数を設定しています．</p>
<p>C言語と同様に戻り値を返すには <code>return</code> キーワードを使用します．
<code>fmt.Sprintf</code> は C言語 の <code>sprintf</code> 関数 (<code>&lt;stdio.h&gt;</code>) と同じものです．</p>
<p>これを実行すると以下のような結果を得られるはずです．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
Hello, Masu!
</code></pre>
<p>Go言語 の戻り値には C言語 にはない機能があります．
たとえば，C言語の <code>printf</code> 関数が整数値を返すのと同様に．先ほどから使用している <code>fmt.Println</code> 関数も戻り値を持ちます．
普段はほとんど使いませんが，<code>fmt.Println</code> 関数の戻り値は <code>(int, error)</code> であると定義されています．
Go言語 ではこのように複数の戻り値を返すことができ，至る所でこの機能を使用しています．
万が一 <code>fmt.Println</code> 関数の戻り値を受け取りたい場合には，以下のように書く必要があります．</p>
<pre><code class="language-go">i, err := fmt.Println(&quot;Hello, Kazuya!&quot;)
</code></pre>
<p>ただし，常に両方の戻り値が必要というわけでもないと思うので，戻り値を破棄する特別な変数名として <code>_</code> (アンダースコア) が予約されています．
つまり，先ほどの例で第2戻り値のエラー情報だけ欲しい場合には，以下のように書けます．</p>
<pre><code class="language-go">_, err := fmt.Println(&quot;Hello, Kazuya!&quot;)
</code></pre>
<h3 id="識別子の命名規則と可視性"><a class="header" href="#識別子の命名規則と可視性">識別子の命名規則と可視性</a></h3>
<p>さきほど関数宣言で <code>hello</code> という識別子を使いました．
また，グローバル変数を定義する際も <code>message</code> という識別子を使いました．
何も変なところはないように思いますが，実は意識して<b>小文字から始まる識別子</b>を使いました．
一方で <code>fmt.Println</code> 関数は，<code>fmt</code> はパッケージ名なので無視するとして，関数名は<b>大文字から始まる識別子</b>になっています．</p>
<p>実は Go言語 では，変数や関数の識別子名として，<b>先頭が大文字である場合と小文字である場合を区別</b>します．
そして，これらを区別することで，<b>パッケージ外からの識別子の可視性</b>をコントロールしています．</p>
<p>具体的には，<code>fmt</code> パッケージ内にも先頭が小文字の識別子が存在しますが，これらの識別子を <code>main</code> パッケージから参照することはできません．
<b>小文字はじまりの識別子はパッケージローカル</b>，すなわち Java でいえば「アクセス修飾子なし」の状態であるということになります．
一方，<b>大文字はじまりの識別子は Java でいうところの public</b> になるため，<code>main</code> パッケージから <code>fmt.Println</code> 関数を参照することができるということです．</p>
<p>このルールは現在のところあまり意識する必要はありません．
ですが，今後プロジェクトが大きくなってパッケージを分割していく必要が生じた際に落とし穴になる可能性があるため，ここで説明をしました．
今後も必要に応じて触れる予定でいます．</p>
<h3 id="制御構造"><a class="header" href="#制御構造">制御構造</a></h3>
<p>複雑な処理を実行するために必要な機能である条件分岐と繰り返しについて説明します．</p>
<h4 id="条件分岐"><a class="header" href="#条件分岐">条件分岐</a></h4>
<p>条件分岐には，主に <code>if</code> および <code>switch</code> を使用します．</p>
<h5 id="条件分岐-1-if"><a class="header" href="#条件分岐-1-if">条件分岐 1: <code>if</code></a></h5>
<p><code>if</code> はC言語とほとんど同じですが，Go言語 では<b>条件節に丸括弧が不要</b>です．</p>
<pre><code class="language-go">// iは整数型の変数
if i % 2 == 0 {
    fmt.Println(&quot;Even!&quot;)
} else {
    fmt.Println(&quot;Odd!&quot;)
}
</code></pre>
<h5 id="条件分岐-2-switch"><a class="header" href="#条件分岐-2-switch">条件分岐 2: <code>switch</code></a></h5>
<p>次に <code>switch</code> ですが，通常の使い方はこちらもだいたい同じです．</p>
<pre><code class="language-go">// iは整数型の変数
switch i {
    case 42:
        fmt.Println(&quot;Answer to the Ultimate Question of Life, the Universe, and Everything&quot;)
    case 57:
        fmt.Println(&quot;Prime!&quot;)
    default:
        fmt.Println(&quot;Common number&quot;)
}
</code></pre>
<p><code>if</code> と同じように，<code>switch(i) {</code> ではなく <code>switch i {</code> と書けます．
ただし，C言語 との違いとしてデフォルトで fall through しないようになっています．
したがって，至る所に <code>break</code> と書く必要がありません．
一方で <code>break</code> の代わりに <code>fallthrough</code> と書くことで，わざと fall through させることもできます．</p>
<p>Go言語 の <code>switch</code> における便利な機能として，複数のマッチ対象を一度に書く機能があります．
また，対象は整数値に限定されず，他の型でも渡すことができます．
以下に具体例を示します．</p>
<pre><code class="language-go">// prefecture はstring型の変数
switch prefecture {
    case &quot;Hokkaido&quot;:
        return &quot;countryside&quot;
    case &quot;Tokyo&quot;, &quot;Yokohama&quot;:  // &quot;Tokyo&quot; か &quot;Yokohama&quot; の場合にマッチ
        return &quot;metropolis&quot;
    default:
        return &quot;unknown&quot;
}
</code></pre>
<p>さらに，Go言語 の <code>switch</code> は複数条件を持つ <code>if</code> として使用することもできます．</p>
<pre><code class="language-go">func Collatz(n int) bool {
    switch {    // 対象がないがtypoではない
        case n &lt; 1:
            return false
        case n == 1:
            return true
        case n % 2 == 0:
            return Collatz(n / 2)
        default:
            return Collatz(3 * n + 1)
    }
}
</code></pre>
<p>複数の <code>case</code> 条件を満たす場合には，より上に書かれたものが優先されます．
すべての <code>case</code> が実行されるわけではないので注意してください．</p>
<h4 id="繰り返し"><a class="header" href="#繰り返し">繰り返し</a></h4>
<p>繰り返しを表現するには <code>for</code> を使用します．
<code>while</code> はありません．</p>
<p>例として 1 から 100 までの整数を出力するプログラムを示します．</p>
<pre><code class="language-go">for i := 1; i &lt;= 100; i++ {
    fmt.Println(i)
}
</code></pre>
<p><code>for</code> も C言語 のものとほとんど同じですが，<code>if</code> と同様に丸括弧を書きません．
ここで，繰り返し変数の定義として <code>i := 1</code> を与えていますが，これは <code>for</code> スコープ内の局所変数なので <code>:=</code> による型推論を含めた初期化 + 定義が可能となっています．</p>
<p>より便利な例を見てみます．
Go言語 にも当然データ構造としての<b>配列</b>があるわけですが，配列のインデックスと要素を順に出力したい状況はよく発生します．
そうした場合，以下のように Java の拡張for文のような書き方ができます．</p>
<pre><code class="language-go">animals := []string{&quot;dog&quot;, &quot;cat&quot;, &quot;Tasmanian devil&quot;}
for i, a := range animals {
    fmt.Printf(&quot;%d: %s\n&quot;, i, a)
}
</code></pre>
<p>インデックス値が不要の場合には <code>_</code> で受けて破棄することで対応できます．</p>
<p>Go言語に <code>while</code> はありませんが，<code>for</code> によって <code>while</code> と同等のことが表現できます．</p>
<pre><code class="language-go">for i &lt; 10 { ... }  // while(i &lt; 10) に相当
for true { ... }    // while(true) に相当 (無限ループ)
</code></pre>
<p>特に 2 つめの無限ループに関しては特別な記法があり，条件節を省略して</p>
<pre><code class="language-go">for { ... }   // for true { ... } と同等
</code></pre>
<p>と書くだけで十分です．</p>
<h5 id="練習問題"><a class="header" href="#練習問題">練習問題</a></h5>
<p>ここまでの理解度を測るため，FizzBuzz問題を解いてみましょう．</p>
<p>手順として以下の要件を満たす関数を順に作成し，最後に組合せることで1〜30までの数値についてFizzBuzzを表示するプログラムを作成してください．</p>
<ol>
<li>3の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 3の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>5の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 5の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>15の倍数 を判定する関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 15の倍数 であれば <code>true</code>，それ以外は <code>false</code></li>
</ul>
</li>
<li>出力すべき文字列を返す関数
<ul>
<li>入力：整数値 (<code>int</code>)</li>
<li>出力：入力が 3の倍数 であるが 5の倍数 でなければ <code>&quot;Fizz&quot;</code> を，3の倍数 でないが 5の倍数 であれば <code>&quot;Buzz&quot;</code> を，15の倍数 であれば <code>&quot;FizzBuzz&quot;</code> を，それ以外は入力値を文字列化して返す</li>
</ul>
</li>
</ol>
<div class="memo">
整数値を文字列化するには，<code class="hljs">fmt.Sprintf</code> 関数か，strconv パッケージ名の <code class="hljs">strconv.Iota</code> を使用するとよい．
</div>
<p><a href="https://gist.github.com/y7amura/262cbbc739017ca2713f4a95fba80731">ここから実装例が確認できます</a></p>
<h3 id="ポインタ"><a class="header" href="#ポインタ">ポインタ</a></h3>
<p>Go言語 にもポインタが存在し，役割や使い方などは C言語 のポインタとほぼ同じです．
ただし，Go言語 は GC (Garbage Collection) 機能を持つ言語なので，C言語 のポインタに比べれば制約も緩く，やや扱いやすいものになっています．</p>
<div class="memo">
本演習に限らず，ポインタの概念が怪しい人は「手続き型プログラミング 発展」などの資料を見直し，復習しておくことを推奨します．
</div>
<p>Go言語 のポインタ変数は，C言語 と同様に型名にアスタリスクを付けることで宣言が可能です．
ただし，型宣言の方法が異なったように，ポインタ変数の型宣言もまた C言語 とは異なり，たとえば整数型ポインタであれば <code>*int</code> のように<b>型名の前にアスタリスク</b>がつきます．</p>
<p>また C言語 と同様に，通常の変数に &amp; (アンパサンド) を付けることで，その変数へのポインタを取得できます．
逆にポインタから値を参照したいときも，C言語 と同様にアスタリスクによるデリファレンスが可能です．</p>
<p>これまでの関係を整理すると，以下のようになります．</p>
<pre><code class="language-go">var i int = 0
var p *int = &amp;i  // 変数iのポインタを取得
var j int = *p   // ポインタ変数pを経由して変数iの値を取得
</code></pre>
<p>とりあえずポインタ変数を確保して，後から値を代入したい場合には組み込み関数 <code>new</code> を使うと良いです．</p>
<pre><code class="language-go">var p *int
p = new(*int)

*p = 1
</code></pre>
<p><code>new</code> を使うため誤解が生じるかもしれませんが，<code>free</code> はありません．
ポインタ変数 <code>p</code> は，不要になれば GC によって勝手に解放されます．</p>
<p>C言語 では無効なポインタ値として <code>NULL</code> が定義されていましたが，Go言語 では <code>nil</code> になります．
Go言語 では，未初期化のポインタ変数は <code>nil</code> を指すことが言語仕様上決まっています．</p>
<p>また，GC がある言語であるため，以下のコードが Go言語 では合法になります．</p>
<pre><code class="language-go">func NewInt() *int {
    p := 1
    return &amp;p
}

var p *int
p = NewInt()
</code></pre>
<p>このコードは関数スタックに積まれた局所変数のポインタを返しているので，C言語では合法ではありません．
一方 Go言語 では，これは特にエラーもなく動きます．
実際，Go言語 のコードでは局所変数のポインタどころか即値のポインタすら関数外へ return するようなコードがよく見られます．
代表的な例としては，次のセクションで説明する構造体を関数ローカルで定義し，そのまま return するコードです．</p>
<pre><code class="language-go">type Person struct {
    Name string
    Age int
}

func NewPerson(name string, age int) *Person {
    return &amp;Person{ name, age }
}
</code></pre>
<p>C言語 としてみるとなんだか不思議なコードですが，Go言語 では割と普通に見かけます．</p>
<h5 id="練習問題-1"><a class="header" href="#練習問題-1">練習問題</a></h5>
<p>次のコードがどういう出力になるか考え，実装して確かめてみよ．</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func IncrementV(v int) {
    v = v + 1
}

func IncrementP(p *int) {
    *p = *p + 1
}

func main() {
    v := 0

    IncrementV(v)
    fmt.Printf(&quot;v = %d\n&quot;, v)

    p := &amp;v
    IncrementP(p)
    fmt.Printf(&quot;v = %d\n&quot;, v)
}
</code></pre>
<h3 id="配列とスライス"><a class="header" href="#配列とスライス">配列とスライス</a></h3>
<p>同じ型の複数の値をまとめて扱うためのデータ構造として<b>配列</b>と<b>スライス</b>が存在します．
Go言語 において通常「<b>配列</b>」と呼ぶものは「固定長配列」を意味しており，これは決められた長さを持つデータ構造です．
一方で，「<b>スライス</b>」は一般に「可変長配列」と呼ばれるものであり，こちらはその名の通り長さを変えることができます．</p>
<h4 id="配列"><a class="header" href="#配列">配列</a></h4>
<p>配列 (固定長配列) 定義の基本形は <code>var 変数名 [長さ]型</code> になります．
また，初期値を直接与える場合には，<code>変数名 := [...]型 { 初期値のリスト }</code> というように長さを推論させることができます．
したがって，配列の型としての記法は <code>[長さ]型</code> であり，この点からも長さを指定する必要があることがわかります．</p>
<p><code>var 変数名 [長さ]型</code> の形式で定義された配列は，指定された長さの分だけ型ごとに決められたデフォルト値ですべての要素が初期化されます．
すなわち，以下の例において <code>a1</code> と <code>a2</code> はすべての要素が等しい 2 つの異なる配列ということになります．</p>
<pre><code class="language-go">var a1 [5]int
a2 := [...]int{0, 0, 0, 0, 0}
</code></pre>
<p>配列中の特定の要素は，C言語と同様に <code>変数名[インデックス値]</code> でアクセス可能です．
他の多くの言語と同様に，0-based indexing になっています．</p>
<pre><code class="language-go">a := [...]int{1, 2, 3, 4, 5}
fmt.Println(a[0])  //=&gt; 1
</code></pre>
<p>Go言語はすべての変数が値として扱われるため，配列もいわゆる値型と呼ばれるような挙動をします．
すなわち，以下のコードにおいて <code>a2</code> は <code>a1</code> のコピーになり，両変数は別の領域にあるデータを指します．</p>
<pre><code class="language-go">a1 := [...]int {1, 2, 3, 4}  // 新しい長さ4の配列
a2 := a1                     // a1と同じ内容の新しい長さ4の配列
</code></pre>
<h4 id="スライス"><a class="header" href="#スライス">スライス</a></h4>
<p>スライス (可変長配列) 定義の基本形は <code>var 変数名 []型</code> となり，配列定義から長さの指定が消えた形となっています．
初期値を直接与える場合も長さの指定がないため，<code>変数名 := []型 { 初期値のリスト }</code> という表現になります．
スライスの型としての記法は <code>[]型</code> です．</p>
<p><code>var 変数名 []型</code> の形式で定義されたスライスは，サイズが 0 になります．
つまり，なにも入っていない状態です．
スライスも配列と同様に <code>変数名[インデックス]</code> の形式で各要素にアクセスできますが，サイズ 0 のスライスにアクセスした場合，どのようなインデックス値に対しても範囲外アクセスによりプログラムが異常終了します．</p>
<p><code>var 変数名 []型</code> の形式で定義したスライスは，組み込み関数 <code>make</code> によって指定したサイズのスライスとして確保しなおすことができます．
組み込み関数 <code>make</code> は引数として型，サイズ，キャパシティの 3 つをとりますが，キャパシティは省略可能です．
キャパシティを省略した場合，おそらくサイズに依存して適切なキャパシティが自動設定されます．</p>
<pre><code class="language-go">var array []int         // これはサイズ0の整数型スライス
array = make([]int, 5)  // ここでサイズ5の整数型スライスになる (キャパシティは自動設定)
</code></pre>
<div class="memo">
これは教員自身が Go言語 でプログラムを書くとき (年に1回くらいのイベント) によくやることなのですが，スライスを使った周辺でプログラムが落ちる場合はだいたいサイズ 0 のまま使おうとして範囲外アクセスで落ちていることが多いです．
スライスを宣言した周辺でプログラムが異常停止する場合は，このミスを疑ってみると良いかもしれません．
</div>
<p>スライスも値ではあるのですが，いわゆる参照型のような挙動をします．
スライスはメモリ上での先頭アドレス・サイズ・キャパシティを持っているようなデータ構造なので，スライスのコピーはこれらの値のコピーを意味します．
つまり，以下のコードにおいて <code>a2</code> は <code>a1</code> の持つ先頭アドレス・サイズ・キャパシティの値をコピーしたものであるため，指している先頭アドレスは同じとなり，実質的に同じものを指す変数となります．</p>
<pre><code class="language-go">a1 := []int {1, 2, 3, 4}  // a1が持つのは，先頭要素のアドレス，サイズ，キャパシティ
a2 := a1                  // a2が持つのは，a1の先頭要素のアドレス，サイズ，キャパシティ
</code></pre>
<p>スライスは可変長であるため，組み込み関数 <code>append</code> を使って要素を追加し，スライスの長さを変えることができます．
<code>append</code> 関数は追加する要素を複数とることができ，追加後のスライスを返します．</p>
<pre><code>a1 := []int{1, 2, 3, 4}
a1 = append(a1, 5, 6, 7)    //=&gt; a1 == [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>ここで注意すべきこととして，追加前の <code>a1</code> が指していた先頭要素のアドレスと追加後の <code>a1</code> が指す先頭要素のアドレスが一致する保証はありません．
要素を追加した結果として <code>a1</code> のキャパシティを超えてしまう場合，新たなキャパシティで <code>a1</code> を再確保することでスライスの伸長を行うためです．
すなわち，<code>append</code> 関数はメモリアロケーションを発生させる可能性があり，場合によってはパフォーマンスに影響が出ることもあります．</p>
<p>追加には <code>append</code> 関数がある一方で，削除する関数はありません．
Go言語 では Python のように<b>部分スライス</b>を取得できるので削除関数を自作することはできます．</p>
<h3 id="構造体"><a class="header" href="#構造体">構造体</a></h3>
<p>複数の型をまとめた複合型を作りたい場合，Go言語 では<b>構造体</b>を使用します．
C言語 の構造体と同じものです．</p>
<p>構造体を定義するには <code>struct</code> キーワードを使用します．
たとえば，文字列型の名前と整数型の年齢をフィールドに持つ構造体の定義は以下のようになります．</p>
<pre><code class="language-go">struct {
    Name string
    Age int
}
</code></pre>
<p>C言語 では構造体を定義する際に構造体名を与えないといけませんでしたが，Go言語 では不要です．
これはそのまま型として機能するので，次のような変数宣言が可能です．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}
</code></pre>
<p>構造体変数は以下のように，波括弧を用いてそれぞれのフィールドに代入する値を指定することで初期化できます．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}{
    &quot;Tech-chan&quot;,
    5,            // 最後のフィールド値のあとに改行を入れる場合，ここのカンマは必要
}
</code></pre>
<p>また，フィールド名を指定して初期化することもできます．</p>
<pre><code class="language-go">var person struct {
    Name string
    Age int
}{
    Name: &quot;Tech-chan&quot;,
    Age: 5,             // 最後のフィールド値のあとに改行を入れる場合，ここのカンマは必要
}
</code></pre>
<p>フィールド名を指定した初期化方法は，フィールドの宣言順序に依存せずに構造体を初期化したい場合や，一部のフィールドにだけ値を与えたい場合などに有効です．</p>
<p>構造体変数のフィールドへは，Java のインスタンス変数などと同様に <code>.</code> (ドット) でアクセスできます．</p>
<pre><code class="language-go">fmt.Println(person.Name)  //=&gt; Tech-chan
</code></pre>
<p>構造体変数がポインタの場合，C言語 ではアロー演算子 <code>-&gt;</code> を使用する必要がありましたが，Go言語 では <code>.</code> (ドット) のままで大丈夫です．</p>
<pre><code class="language-go">p := &amp;person
fmt.Println(p.Name)  //=&gt; Tech-chan
</code></pre>
<p>さて，ここで Go言語 の識別子の表記と可視性の規則を思い出してみましょう．
<b>小文字はじまりはパッケージローカル</b>で，<b>大文字はじまりは外部パッケージからも参照可能</b>というルールでした．
ここまで何気なくフィールド名を大文字で書いてきましたが，この識別子の命名規則はフィールド名にも適用されます．
すなわち，フィールド名を小文字はじまりで設定した場合，外部パッケージでは構造体変数のフィールドへアクセスできなってしまいます．
この機能を上手に使うと<b>カプセル化</b>を実現できますが，特に構造体のフィール変数については，慣れないうちは間違い防止のためにすべて大文字はじまりで書いておく方が安全かもしれません．</p>
<h3 id="型の別名とメソッド"><a class="header" href="#型の別名とメソッド">型の別名とメソッド</a></h3>
<p>構造体の定義方法はわかりましたが，同じ構造体型を複数の場所で何度も使用する場合に，毎回すべてのフィールド定義を書くのは面倒です．
Go言語 には<b>型に別名をつける</b>機能があるので，これを使って少し楽をしましょう．</p>
<p>型へ別名をつけるためには <code>type 別名 元の型</code> という構文を使用します．
C言語 の <code>typedef</code> のようなものだと思ってください．</p>
<p><code>type</code> キーワードを使って先ほど定義した構造体に <code>Person</code> という型名をつけてみます．</p>
<pre><code class="language-go">type Person struct {
    Name string
    Age int
}

person := &amp;Person{
    Name: &quot;Tech-chan&quot;,
    Age: 5,
}
</code></pre>
<p>だいぶ見慣れた表現になったのではないでしょうか．</p>
<p><code>type</code> キーワードにはもう一つ特殊な機能があります．
同一パッケージ内で <code>type</code> キーワードによって別名を付けた型には，<b>メソッド</b>と呼ばれる特殊な形式の関数を紐づけることができるようになります．
Go言語 には Java のような <code>class</code> はありませんが，この機能を使うことでオブジェクト指向的な機能をを実現することができます．</p>
<p>たとえば，構造体 <code>Person</code> に文字列へ変換するメソッド <code>ToString</code>，および，年齢を 1 歳増やすメソッド <code>GetOlder</code> を実装してみます．</p>
<pre><code class="language-go">type Person {
    Name string
    Age int
}

func (p Person) ToString() string {
    return fmt.Sprintf(&quot;Name: %s, Age: %d&quot;, p.Name, p.Age)
}

func (p *Person) GetOlder() {
    p.Age = p.Age + 1
}
</code></pre>
<p>メソッドはこのように <code>func (変数名 型) 関数名(引数リスト) 戻り値型 {}</code> の形式で定義することができます．
関数名の前に配置する変数を一般に<b>レシーバ</b>といいます．
レシーバには値型あるいはポインタ型が設定でき，レシーバの内容を変更したい場合にはポインタ型を使用する必要があります．</p>
<p>メソッドの呼び出しは Java などと同様に以下のように行うことができます．</p>
<pre><code class="language-go">person := Person{
    Name: &quot;Tech-chan&quot;,
    Age: 5,
}

fmt.Println(person.ToString())  //=&gt; Name: Tech-chan, Age: 5

person.GetOlder()
fmt.Println(person.ToString())  //=&gt; Name: Tech-chan, Age: 6
</code></pre>
<p>フィールドへのアクセスと同様に，レシーバをポインタ型で定義した場合であっても，そのままドットでアクセスすることができます．便利．</p>
<div class="memo">
構造体が大きい場合も，変更の有無に関わらずポインタ型とするのが良いでしょう．
レシーバとして値型を設定すると，メソッド呼び出しのたびに構造体のコピーが発生するため，パフォーマンス低下の原因になります．
また，こうした事情からレシーバは常にポインタ型にする開発者もいます．
とはいえ，値型とすることで予期せぬ変更を防ぐことができる利点もあるため，適切に使い分ける方が良い気はします．
</div>
<p>さきほど <code>type</code> キーワードは型に別名をつけることができると書きました．
その機能を使用して構造体に名前をつけたわけですが，考えてみれば構造体以外の型でも別名はつけられます．
さらに別名をつけた型には (同じパッケージ内において) メソッドを定義できるというわけです．</p>
<p>つまり，これができます．</p>
<pre><code class="language-go">type MyInt int

func (i MyInt) ToString() string {
    return fmt.Sprintf(&quot;%d&quot;, i)
}

fmt.Println(MyInt(5).ToString())  //=&gt; 5
</code></pre>
<p>ちなみに，7行目において <code>5.ToString()</code> と書くことはできません．
きちんと <code>MyInt</code> 型に変換してからメソッドを呼ぶ必要があります．
これくらいなら普通に <code>int</code> を引数とする関数を定義する方が良いですが，この機能は何かに使えるかもしれませんね．</p>
<!--
### パッケージ
最後に Go言語 の文法ではなく．パッケージの仕組みについて簡単に整理しておきます．

冒頭でも述べた通り，Go言語 ではすべてのファイルが何かしらのパッケージに属し，パッケージの集合であるモジュールが 1 つのプロジェクトになります．
特殊なパッケージである `main` を除いて，パッケージ名には一般にファイルが存在するディレクトリの名前を付けるのが一般的です．
-->
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>駆け足で非常に浅い Go言語 の入門書ですが，最低限必要になりそうな機能は網羅できたと思います．
Go言語 は慣れると割と書きやすい言語ですが，慣れるまでは変な機能も多く，コンパイラの文句も多いので苦労するかと思います．
これ以降の資料でも可能な限り補足はしていくつもりですが，必要に応じてこのページを見返したり，教員へ質問したり，あるいは自身で調べたりなどによって対応してください．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-http通信とルーティング"><a class="header" href="#02-http通信とルーティング">02: HTTP通信とルーティング</a></h1>
<p>今回から本格的にWebアプリケーションを構築するための基礎技術に触れていきます．</p>
<p>第2回は，特に以下の内容について扱います．</p>
<ol>
<li>Webアプリケーションの基本的な動作</li>
<li>Web通信の決まりごと (Hypertext Transfer Protocol; HTTP)</li>
<li>アクセス先の制御 (ルーティング)</li>
</ol>
<p>また今回の資料は，前回配布したプロジェクトとは異なる新たなプロジェクトをベースとして演習を進めます．
以下のリンクより新しいプロジェクト httpserver.go をダウンロードし，演習が進められるよう展開・配置してください．</p>
<p><a href="https://github.com/cs-sysdes/httpserver.go">https://github.com/cs-sysdes/httpserver.go</a></p>
<p>ダウンロード方法は <a href="01_preliminary.html">前回の資料</a> を参照してください．</p>
<h2 id="webアプリケーションの基本的な動作"><a class="header" href="#webアプリケーションの基本的な動作">Webアプリケーションの基本的な動作</a></h2>
<p><b>Web技術</b>を基盤としたアプリケーションを総称して「Webアプリケーション」と呼びます．
Webアプリケーションは，一般に <b>Client-Server model</b> と呼ばれるアプリケーション形態をとり，Client側アプリケーション (Client-side application) と Server側アプリケーション (Server-side application) という2つのアプリケーションによって構成されます．
基本動作として <b>Client からの要求 (リクエスト)</b>に対して <b>Server が応答 (レスポンス)</b>を返す形式で目的の処理を実行します．</p>
<p><img src="img/webapp_flow.png" alt="Client-Server model" /></p>
<p>Client-side アプリケーションには <b>Webブラウザ</b> を採用する場合が多いですが，場合によって専用のアプリケーションを提供する場合もあります．
たとえば，Twitter社は自社のサービスとして Webブラウザ上で Tweet を閲覧可能な Twitter Web App を提供していますが，スマホ用にネイティブアプリケーションとして Twitter for Android や Twitter for iPhone などを提供しています．
また，サードパーティ製アプリケーションまで含めると，PC用あるいはタブレット用アプリケーションなど，さまざまなものが提供されています．
本演習では Client-side アプリケーションには Webブラウザ を採用するため，各自で Client-side アプリケーションを構築してもらう必要はありません．</p>
<p>Server-side アプリケーションは Client-side アプリケーションからのリクエストをもとに，必要に応じて内部状態の更新などを行い，Client-side アプリケーションにレスポンスを返します．
アプリケーションの目的に応じてデータベースや認証システムなど，他の外部サービスと連携して処理を行う場合もあります．
本演習で主に扱うのは，こちらの Server-side アプリケーションになります．</p>
<h3 id="server-side-アプリケーションの実行"><a class="header" href="#server-side-アプリケーションの実行">Server-side アプリケーションの実行</a></h3>
<p><a href="https://github.com/cs-sysdes/httpserver.go">今回配布するプロジェクト</a>は，Server-side アプリケーションとして最低限の通信機能と動作ログを標準出力へ書き出す機能のみをもつプログラムになります．
本ページの以降の説明では，このプログラムを編集し，Webアプリケーションの動作について学びます．</p>
<p>前回と同様に <code>~/sysdes/httpserver.go</code> にダウンロードしたプロジェクトが展開されていると仮定します．
このパスは各自の環境で置き換えてください．</p>
<p>ターミナルエミュレータを起動し，Dockerコンテナを起動します．</p>
<pre><code class="language-sh">$ cd ~/sysdes/httpserver.go
$ docker-compose up -d
</code></pre>
<p>プログラムを起動し，2行目ようなログが表示されることを確認してください．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
2022/10/08 03:30:00 Listen:  [::]:8000
</code></pre>
<p>冒頭のタイムスタンプや <code>[::]</code> の部分は実行タイミングや環境によって異なる場合があります．</p>
<p>このプログラムは Server-side アプリケーションなので，起動すると Client-side アプリケーションからの接続を待機します．
したがって，なにか処理をさせるためには，Client-side アプリケーションからリクエストを送信する必要があります．
先ほど述べた通り，本演習では Client-side アプリケーションとしてWebブラウザを使用することとしているので，ChromeなどのWebブラウザからリクエストを送信してみましょう．</p>
<p>Webブラウザを開き，URL欄に <code>localhost:8000</code> あるいは <code>127.0.0.1:8000</code> と打ち込んでエンターを押してみましょう．
プログラム側のログは以下のような状態となるはずです．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
2022/10/08 03:30:00 Listen:  [::]:8000
2022/10/08 03:35:31 Connected by  172.19.0.1.41888
2022/10/08 03:35:31 Connected by  172.19.0.1.41892
2022/10/08 03:35:32 Connected by  172.19.0.1.41896
</code></pre>
<p>先ほどと同様に，冒頭のタイムスタンプや <code>172.19.0.1:41888</code> の部分，出力されるログの数は実行タイミングや環境によって異なります．</p>
<p>これらのログは，Client-side アプリケーションからのリクエストを受信したことを意味します．
この例のように，1 度しかアクセスしていないのに複数のログが出る場合がありますが，使用するWebブラウザによってこの辺の挙動は変わりますので，いまはあまり気にしなくて良いです．</p>
<p>プログラムの方ではリクエストを受け取ったことをログから確認できました．
一方で，Webブラウザの方はどうなっているでしょうか．</p>
<p>おそらく，通常の動作だと「ページが動作していない」などのエラーが表示されていると思います．
たとえば，教員の端末では以下のような表示になっています．</p>
<p><img src="img/invalid_response.png" alt="Error page" /></p>
<p>現段階では，<b>これは正常な動作結果</b>ですので，安心してください．</p>
<p>このエラー画面に代えて，Webブラウザ上に ”Hello world&quot; と表示することを次の目標とします．</p>
<h3 id="server-side-アプリケーションの停止"><a class="header" href="#server-side-アプリケーションの停止">Server-side アプリケーションの停止</a></h3>
<p>具体的なプログラムの開発に移る前に，プログラムの停止方法を説明します．</p>
<p>今回以降において実行する Server-side アプリケーションは，基本的に Client-side からのリクエストを待ち受け，リクエストに対してレスポンスを返す動作を繰り返し行うプログラムになります．
したがって，初期状態では停止する方法を実装していません．
停止できなければプログラムを変更して再起動することもできないので，どうにかして停止する必要があります．</p>
<p>停止方法は簡単で，ターミナルエミュレータ上で強制停止シグナルを送信することでプログラムを強制的に落とします．
強制停止シグナルを送信するには，プログラムを実行しているターミナルエミュレータ上で，<code>Ctrl-c</code> を入力します．
すなわち，キーボード上の <code>Ctrl</code> ボタンとアルファベットの <code>c</code> を同時押しすることで，プログラムを停止することができます．</p>
<h3 id="httpservergomaingo-概観"><a class="header" href="#httpservergomaingo-概観">httpserver.go/main.go 概観</a></h3>
<p>ここで，どうやらうまく動いていないらしいプログラムの中身を簡単に解説します．
スクロールしながら資料を追うのは難しいと思うので，各自の手元で main.go を開きながら進めると良いかと思います．</p>
<p>main.go には以下のように Server-side アプリケーションが実装されています．</p>
<p><span class="filename">httpserver.go/main.go</span></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net&quot; // standard network package
)

func main() {
	// config
	port := 8000
	protocol := &quot;tcp&quot;

	// resolve TCP address
	addr, err := net.ResolveTCPAddr(protocol, fmt.Sprintf(&quot;:%d&quot;, port))
	if err != nil {
		log.Fatalln(err)
	}

	// get TCP socket
	socket, err := net.ListenTCP(protocol, addr)
	if err != nil {
		log.Fatalln(err)
	}
	log.Println(&quot;Listen: &quot;, socket.Addr().String())

	// keep listening
	for {
		// wait for connection
		conn, err := socket.Accept()
		if err != nil {
			log.Println(err)
			continue
		}
		log.Println(&quot;Connected by &quot;, conn.RemoteAddr().String())

		// yield connection to concurrent process
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	// close connection when this function ends
	defer conn.Close()

	// write response
	conn.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<p><a href="01_preliminary.html">前回</a>触れなかった機能として，3--7行目のように，Go言語の import 文は変数宣言などと同じように複数のパッケージを丸括弧でグループ化して一括で宣言することができます．</p>
<p>9--40行目の <code>main</code> 関数では，Web通信用にソケットを開き (15, 21行目)，外部からの接続を待機しています (28--39行目)．</p>
<p>このプログラムでは，30行目で受け取った外部からの接続 <code>conn</code> を，38行目で <code>handleConnection</code> に渡し，具体的なリクエストおよびレスポンスの処理は <code>handleConnection</code> 関数内で行うよう設計しています．
したがって，これから <code>handleConnection</code> 関数を適切に実装することで，正しく応答する Server-side アプリケーションを開発していきます．</p>
<p>プログラム全体を見渡してみると，以下のような頻出する表現があることに気付きます．</p>
<pre><code class="language-go">if err != nil {
    ...  // 何かしらの処理
}
</code></pre>
<p>これは Go言語 を書く上でおそらく一番よく使うであろう<b>エラーハンドリング</b>を行う記述パターンになります．</p>
<p>たとえば15行目では，与えられたポート番号 (<code>port := 8000</code>) から通信ソケットのアドレスを取得していますが，与えられた文字列が正しいフォーマットではない場合などに，<code>net.ResolveTCPAddr</code> 関数はエラーになります．
Go言語には Java の try-catch のような言語機能がないため，エラーの有無は一般に関数の戻り値として通知されます．
エラーが発生した場合，<code>net.ResolveTCPAddr</code> 関数は第2戻り値としてエラーを伝達するため，第2戻り値を受ける <code>err</code> が <code>nil</code> ではないとき，それはエラーが発生していることを示します．</p>
<p><span class="filename">httpserver.go/main.go (15--18行目 抜粋)</span></p>
<pre><code class="language-go">addr, err := net.ResolveTCPAddr(protocol, fmt.Sprintf(&quot;:%d&quot;, port))   // ここでエラーが発生した場合
if err != nil {                                                       // ここで err != nil となり
    ...                                                               // ここに記述された処理が実行される
}
</code></pre>
<p>このように，Go言語では処理が失敗する可能性がある関数はエラーの有無を表す <code>error</code> 型の戻り値を返すのが一般的です．
<code>error</code> 型の戻り値は，エラーがない，すなわち関数の処理が正常に終了した場合には <code>nil</code> になります．
そうでない場合，すなわち，関数の処理に失敗した場合には，エラー情報を含む <code>error</code> 型の値になります．
したがって，<code>error</code> 型の戻り値の <code>nil</code> 判定を行って，エラーの有無を調べるのが一種の記述パターンになっています．</p>
<p>ところで，<a href="01_preliminary.html">前回</a>の資料中で，通常 <code>:=</code> による変数定義は複数回できないが例外もあるという話をしたかと思います．
今回の <code>err</code> の定義がその例外で，たとえば <code>main</code> 関数の中では，15行目と21行目に同じスコープ内で複数回 <code>err</code> を定義しているように見えます．
これについては，この書き方を許容しないと <code>err</code> のように使い回される可能性がある変数を最初に <code>var err error</code> などと定義しなくてはならず不便なので，例外として許されています．
注意すべきは，<code>err</code> の他に別の新たな変数も同時に定義されているという点で，Go言語 ではこの場合に限り複数回同じ変数を定義しても良いということになっています．
つまり，以下のコードは <code>err</code> 以外に新たな変数が定義されていないので，コンパイルエラーになります．</p>
<pre><code class="language-go">func f() {
    err := ThisCanReturnError()
    err := ThisCanAlsoReturnError()
}
</code></pre>
<p>こういうケースでは，以下のように局所スコープを利用すると良いでしょう．</p>
<pre><code class="language-go">if err := ThisCanReturnError(); err != nil {
    ...
}
</code></pre>
<p>少し話が逸れましたが，最後に38行目の <code>handleConnection</code> 関数を呼び出す記述について見てみます．
この行では関数呼び出しとして通常通り <code>handleConnection(conn)</code> とは書かずに，冒頭に <code>go</code> キーワードを付与して <code>go handleConnection(conn)</code> として関数呼び出しを行っています．
この記述は Go言語 特有のもので，<code>handleConnection</code> 関数を goroutine という機能を使用して<b>並行実行</b>するための記述法です．
すなわち，<code>handleConnection</code> 関数は <code>main</code> 関数の実行とは独立して並行的に処理され，<code>main</code> 関数は <code>handleConnection</code> 関数の結果を待たずに次の処理へとプログラムの実行を進めます．
したがって，<code>handleConnection</code> 関数の実行によって <code>main</code> 関数の実行が妨げられることが (普通は) ないので，<code>main</code> 関数は次々と外部からの接続受けて <code>handleConnection</code> へ渡すといった動作を絶え間なく行うことができます．</p>
<div class="memo">
Go言語 は並行処理を記述しやすいよう設計されたプログラミング言語であり，C言語であれば <code class="hljs">fork</code> を用いたり，Java であれば <code class="hljs">Thread</code> を使って書かなくてはいけないプログラムの並行実行を，<code class="hljs go">go</code> キーワードを付与した関数呼び出しという形で簡単に実行できるようになっています．
goroutine は面白い機能ですが，この演習において理解すべき言語機能というわけではないですし，かなり奥深い内容になってしまうため，詳細な説明は省略します．
</div>
<p>44行目の <code>defer</code> キーワードも Go言語 の面白い機能の一つで，<code>defer</code> キーワードを付けて記述された関数呼び出しは，スコープを抜ける際に実行されるようになります．
要するに関数呼び出しの予約機能みたいなものです．
<code>conn</code> 変数は外部との接続を表す変数であり，Java でファイル操作を行った時と同様に，使い終わったら <code>Close</code> してやる必要があります．
関数の最後に <code>conn.Close()</code> と記述しても同じことですが，できれば変数宣言の近くに <code>Close</code> 指定がある方がプログラムの見通しが良いため，<code>defer</code> を使って事前予約すると良いでしょう．</p>
<p>Go言語 の機能に関する説明もしたため長くなりましたが，このプログラムの一番重要な部分として，47行目において <code>conn</code> にバイト列を書き込んでいるのが確認できます．
ここも Java でファイル操作を行った時と同様に，<code>Write</code> 関数によって接続元，すなわち Client-side アプリケーションにバイト列で応答を返すことができます．
ただし，さきほど動かしてみてわかった通り，Webブラウザには &quot;Hello world.&quot; などとは表示されませんでした．
この原理について以降で説明していきます．</p>
<h2 id="web通信の決まりごと-hypertext-transfer-protocol-http"><a class="header" href="#web通信の決まりごと-hypertext-transfer-protocol-http">Web通信の決まりごと (Hypertext Transfer Protocol; HTTP)</a></h2>
<p>Webアプリケーションは Client-side アプリケーションからの <b>リクエスト (Request)</b> に対し，Server-side アプリケーションが <b>レスポンス (Response)</b> を返す形で成り立っています．
このとき，リクエストおよびレスポンスにはそれぞれ決められた形式 (フォーマット) が存在し，こうした形式などを定めた<b>Web通信における約束事 (プロトコル)</b> を <b>Hypertext Transfer Protocol (HTTP)</b> と呼びます．
HTTP は TCP (Transmission Control Protocol) 上で定められたプロトコルであり，TCP/IPモデルでは第4層「アプリケーション層」，OSI参照モデルでは第7層「アプリケーション層」に位置します．</p>
<p>HTTP は本来 HTML や XML といったWeb通信においてやり取りされる Hypertext と呼ばれるデータ形式を扱うためのプロトコルです．
しかしながら，現実的には画像データや音声データ，映像データなど，Web上で利用される様々な形式のデータ送受信に使用されています．</p>
<p>HTTP は通信技術の向上とともに新たなバージョンがいくつか出されています．
代表的なものとして HTTP/1.1，HTTP/2 などがあり，最近では HTTP/3 が正式に標準化されました (2022年6月6日)．
長きにわたって HTTP/1.1 が最も使用率の高いプロトコルでしたが，近年 HTTP2 の使用率が 50% を超えたらしいです (2021年1月)．</p>
<div class="memo">
一般にネットワーク上を流れるデータはすべて<b>バイト列</b>として表現されるため，Web通信におけるリクエストもレスポンスもデータとしては単なるバイト列として扱われます．
通信されるデータが単なるバイト列なので，さまざまなアプリケーションが好き勝手な形式でリクエストを送ったり，あるいはレスポンスを返したりしてしまうと，アプリケーション開発者としては非常に困ったことになります．
特にWebブラウザのような汎用アプリケーションでは，さまざまな Server-side アプリケーションがそれぞれ独自の形式でレスポンスを返してくるとなると，サービスごとのレスポンス形式を個別に知っておく必要があり，これは相当面倒です．
予めデータのフォーマットを定めておき，それに従わないデータは無視して良いということにすると，なにかと便利なわけです．
<p>よくWebサイトなどのURLの先頭についている <code>http:</code> というのは，HTTPに従った通信であることを明示するものです．
最近では <code>https:</code> とする方が一般的となっていますが，これは HTTP Secure と呼ばれる暗号化された通信経路上で HTTP 通信を行うより安全なプロトコルを表すものです．</p>
</div>
<p>HTTP では，リクエストおよびレスポンスそれぞれについて特定の形式に則って通信を行うよう定めています．
それぞれを一般に <b>HTTPリクエスト</b> および <b>HTTPレスポンス</b> と呼びます．
配布したプログラムがうまく動かなかったのは，どうやらこの辺が原因ではないかと推測できます．</p>
<h3 id="httpリクエスト"><a class="header" href="#httpリクエスト">HTTPリクエスト</a></h3>
<p>HTTPリクエストは，Client-side アプリケーションから Server-side アプリケーションへ送信するリクエストの形式を定めます．
通常は Webブラウザ などが自動的に生成するため，自分で記述する必要はありません．
ただし，専用の Client-side アプリケーションを開発し使用する場合には，サーバへの通信がこの形式に従うよう自身で実装する必要がある場合もあります．</p>
<p>代表的なHTTPリクエストの例を示します．</p>
<pre><code class="language-txt">GET /index.html HTTP/1.1
HOST: 127.0.0.1
Connection: keep-alive

</code></pre>
<pre><code class="language-txt">POST /login HTTP/1.1
HOST: 127.0.0.1
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content: multipart/form-data
Content-Length: 38

user=titech&amp;passwd=extremelysafepasswd
</code></pre>
<p>これらの形式を統一的に記述すると以下のようになります．</p>
<pre><code class="language-txt">&lt;METHOD&gt; &lt;PATH&gt; &lt;VERSION&gt;
&lt;HTTP_HEADERS&gt;

&lt;BODY&gt;
</code></pre>
<p>1行目の <code>&lt;METHOD&gt; &lt;PATH&gt; &lt;VERSION&gt;</code> は，<b>リクエストの種類</b>，<b>リクエスト先</b>，および使用する <b>HTTPのバージョン</b> を指定します．
<code>&lt;METHOD&gt;</code> の部分は特に <b>リクエストメソッド</b> と呼ばれ，GET や POST の他に，PUT，DELETE，UPDATE などいくつかの種類が定義されています．
<code>&lt;PATH&gt;</code> の部分はリクエストを送信する対象であるリソースを指定します．
<code>&lt;VERSION&gt;</code> 部分は主に HTTP/1.1 あるいは HTTP/2 である場合が多く，バージョンによって使用できる機能に若干の違いがあるため，ここの指定によって特定の機能が有効か無効かを確認します．
<code>&lt;METHOD&gt;</code>，<code>&lt;PATH&gt;</code>，<code>&lt;VERSION&gt;</code> はスペース区切りで識別されます．
したがって，それぞれの項目はスペースを含まない文字列になります．</p>
<p>2行目の <code>&lt;HTTP_HEADERS&gt;</code> はHTTP/1.1以降で有効になった機能であり，サーバ側へリクエストに関するメタ情報を送る役割を持ちます．
形式として，1行に1つの「key」と「value」のペアを記述でき，<code>&lt;key&gt;: &lt;value&gt;</code> のようにコロン区切りで記述します．
ここは複数行にわたってメタ情報を載せることができ，以下の通り役割によって分類されたいくつかのヘッダ情報を組合せて記述されることが多くなっています．</p>
<ul>
<li>Request headers
<ul>
<li>リクエストに直接関わる情報</li>
<li>HOST や User-Agent といった key が該当する</li>
</ul>
</li>
<li>General headers
<ul>
<li>通信設定などの情報</li>
</ul>
</li>
<li>Representation headers
<ul>
<li><code>&lt;BODY&gt;</code> の形式などに関わる情報</li>
</ul>
</li>
</ul>
<p><code>&lt;HTTP_HEADERS&gt;</code> と <code>&lt;BODY&gt;</code> の間の空行は必須です．
この空行が存在することで，リクエスト中のどこからが <code>&lt;BODY&gt;</code> であるかを判断します．</p>
<p><code>&lt;BODY&gt;</code> はリクエストとしてサーバへ送信される情報そのものを載せる区画になります．
リクエストメソッドが GET である場合には一般に <code>&lt;BODY&gt;</code> は空，すなわちなにも記述されずに送られることが多いですが，もちろん GET リクエストにも <code>&lt;BODY&gt;</code> を載せることはできます．
また，<code>&lt;BODY&gt;</code> の長さ (バイト長) がわからなければ Server-side アプリケーションでどこまで読むべきかを判定できない場合があるため，<code>&lt;REQUEST_HEADERS&gt;</code> 上に <code>Content-Length</code> を key とする長さ情報を付与して送るのが一般的です．</p>
<div class="memo">
<code class="hljs">Content-Length</code> に設定される値は <code class="hljs">&lt;BODY&gt;</code> の<b>byte長</b>であり<b>見かけの文字数とは必ずしも一致しない</b>ことに注意が必要です．
特に日本語などのマルチバイト文字を扱う場合，1文字を複数バイトで表現するため，見かけの文字数とbyte長は一般に一致しません．
</div>
<h5 id="練習問題-2-1"><a class="header" href="#練習問題-2-1">練習問題 2-1</a></h5>
<p>実際にWebブラウザから送られてくるHTTPリクエストを観察してみましょう．</p>
<p>httpserver.go/main.go 内の <code>handleConnection</code> 関数を以下のように編集した上で，プログラムを実行してください．
Webブラウザからのアクセスに対してどのようなログが表示されるか観察し，Webブラウザがたしかに形式的に正しいHTTPリクエストを送信していることを確かめてください．</p>
<pre><code class="language-go">func handleConnection(conn net.Conn) {
    // close connection when this function ends
    defer conn.Close()

    buf := make([]byte, 1024)
    conn.Read(buf)

    log.Printf(&quot;Request\n----------\n%s\n----------&quot;, string(buf))

    // write response
    conn.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<p>このプログラムは，<code>buf := make([]byte, 1024)</code> にてリクエストを読み込むための領域を1024バイト分だけ確保し，<code>conn.Read(buf)</code> によってリクエスト全体を <code>buf</code> へ読み込んでいます．
<code>net.Conn.Read</code> メソッドは本来戻り値として読み込んだ byte 長とエラー情報を返しますが，ここでは特に使用しないため無視しています．
<code>log.Printf</code> 関数によってリクエストの内容を整形してログとして出力しますが，<code>buf</code> は <code>[]byte</code> 型の変数であるため <code>string(buf)</code> として文字列へ変換して渡しています．
なお，今回の例ではおそらく1024バイトもあれば足りるであろうと考えて読み込み処理について少し手を抜いていますが，本来はより長いリクエストにも対応できるよう工夫する必要があります．</p>
<h3 id="httpレスポンス"><a class="header" href="#httpレスポンス">HTTPレスポンス</a></h3>
<p>HTTPレスポンスは，Server-side アプリケーションから Client-side アプリケーションへ送信するレスポンスの形式を定めます．
ここまで来たらお気づきだと思いますが，配布したプログラムはHTTPレスポンスとして定められた形式に従った応答を返していないため，Webブラウザ上にて何も表示されない状態となっています．</p>
<p>HTTPレスポンスは以下の形式をとります．</p>
<pre><code class="language-txt">&lt;VERSION&gt; &lt;STATUS_CODE&gt; &lt;REASON_PHRASE&gt;
&lt;HTTP_HEADERS&gt;

&lt;BODY&gt;
</code></pre>
<p>1行目の <code>&lt;VERSION&gt; &lt;STATUS_CODE&gt; &lt;REASON_PHRASE&gt;</code> は <b>Status line</b> と呼ばれ，リクエストに対する処理の状態 (処理の成功・失敗など) を Client-side アプリケーションへ通知します．
<code>&lt;VERSION&gt;</code> はHTTPリクエストと同様に使用するプロトコルのバージョンを宣言します．
<code>&lt;STATUS_CODE&gt;</code> および <code>&lt;REASON_PHRASE&gt;</code> には，リクエスト処理の状態に応じて予め定義された数値と文字列のペアを書き込みます．
よく見かける例としては，<code>200 OK</code> や <code>404 Not Found</code> などが挙げられます．
HTTPリクエストの1行目と同様に，<code>&lt;VERSION&gt;</code>，<code>&lt;STATUS_CODE&gt;</code>，<code>&lt;REASON_PHRASE&gt;</code> はスペース区切りで識別され，<code>&lt;VERSION&gt;</code> はスペースを含まない文字列，<code>&lt;STATUS_CODE&gt;</code> は3桁の整数値で定義されます．
<code>&lt;REASON_PHRASE&gt;</code> については，末尾であり解釈時に曖昧性をもたないため，空白を含むことを許容した文字列とされています．
有効な <code>&lt;STATUS_CODE&gt;</code> と <code>&lt;REASON_PHRASE&gt;</code> の組合せについては，<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.1">RFC7231</a> に定義されています．</p>
<p><code>&lt;HTTP_HEADRS&gt;</code> および <code>&lt;BODY&gt;</code> については，HTTPリクエストと同様です．
また，HTTPリクエストと同様に <code>&lt;HTTP_HEADERS&gt;</code> と <code>&lt;BODY&gt;</code> の間の空行は必須です．
Webブラウザでは一般に <code>&lt;BODY&gt;</code> の部分が画面上に表示されます．</p>
<p>HTTPリクエストの形式がわかったところで，配布したプログラムを修正してWebブラウザ上に &quot;Hello world.&quot; を表示できるようにしてみましょう．
この項目は以下の通り練習問題とします．</p>
<h5 id="練習問題-2-2"><a class="header" href="#練習問題-2-2">練習問題 2-2</a></h5>
<p>配布したプロジェクト httpserver.go について，適切なHTTPレスポンスを返すようプログラムを修正し，Webブラウザ上に &quot;Hello world.&quot; の文字列を表示できるようにします．
なお，この練習問題は以下のヒントを参考に各自で解いてみましょう．</p>
<ul>
<li>HTTPレスポンスは <code>net.Conn.Write</code> メソッドを使用することで，バイト列として Client-side アプリケーションへ書き出すことができる．具体的には，配布プログラム中の <code>handleConnection</code> 関数内に記述された <code>conn.Write</code> のメソッド呼び出しを真似すると良い．</li>
<li>HTTPレスポンスの <code>&lt;HTTP_HEADERS&gt;</code> として <code>&lt;BODY&gt;</code> の長さを指定すること．このとき Go言語 において，<code>[]byte</code> 型の長さ (byte長) は Python と同様に組み込み関数 <code>len</code> によって取得できる．</li>
</ul>
<h2 id="アクセス先の制御-ルーティング"><a class="header" href="#アクセス先の制御-ルーティング">アクセス先の制御 (ルーティング)</a></h2>
<p>多くのWebアプリケーションは，HTTPリクエストの内容に応じて様々な処理を行います．
こうしたリクエストの内容に応じた処理の分岐を一般に <b>ルーティング (Routing)</b> と呼びます．</p>
<p>ルーティングはWebアプリケーションの使いやすさに影響を与えるのはもちろんとして，開発にも影響を及ぼします．
適切なルーティングが為されていない場合，アプリケーションが実行すべき処理の流れが追いづらく，使う側および作る側の双方にとって嬉しくない状態となってしまいます．</p>
<p>通常のルーティングでは，HTTPリクエストの持つアクセスメソッド <code>&lt;METHOD&gt;</code> とアクセスパス <code>&lt;PATH&gt;</code> の組合せに基づいて処理を分岐します．
すなわち，たとえば <code>/</code> に対する GETリクエスト と <code>/</code> に対する POSTリクエストとでは別の処理を実行するなど，同じパスでもメソッドの違いによって処理を変えることが可能です．</p>
<p>ルーティングについては，単純にHTTPリクエスト中の <code>&lt;METHOD&gt;</code> と <code>&lt;PATH&gt;</code> を確認し，<b>条件分岐</b>によって処理を変えているだけと考えることができます．
したがって，ここでは実際に以下の練習問題に取り組んでもらい，ルーティングの理解を深めるとともに Go言語 により一層慣れるための機会にしてもらえればと思います．</p>
<h5 id="練習問題-2-3"><a class="header" href="#練習問題-2-3">練習問題 2-3</a></h5>
<p>以下の仕様を満たすようルーティングを実装し，動作確認をしてください．
なお，現在までの内容ではWebブラウザから送信されるリクエストのメソッドは基本的に GET になってしまうため，ここではメソッドの違いによるルーティングは考慮しなくてよいものとします．</p>
<ul>
<li>Webブラウザから <code>localhost:8000/hello</code> にアクセスした場合，&quot;Hello world.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/bye</code> にアクセスした場合，&quot;Good bye.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/hello.jp</code> にアクセスした場合，日本語で &quot;こんにちは&quot; と表示される．</li>
<li>Webブラウザから上記以外のリソースにアクセスした場合，ページが見つからない旨を Client-side に通知する．</li>
</ul>
<p>なお，この練習問題も以下のヒントをもとに各自で解いてみましょう．</p>
<ul>
<li>文字列の分割は <code>strings</code> パッケージ内の <code>strings.Split</code> 関数にて行うことができる．この関数は，第1引数として文字列，第2引数として区切り文字を受け取り，文字列のスライスを返す．</li>
<li>アクセス先のパス (<code>/hello</code> など) は，HTTPリクエストの1行目に記述されている．</li>
<li>Go言語 での条件分岐には，<code>if</code> または <code>switch</code> を使用する．</li>
</ul>
<div class="memo">
今後演習を進めていくにあたり，標準ライブラリやサードパーティライブラリにどのような関数・構造体・メソッドが定義されているかを調べる必要が出てくるかと思います．
Go言語 では便利なことに，だいたいのパッケージを網羅したWebサイトが存在し，関数の定義や場合によってはサンプルコードなどを調べることができます．<br>
<a href="https://pkg.go.dev">Go言語パッケージドキュメントサイト</a>
</div>
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<p>今回はWebアプリケーションを支えるWeb通信の仕組みについて扱いました．
配布したプログラムは最低限の機能しか持たないため，これをベースとしてWebアプリケーションを構築するのはかなり難しいと感じたかもしれません．</p>
<p>次回は，Webアプリケーション開発をより簡単にする仕組みについて触れます．
また，Client-side アプリケーションから Server-side アプリケーションへ情報を送信する方法について扱い，より実用的なアプリケーションを開発できる体制を整えていきます．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-webアプリケーションフレームワーク"><a class="header" href="#03-webアプリケーションフレームワーク">03: Webアプリケーションフレームワーク</a></h1>
<p><a href="02_http_and_routing.html">前回</a>は，Webアプリケーションを支えるHTTP通信の仕組みや，アプリケーション開発時に使用するであろう基本的なルーティングの方法について扱いました．</p>
<p>今回は以下の内容を通して，開発効率の向上およびユーザとのインタラクションについて扱います．</p>
<ol>
<li>Web Applicaion Framework</li>
<li>Hypertext Markup Language (HTML)</li>
<li>formタグを用いたHTTP POST</li>
</ol>
<p>また今回から3回に分けて，新たなプロジェクトをベースとして演習を進めます．
以下のリンクより新しいプロジェクト formapp.go をダウンロードし，演習が進められるよう展開・配置してください．</p>
<p><a href="https://github.com/cs-sysdes/formapp.go">https://github.com/cs-sysdes/formapp.go</a></p>
<p>ダウンロード方法は <a href="01_preliminary.html">第1回資料</a> を参照してください．</p>
<h2 id="web-application-framework"><a class="header" href="#web-application-framework">Web Application Framework</a></h2>
<p>前回配布したプログラムは基礎的なHTTPサーバ機能しか持たず，ルーティングのために自分でHTTPリクエストを解析したり，適切なHTTPレスポンスを返すようヘッダ情報を追加したりといった処理を自分で実装する必要がありました．
今後，より複雑な機能を持った実用的なWebアプリケーションを開発していくにあたって，こうした処理を開発者自身が毎回行うのは面倒ですし，ミスが起こりやすく非効率的です．</p>
<p>こうしたWebアプリケーション開発において常に必要となる共通処理をまとめたライブラリや，必要に応じて開発を支援する仕組みなどを集めたものを，一般に <b>Web Application Framework (WAF)</b> あるいは単に Web Framework と呼びます．
多くのWAFは適切なHTTPレスポンスを簡単に返すことができる仕組みや，HTMLページの生成を補助する仕組みを持っており，Webアプリケーション開発において面倒な部分を肩代わりしてくれます．</p>
<p>現代のWebアプリケーション開発においてはなにかしらのWAFをベースに開発が行われている場合が多いです．
有名どころでは以下のようなWAFが対応する各プログラミング言語と組合せて実際に使われています．</p>
<div class="table-wrapper"><table><thead><tr><th>WAF</th><th>Language</th></tr></thead><tbody>
<tr><td>Drogon</td><td>C++</td></tr>
<tr><td>Spring</td><td>Java</td></tr>
<tr><td>Play</td><td>Java,Scala</td></tr>
<tr><td>Rails</td><td>Ruby</td></tr>
<tr><td>Laravel</td><td>PHP</td></tr>
<tr><td>Phoenix</td><td>Elixir</td></tr>
<tr><td>Django</td><td>Python</td></tr>
</tbody></table>
</div>
<p>一方で，Go言語 は Google によって開発がすすめられた比較的新しい言語である背景から，Web周りのサポートが他の言語と比べても非常に充実しています．
実際WAFに頼らなくても，標準パッケージ <code>net/http</code> だけでも十分にWebアプリケーションの開発が可能です．
Go言語に対応するWAFには <code>net/http</code> パッケージに薄い wrapper を追加する程度のものも多く，こういった点からも標準パッケージによるサポートの強さがわかります．</p>
<p>以下ではまず，標準パッケージ <code>net/http</code> を用いたHTTPサーバ実装の例を示します，
この例の中で <code>net/http</code> の便利さを理解してもらった上で，実は少し使いづらい部分なども紹介し，以降の演習にて扱う Go言語 向けのWAF: <a href="https://github.com/gin-gonic/gin">Gin</a> を導入します．</p>
<h3 id="標準パッケージ-nethttp"><a class="header" href="#標準パッケージ-nethttp">標準パッケージ <code>net/http</code></a></h3>
<p><code>net/http</code> パッケージを使用して，<a href="02_http_and_routing.html">前回資料</a> と同様に localhost:8000/ に GET リクエストが来た場合に &quot;Hello world.&quot; を表示するWebサーバを構築してみます．
具体的には，以下のようなコードになります．
これは説明の都合上示した例ですので，今回配布した formapp.go 内に以下を実装する必要はありません．</p>
<pre><code class="language-go">package main

import &quot;net/http&quot;

func main() {
    http.HandleFunc(&quot;/&quot;, rootHandler)
    http.ListenAndServe(&quot;:8000&quot;, nil)
}

func rootHandler(w http.ResponseWriter, r *http.Request) {
    if r.URL != &quot;/&quot; {
        w.WriteHeader(http.StatusNotFound)
        return
    }
    if r.Method != &quot;GET&quot; {
        w.WriteHeader(http.StatusMethodNotFound)
        return
    }
    w.Write([]byte(&quot;Hello world.&quot;))
}
</code></pre>
<div class="memo">
蛇足ですが，11 行目および 15 行目の条件分岐ですが，こうした場合はおそらく <code class="hljs go">switch</code> を使った方が楽でしょう．
</div>
<p>一見して <code>main</code> 関数がすっきりしたことがわかります．
前回配布したプログラムでは，通信を受けるソケットを用意したり，接続を待ち受けたりといった動作をすべて記述していましたが，今回の例ではそうした面倒な記述がすべて 7 行目の <code>http.ListenAndServe</code> 関数呼び出しにて済んでいます．</p>
<p>また，<code>net/http</code> パッケージはルーティングの機能を<b>パスと対応する処理のペア</b>を登録する形式で提供しています．
6 行目に示す <code>http.HandleFunc</code> 関数は引数としてパスと指定された形式のコールバック関数を受け取り，リクエストパスが &quot;/&quot; であるリクエストは <code>rootHandler</code> 関数に処理を任せるものとしてルーティング設定を登録します．</p>
<p>コールバック関数として登録される <code>rootHandler</code> 関数は，引数として <code>http.ResponseWriter</code> および <code>*http.Request</code> の 2 つの構造体をとります．</p>
<p>第1引数である <code>http.ResponseWriter</code> 型の変数 <code>w</code> は，HTTPレスポンスとしてヘッダ情報や BODY を書き込むための変数であり，12 行目や 16 行目のように<code>http.ResponseWriter.WriteHeader</code> メソッドによって BODY が空のヘッダ情報だけを返すことができたり，19 行目のように <code>http.ResponseWriter.Write</code> メソッドによって BODY を含めたレスポンスを返すことができます．
なお，<code>http.ResponseWriter.Write</code> 関数は，引数によって渡された BODY に喜寿されるべきバイト列から自動で <code>Content-Length</code> の値を計算し，HTTP header としてレスポンスに含めてくれます．</p>
<p>第2引数である <code>*http.Request</code> 型の変数 <code>r</code> は，HTTPリクエストを格納している変数であり，パスやメソッドなどの情報はすでにパースされて構造体のメンバとして保存されています．
前回のプログラムでは自分で <code>strings.Split</code> 関数などを用いてメソッドの種類やパスを取得する必要がありましたが，<code>http.Request</code> を介することで，<code>http.Request.Method</code> や <code>http.Request.URL</code> などによってメソッドやパスを直接参照することができるようになっています．</p>
<p>ここまでを見ると，<code>net/http</code> パッケージはこれだけでも十分に便利な気がしてきます．
一方で，11 行目の条件分岐について何か違和感がないでしょうか．
6 行目ですでに &quot;/&quot; に対するルーティングとしてパスを検査しているにもかかわらず，再びここでパスを検査しています．
一見すると無意味な条件分岐にも見えますが，実はきちんと意味のある条件分岐です．</p>
<p>6 行目 <code>http.HandleFunc</code> 関数の第1引数は，<strong>最長一致</strong> の原則を採用しています．
すなわち，6 行目の設定だけでは，&quot;/&quot; が引っかかるのはもちろんですが &quot;/hello&quot; や &quot;/bye&quot; でも先頭の &quot;/&quot; は一致しているので <code>rootHandler</code> 関数が呼び出されてしまいます．
ここでは，&quot;/&quot; だけに限定して &quot;Hello world.&quot; を返したいので，11 行目のように正確なパス検査を入れる必要があります．
また，メソッドによる分岐も 15 行目のように <code>http.Request.Method</code> を参照して設定する必要があります．</p>
<p>このように <code>net/http</code> パッケージは<a href="02_http_and_routing.html">前回</a>配布した httpserver.go よりは便利ですが，いろいろと足りない部分などがあります．
特に <code>net/http</code> パッケージの持つルーティング機能はやや遅い (計算コストが高い) ことが知られており，こうしたちょっとした面倒さやアプリケーションの応答速度などを気にする場合には，さらに別のWAFの使用が検討されます．</p>
<h3 id="gin-web-framework"><a class="header" href="#gin-web-framework">Gin Web Framework</a></h3>
<p><a href="https://github.com/gin-gonic/gin">Gin</a> は Go言語 によって記述された代表的WAFの1つです．
基礎的なHTTPサーバ機能として，標準パッケージ <code>net/http</code> に代えて <a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> を使用し，高速に動作するよう設計されています．</p>
<p>Gin を用いて先ほど示した localhost:8000/ へのGETリクエストに対して &quot;Hello world.&quot; を返すHTTPサーバを実装した例を以下に示します．
なお，この例は今回配布した formapp.go が持つ main.go ファイルを簡略化したものになっています．</p>
<pre><code class="language-go">package main

import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;  // ginパッケージをimport
)

func main() {
    engine := gin.Default()
    engine.GET(&quot;/&quot;, rootHandler)
    engine.Run(&quot;:8000&quot;, nil)
}

func rootHandler(ctx *gin.Context) {
    ctx.String(http.StatusOK, &quot;Hello world.&quot;)
}
</code></pre>
<p><code>main</code> 関数に注目すると，<code>net/http</code> パッケージを使用した場合とほとんど変わりません．
ただし 10 行目のように，Gin ではHTTPメソッドを指定したルーティングを記述することができます．
また <code>net/http</code> の場合とは異なり，パスとして &quot;/&quot; と指定した場合，これは基本的に &quot;/&quot; にしかマッチしません．
これにより，先ほどのように追加条件をコールバック関数側で記述する必要がなくなるため，&quot;/&quot; へのGETリクエストに対して呼び出されるコールバック関数 <code>handleRoot</code> (14--16行目) をかなり簡単に書くことができます．</p>
<p>コールバック関数の形式も先ほどとは異なり，引数として <code>*gin.Context</code> 型の変数のみをとる関数になります．
<code>gin.Context</code> は，HTTPリクエストとHTTPレスポンスを合わせたような構造体だと理解しておけば良いかと思います．
今回は文字列として &quot;Hello world.&quot; を返したいので，15行目のように <code>gin.Context.String</code> メソッドを用いてHTTPレスポンスの種類と内容を指定しています．
より具体的に書けば，Content-Type として String = text/plain を指定し，BODYとして &quot;Hello world.&quot; を持つHTTPレスポンスを生成します．
当然ながら，Content-Length は自動計算されます．</p>
<p>Gin はこのようにライブラリとして便利な機能を提供するだけではなく，Framework として開発を支援する機能をいくつか提供します．
代表的な機能の一つに Middleware の挿入という機能があり，以下のようにルーティングの前後にアプリケーション全体で共通する処理を挟むこむことができます．
この機能により，たとえばユーザ認証を必要とするアプリケーションではルーティング前に認証処理を挟むことによってルーティング後の特定の処理と全体での共通処理を分離でき，見通しの良いアプリケーションの設計が可能になります．
この演習中に middleware に触れるところまで進めるかはわかりませんが，こういうこともできるということだけ頭の片隅に置いておくとよいでしょう．</p>
<p><img src="img/middleware.png" alt="Middlewares on Gin framework" /></p>
<p>Go言語 で記述されたWAFとしては，他にも <a href="https://github.com/labstack/echo">Echo</a> などが有名ですが，本演習では Gin を扱うこととします．
Echo にも Gin と同様に middleware を扱う仕組みが存在し，全体的な使用感も Gin と大きく差があるわけではありません．</p>
<h5 id="練習問題-3-1"><a class="header" href="#練習問題-3-1">練習問題 3-1</a></h5>
<p>formapp.go/main.go を編集し，<a href="02_http_and_routing.html">前回資料</a>において示した 練習問題 2-3 の内容を，Gin を用いてプログラムしてみましょう．
具体的には，以下の要求を満たすよう formapp.go/main.go を編集してください．</p>
<ul>
<li>Webブラウザから <code>localhost:8000/hello</code> にアクセスした場合，&quot;Hello world.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/bye</code> にアクセスした場合，&quot;Good bye.&quot; が画面に表示される．</li>
<li>Webブラウザから <code>localhost:8000/hello.jp</code> にアクセスした場合，日本語で &quot;こんにちは&quot; と表示される．</li>
</ul>
<p>Gin を使用する場合，1つのルーティング (HTTPメソッドとパスの組) に対して対応する1つのコールバック関数を定義する必要があります．
必要に応じてコールバック関数を新たに定義し，ルーティングのルールを追加することで目的の処理を実装することができます．
関数名などは特に指定しませんが，わかりやすい名前を付けると良いでしょう．</p>
<h2 id="hypertext-markup-language-html"><a class="header" href="#hypertext-markup-language-html">Hypertext Markup Language (HTML)</a></h2>
<p>ここまでのプログラムは文字列を Client-side に返してきました．
したがって，Webブラウザ上に表示される結果も単なる文字列であり，なかなかに質素なものだったと思います．
一方で，たとえばこの演習資料のように，多くのWebページには見出しやリンク，パラグラフなどが存在しています．
ここでは，こうした構造化された文書を Client-side に返す方法について扱います．</p>
<p>Webサイトのように電子デバイス上での閲覧を想定した，複数のテキストを即時利用可能な形式でリンクした文書形式を一般に <b>Hypertext</b> と呼びます．
またこうした Hypertext を記述するための形式言語を <b>Hypertext Markup Language (HTML)</b> と呼び，Webページは通常このHTMLによって記述されます．</p>
<p>HTMLでは文書を原則として木構造で表現し，木構造を構成する節や葉は <b>タグ (tag)</b> によって文書構造中に配置されます．
例としてWebブラウザに &quot;Hello world.&quot; とだけ表示するHTMLを以下に示します．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        Hello world.
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>1 行目の <code>&lt;!DOCTYPE html&gt;</code> は<strong>文書型宣言</strong>と呼ばれ，これはタグではありません．
ここではこの文書がHTML，より具体的にはHTML5によって書かれていることを宣言しており，HTMLのバージョンによって書き方が少し異なります．
現在ではHTML5を使用するのが標準ですので，他のバージョンの書き方は特に覚えなくてもよいでしょう．</p>
<p>2 行目の <code>&lt;html&gt;</code> は，HTML要素と呼ばれる木構造における根の役割を持つ要素の宣言をするタグです．
この <code>&lt;html&gt;</code> タグは 6 行目の <code>&lt;/html&gt;</code> とペアになっており，一般に前者を「開始タグ」，後者を「閉じタグ」などと呼びます．
HTMLにおける節や葉の多くは開始タグと閉じタグのペアで構成され，タグが入れ子 (ネスト)  になっている場合は外側のタグが親，内側のタグが子となる親子関係を表します．
たとえば，3 行目に出現する <code>&lt;body&gt;</code> タグは <code>&lt;html&gt;</code> タグの子になります．
したがって，このHTMLは <code>&lt;html&gt;</code> 要素が根であり，唯一の葉として <code>&lt;body&gt;</code> 要素を持つ木構造であることがわかります．
注意点として，HTMLには一部単独で存在することのできるタグがあり，こうしたタグは基本的に子要素を持たないため，木構造における節になることがありません．</p>
<p><code>&lt;body&gt;</code> はBody要素と呼ばれ，Webブラウザが画面上に表示する文書パーツを表します．
このHTMLはBody要素内にプレーンテキストで &quot;Hello world.&quot; だけを持つので，Webブラウザ上に &quot;Hello world.&quot; と表示するだけのものとなります．
HTMLは基本的にインデントを無視するので，&quot;Hello world.&quot; の前に余計なスペースが入ることはありません (インデントを含めて見た目通り出力する方法もあります)．</p>
<p>多くの場合HTML文書にはBody要素のほかにHead要素と呼ばれるパーツが配置され，たとえば以下のような形式をしています．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;formapp.go&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello world.
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>&lt;head&gt;</code> タグによってHTML要素直下に配置されるHead要素は，通常そのままWebブラウザ上に表示されることはありません．
Head要素はそのページを構成するメタ情報などを記載する場所とされており，たとえば 4 行目の <code>&lt;title&gt;</code> タグはWebブラウザのタブ上などに表示するWebページのタイトルを設定するための記述です．
この他にも，ページ全体の文字コードの指定や関連する外部ファイルの取り込みに関する情報が記載されている場合が多いです．</p>
<p>試しにこの演習資料のHTMLソースコードを眺めてみると良いかもしれません．
Webブラウザによって方法が異なりますが，だいたいの場合ページ上で右クリックをすると出現するメニュー内に「このページのソースを表示」などの項目があると思います．
割と複雑なHTMLが表示されますが，当然すべて教員が心を込めて手入力した温もりあるHTMLというわけではありません．
一部実際に手動入力している部分もありますが，ほとんど自動生成です．</p>
<p>HTMLで使用できるタグには様々な種類があり，それぞれ特定の用途が定められています．
なかには文書中における役割を明示するタグなどもあり，こうしたタグを適切に使用することで文書に対して意味的な構造を与えることも可能です．
詳細は <a href="https://w3schools.com/html/default.asp">HTML | w3schools.com</a> などを参考に各自で学習を進めて下さい．</p>
<p>WebブラウザはこうしたHTML文書を解析し，画面上に描画する機能をもったアプリケーションです．
しかしながら，HTMLの機能だけでは人間に優しい表示を制御することは難しいので，JavaScript や CSS などを併用してより可読性が高く使いやすいWebページにできるよう開発者が努力しています．</p>
<h3 id="ginでhtmlを返す"><a class="header" href="#ginでhtmlを返す">GinでHTMLを返す</a></h3>
<p>それではこれまで無機質な文字列だけを返していたプログラムを編集し，HTMLを返してみます．
とりあえず，HTMLを文字列として直接プログラム中に埋め込めば目的は達成できそうです．</p>
<pre><code class="language-go">func rootHandler(ctx *gin.Context) {
    ctx.String(http.StatusOK, &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;...&quot;)
}
</code></pre>
<p>この方法には明らかな問題があります．
<code>gin.Context.String</code> メソッドは HTTP header に <code>Content-Type: text/plain</code> を設定してしまうため，WebブラウザによってはHTML文書ではなく単なるプレーンテキストとして認識されてしまい，正しく描画されないことがあります．
正しいレスポンスとして設定されるべきは <code>Content-Type: text/html</code> です．
また，HTMLを文字列として書くとシンタックスハイライトも効かないし書くの怠いですよね．
Content-Type を変更する方法はいくつか存在しますが，もっと良い方法があればそちらを使いたいです．</p>
<p>より良さそうな方法として，返したいHTML文書を別ファイルで用意し，そのファイルをプログラム中で読み込んでHTTPレスポンスとして返す方法を考えます．
formapp.go/templates の中に，すでにいくつかのサンプルHTML文書を配置していますので，これを使いましょう．
たとえば以下のような形式になると良さそうです．</p>
<pre><code class="language-go">// このコードは嘘のコードです
func rootHandler(ctx *gin.Context) {
    html := file.Read(&quot;templates/hello.html&quot;)
    ctx.String(http.StatusOK, html)
}
</code></pre>
<p>先ほどよりは筋がよさそうですが，Gin は Web Framework としてもっと良い方法を提供しています．
以下のコードでは <code>package main</code> などの共通部分を省略しています．</p>
<pre><code class="language-go">func main() {
    engine := gin.Default()
    engine.LoadHTMLGlob(&quot;templates/*.html&quot;)
    engine.GET(&quot;/&quot;, rootHandler)
    engine.Run(&quot;:8000&quot;, nil)
}

func rootHandler(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;hello.html&quot;, nil)
}
</code></pre>
<p>重要な変更点は 3 行目 <code>engine.LoadHTMLGlob(&quot;templates/*.html&quot;)</code> および 9 行目 <code>ctx.HTML(http.StatusOK, &quot;hello.html&quot;, nil)</code> の2点です．</p>
<p>9 行目のHTTPレスポンスを設定している部分から説明します．
先ほどまでのプログラムでは，<code>gin.Context.String</code> メソッドを使用して <code>Content-Type: text/plain</code> となる文字列データをHTTPレスポンスに設定していました．
一方今回は，<code>gin.Context.HTML</code> メソッドを使用することで，<code>Content-Type: text/html</code> となるHTML文書をレスポンスに設定しています．
<code>gin.Context.HTML</code> メソッドは，第1引数としてHTTPステータスコード，第2引数として返すHTML文書のファイル名を取ります．
第3引数は今回使用しないので <code>nil</code> を渡しています．
このメソッドは第1引数で渡されたHTTPステータスコードをともなって，第2引数で渡されたファイルに従って生成したHTML文書をHTTPレスポンスとして返します．
すなわち，先ほど紹介したファイルを読み込んで返すという動作ができているということになります．</p>
<p><code>gin.Context.HTML</code> ではファイル名を渡しましたが，このファイル名から当該ファイルを見つけるための設定が 3 行目の <code>engine.LoadHTMLGlob(&quot;templates/*.html&quot;)</code> になります．
この関数は templates ディレクトリ内のHTMLファイルをアプリケーションに登録し，ファイル名からの検索対象に含めるために呼び出しています．
すなわち，ここで登録したファイルであれば <code>gin.Context.HTML</code> メソッドからファイル名によって使用することができるということです．</p>
<p>この方法は Gin Web Framework 特有の方法ですが，他のFrameworkでも同様の方法が提供されていることが多いと思われます．</p>
<h5 id="練習問題-3-2"><a class="header" href="#練習問題-3-2">練習問題 3-2</a></h5>
<p>練習問題 3-1 の内容を，それぞれ対応するHTMLファイルを作成したうえで，<code>gin.Context.HTML</code> メソッドによってHTML文書を返す方法に書き変えてみましょう．</p>
<h2 id="formタグを用いたhttp-post"><a class="header" href="#formタグを用いたhttp-post">formタグを用いたHTTP POST</a></h2>
<p>Server-side から Client-side へHTML文書を送ることができるようになったので，今度は逆に Client-side から何かしらの入力情報を Server-side に送ってみます．
こうした情報送信にはHTMLタグの一つである <code>form</code> タグが使用できます．
<code>form</code> タグの使い方を見るため，プログラムに少し修正を加えます．</p>
<p><code>main</code> 関数内に以下のルーティングを登録してください．</p>
<pre><code class="language-go">engine.GET(&quot;/name-form&quot;, nameFormHandler)
engine.POST(&quot;/register-name&quot;, registerNameHandler)
</code></pre>
<p>また，以下の関数をファイル内に定義してください．</p>
<pre><code class="language-go">func nameFormHandler(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;name_form.html&quot;, nil)
}

func registerNameHandler(ctx *gin.Context) {
    body, _ := ctx.GetRawData()
    ctx.String(http.StatusOK, string(body))
}
</code></pre>
<p>Webブラウザから localhost:8000/name-form にアクセスすると，以下のような入力画面が表示されるはずです．
入力欄に適当な名前を入力後，送信ボタンを押してどうなるか観察してみましょう．
このとき，入力として英数字のみを入れた場合と，漢字やひらがな，スペース (空白文字) などを含めた場合とで結果に違いが出るか確認してください．</p>
<p>例として，入力欄に「東工大」といれて送信した場合，次の画面に以下のような表示が出ると思います．</p>
<pre><code>name=%E6%9D%B1%E5%B7%A5%E5%A4%A7
</code></pre>
<p>これについて次の節で説明します．</p>
<h3 id="content-type-applicationx-www-form-urlencoded"><a class="header" href="#content-type-applicationx-www-form-urlencoded">Content-Type: application/x-www-form-urlencoded</a></h3>
<p><code>form</code>タグから送られたデータは，基本的に <code>key=value&amp;key2=value2&amp;...</code> という形式でサーバへ送信されます．
今回の例では，<code>form</code> タグから <code>name</code> という key で入力値を送っているため，<code>name=&lt;入力値&gt;</code> という形でサーバへ情報が送られてきます．</p>
<p>このとき，HTTPではURLなどの文字列において，たとえばスペースや「@」などの通常使用できない文字が存在します．
こうした文字は通信可能な形式に変換 (encode) された上で送信されるため，正しく解釈するには受信側で逆変換 (decode) してやる必要があります．
日本語のようなマルチバイト文字は基本的に<code>%..</code>のような形式に変換されるため，「東工大」と入力したものをそのまま表示しようとすると怪しい文字列になるわけです．</p>
<p>逆変換のためには，たとえば Java では <code>java.net.URLDecoder</code> というクラスなどが用意されていますが，Go言語ではより扱いを簡単にするために，<code>gin.Context</code> のメソッドとして指定した key に対応する value を自動的に逆変換して返す <code>GetPostForm</code> メソッドが存在します．
したがって，<code>registerNameHandler</code> 関数を以下のように書き変えると適切な表示に変換されるはずです．</p>
<pre><code class="language-go">func registerNameHandler(ctx *gin.Context) {
    name, _ := ctx.GetPostForm(&quot;name&quot;)
    ctx.String(http.StatusOK, name)
}
</code></pre>
<p>このメソッドが存在することによって，<code>key1=value1&amp;key2=value2&amp;key3=value3</code> などのような情報が送られてきた場合でも，&quot;&amp;&quot; で分割して decode して...などとしなくても簡単に目的の値を取り出すことができます．
なお，<code>gin.Context.GetPostForm</code> メソッドは，指定した key が存在しない場合に第2戻り値として <code>false</code> を返すため，これを使用して key の存在判定を行うことができます．</p>
<h3 id="htmlへの値の埋め込み"><a class="header" href="#htmlへの値の埋め込み">HTMLへの値の埋め込み</a></h3>
<p><code>registerNameHandler</code> は送られてきた入力値を文字列で返しているだけなので，これをHTMLで返すように変更しましょう．
Go言語のHTMLテンプレート機能には，HTMLファイル中に変数の値などを埋め込む機能があるため，これを使用してHTML文書中に送信されてきた名前情報を入れてみます．</p>
<p>templates/result.html は以下のようなHTML文書 (のテンプレート) になっています．</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Result | formapp.go&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;入力結果&lt;/h1&gt;
        &lt;dl&gt;
            &lt;dt&gt;名前&lt;/dt&gt;
            &lt;dd&gt;{{ .Name }}&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>詳しい構造の説明は省略しますが，10 行目に見慣れない表現 <code>{{ .Name }}</code> があります．
これはHTML文書中に変数の値を埋め込むための構文です．
このHTMLテンプレートを使用して，入力結果をHTMLで返す <code>registerNameHandler</code> 関数の例を以下に示します．</p>
<pre><code class="language-go">func registerNameHandler(ctx *gin.Context) {
    name, _ := ctx.GetPostForm(&quot;name&quot;)
    ctx.HTML(http.StatusOK, &quot;result.html&quot;, gin.H{&quot;Name&quot;: name})
}
</code></pre>
<p>基本的には &quot;Hello world.&quot; を表示したときの例と同じですが，<code>gin.Context.HTML</code> の第3引数として <code>nil</code> ではなく <code>gin.H{&quot;Name&quot;: name}</code> を渡しています．
<code>gin.H</code> 関数は単純な連想配列 (HashMap) を提供する関数で，ここでは &quot;Name&quot; という key に変数 <code>name</code> の値を紐づけています．
key と指定される &quot;Name&quot; は templates/result.html 中の <code>{{ .Name }}</code> と同じである必要があります．
すなわち，<code>{{ .Name }}</code> は渡された連想配列から key として &quot;Name&quot; に対応する値を受け取り，その場に展開するコードとして働きます．</p>
<p>簡単ですが，これで Client-side から Server-side への情報送信およびHTMLの整形方法を扱ったことになります．</p>
<h5 id="練習問題-3-3"><a class="header" href="#練習問題-3-3">練習問題 3-3</a></h5>
<p><code>&lt;form&gt;</code> タグでは <code>action</code> 属性で送信先，<code>method</code> 属性でHTTPリクエストメソッドの種類を指定できます．
では，いま <code>action=&quot;POST&quot;</code> となっている場所を <code>action=&quot;GET&quot;</code> とした場合，どういった変化が起こるか，確認してみてください．</p>
<h2 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h2>
<p>今回はより実践的なWebアプリケーション開発のためのフレームワークについて扱いました．
また，HTMLを返すことでWebページとして表示できるようにし，同時に Client-side から Server-side へ情報を送信する方法を扱いました．</p>
<p>次回から2回に分けて，通信ごとに情報を記憶しておく方法を扱います．
HTTP通信は基本的に記憶を持たないため，前回の通信時にどういった状態であったかという情報を次の通信時まで保持するためには工夫が必要です．
この工夫として2種類の方法を2回に分けて扱います．</p>
<p>次回以降も formapp.go を使用しますので，削除しないよう気を付けてください．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-http通信における状態管理-1"><a class="header" href="#04-http通信における状態管理-1">04: HTTP通信における状態管理 (1)</a></h1>
<p><a href="03_web_application_framework.html">前回</a>は，より効率的にWebアプリケーション開発を進める仕組みとしてWeb Application Frame について扱いました．
基礎編最後の2回は，実践的なWebアプリケーション開発のために必要な状態管理について扱います．</p>
<p>内容に入る前に，今回開発するアプリケーション formapp.go の仕様を以下のリンクより確認してください．</p>
<p>仕様書：<a href="https://cs-sysdes.github.io/formapp.html">https://cs-sysdes.github.io/formapp.html</a></p>
<p>仕様書に示す通り，formapp.go は 5 つの画面からなるアプリケーションです．
本来であれば 1 画面でまとめてすべての情報を入力できる程度のものですが，練習のため個別の入力画面としています．
示された仕様から，formapp.go は <strong>5.確認画面</strong> において <strong>1～4 の画面において入力した情報を参照</strong>する必要があることがわかります．</p>
<p><strong>04: 状態管理 (1)</strong> および <strong>05: 状態管理 (2)</strong> では，この挙動を実現する上で解決しなければいけない状態管理に関する課題を説明し，その解決方法を実装します．
なお，ここで<strong>状態</strong>とはユーザのログイン状態やリクエストに関する一時的な記憶など，比較的短時間で変化し得るものを仮定しています．</p>
<p>今回は特に以下の内容を通して状態管理に関する課題を理解し，1 つ目の解決方法を実装していきます．</p>
<ol>
<li>事前準備: パッケージ分割</li>
<li>HTTP通信のステートレス性</li>
<li>状態管理手法 (1): ステートレス方式</li>
</ol>
<p>引き続き formapp.go をベースプロジェクトとして使用します．
前回の練習問題などにおいてすでに修正を加えているかと思いますが，初期状態に戻す必要はありません．
複数機能の開発を行うため，まずは Go言語 におけるパッケージ分割 (ソースコード分割) の方法について説明し，状態管理のための準備を整えます．</p>
<p>これ以降，提示するコードに関して以下に注意してください．</p>
<ul>
<li>package 宣言を省略するなど，ソースコードの一部を抜粋している場合があります．</li>
<li>表記中の <code>...</code> はコードの省略を意味します．</li>
<li>提示したコードの n 行目などと指定した場合は，本資料上での行数を意味しています．
多くの場合，実際のソースコード上での行数と一致するものではありません．</li>
</ul>
<h2 id="事前準備-パッケージ分割"><a class="header" href="#事前準備-パッケージ分割">事前準備: パッケージ分割</a></h2>
<p>これから複数の機能を実装していくにあたり，すべてを formapp.go/main.go の中に記述していると，プログラム全体の見通しが悪くなりミスを発見しづらくなるなど，あまり良いことはありません．
C言語 や Java，その他の言語を用いる場合においても，ある程度の規模になるとソースコードを機能や役割ごとに分割し，プログラムの構造を整理する必要が生じます．
ここでは Go言語 においてソースコード分割 (パッケージ分割) の方法を簡単に説明し，以降の演習に備えます．</p>
<p>いま formapp.go/main.go が以下の状態であると仮定して話を進めます．
各自で修正した部分がある場合でも，元に戻す必要はありません．
現在の手元のソースコードの状態と読み換えて資料を進めてください．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.GET(&quot;/&quot;, rootHandler)
    ...
}

func rootHandler(ctx *gin.Context) {
    ...
}
</code></pre>
<p>ここでは <code>rootHandler</code> 関数を <code>service</code> パッケージに分割することにします．
前回の練習課題などで他にも定義した関数があれば，それらもついでに移動しましょう．</p>
<h3 id="service-パッケージへの関数定義の移動"><a class="header" href="#service-パッケージへの関数定義の移動">service パッケージへの関数定義の移動</a></h3>
<p>ディレクトリ名がパッケージ名となるので，まず formapp.go/service というディレクトリを作成します．
また，作成したディレクトリ下に適当な名前を付けたGo言語ソースファイルを配置します．
ここでは formapp.go/service/handler.go とでもしておきましょう．
ファイル名は基本的にパッケージの import などに影響を与えないため，わかりやすい名前であれば特に制限はありません．</p>
<p>作成したソースファイルにプログラムを書き込みます．</p>
<p><span class="filename">formapp.go/service/handler.go</span></p>
<pre><code class="language-go">package service

import (
    &quot;github.com/gin-gonic/gin&quot;
)

func RootHandler(ctx *gin.Context) {
    ...
}
</code></pre>
<p>1行目のパッケージ宣言は，このファイルが属するパッケージ名として <code>service</code> を宣言しています．
パッケージ宣言は直上のディレクトリ名のみを宣言し，Java のようにすべてのパッケージ階層を宣言する必要はありません．</p>
<p>コールバック関数作成時に Gin によって提供される構造体 <code>gin.Context</code> を使用するため，Gin のパッケージを import します．
他にも関数内で使用するパッケージがある場合には，ここで明示的に import する必要があります．
たとえば標準パッケージ <code>fmt</code> を使用する場合，たとえ main.go 内で <code>fmt</code> を import していても，こちらのファイルには適用されないので，ここで再度 import する必要があります．</p>
<p>7行目において関数 <code>RootHandler</code> を定義しています．
<a href="01_preliminary.html">第1回</a>でも触れたように，Go言語では<strong>識別子の先頭が大文字の場合のみ他のパッケージから可視</strong>であるため，<code>rootHandler</code> ではなく <code>RootHandler</code> とする必要があります．</p>
<p>さて，関数定義を新たなパッケージ <code>service</code> へ移動したので，main.go の方も手直しが必要です．</p>
<h3 id="service-パッケージの利用"><a class="header" href="#service-パッケージの利用">service パッケージの利用</a></h3>
<p><code>main</code> パッケージから <code>service</code> パッケージを利用するには，これを import する必要があります．
また，ルーティング時に指定するコールバック関数も，<code>service</code> パッケージにより提供されるものに変更しなくてはいけません．</p>
<p>修正後の formapp.go/main.go を以下に示します．
主な変更点は 8 行目と 13 行目です．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
    &quot;formapp.go/service&quot;
)

func main() {
    ...
    engine.GET(&quot;/&quot;, service.RootHandler)
    ...
}

// rootHandler関数の定義はserviceパッケージへ移動済み
</code></pre>
<p>8行目において先ほど作成した <code>service</code> パッケージを import し，使用可能にしています．
Go言語では，C言語のように <code>import &quot;./service&quot;</code> などとして import することができません．
標準パッケージ以外のパッケージを使用する場合，必ず<strong>モジュール名から使用するパッケージ名までのパスを記述</strong>する必要があります．
今回の場合モジュール名は <code>formapp.go</code> ですので，import 文には &quot;formapp.go/service&quot; を指定しています．
なお，モジュール名は formapp.go/go.mod の1行目に <code>mod formapp.go</code> として宣言しています．</p>
<p>13行目において &quot;/&quot; への GET アクセスに対し <code>service.RootHandler</code> を呼び出すルーティング設定をしています．
<code>RootHandler</code> 関数は <code>service</code> パッケージ内の関数なので，このように指定する必要があります．</p>
<div class="memo">
github.com/gin-gonic/gin はモジュール名ですが，パッケージ名は gin です．
github.com/gin-gonic の部分は GitHub 上でのユーザディレクトリのようなものなので，実質的にモジュールのルートディレクトリは gin になります．
Go言語ではこのようにモジュールルートもパッケージになります．
一方で，パッケージ名として '.' (ドット) は使用できない文字なので，本演習のようにルートディレクトリとして formapp.go などと名前を付けてしまうと，そのままパッケージ名として採用できなくなります．
</div>
<p>パッケージ分割の方法がわかったところで，今回のメイントピックである状態管理について見ていきます．</p>
<h2 id="http通信のステートレス性"><a class="header" href="#http通信のステートレス性">HTTP通信のステートレス性</a></h2>
<p>WebアプリケーションはHTTP通信によって Client-side と Server-side が情報をやり取りし，目的のタスクを実行するアプリケーションです．
したがって，WebアプリケーションはHTTP通信の持つ制限や制約に縛られます．
HTTP通信が持つ制約の中でも，Webアプリケーション開発において大きな課題となるのが，<strong>ステートレス性</strong>という性質です．</p>
<p>HTTP通信のステートレス性とは，簡単に言えば<strong>個々の通信でやりとりした情報や状態は何もしなければ次の通信に引き継がれない</strong>という性質です．</p>
<p><img src="img/http_stateless_communication.png" alt="Stateless communication on HTTP" /></p>
<p>いま作成したい formapp.go の仕様で考えると，この性質によって「1. 名前入力画面」で入力された情報は<strong>アプリケーションが何もしなければ</strong>次の「2. 生年月日入力画面」へは引き継がれず，最終的に「5. 確認画面」で表示することもできません．
すなわち，HTTP通信自体はこうした情報を自動で保持する仕組みはなく，<strong>アプリケーションの責任</strong>において保持しなければいけないということになります．</p>
<p>Webアプリケーションにおける状態管理とは，1つのリクエストと1つのレスポンスの対からなる通信について，<strong>複数の通信間で状態 (情報) を引き継ぐ</strong>ことを意味します．
複数の通信間で状態を引き継ぐためには，<strong>どこかに引き継ぎたい状態を保存</strong>しておき，<strong>通信のたびに保存していた状態を確認</strong>することができれば良いでしょう．</p>
<p>このとき，どこに状態を保存するかによって大きく2つの方式を考えることができます．
これらの方式を，本演習では「<strong>ステートレス方式</strong>」および「<strong>セッション方式</strong>」と呼ぶこととします．</p>
<p>両方式の違いを以下に簡単にまとめます．</p>
<div class="table-wrapper">
<table style="width: 100%">
    <thead>
        <tr>
            <th style="width: 40%">ステートレス方式</th>
            <th style="width: 20%"></th>
            <th style="width: 40%">セッション方式</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="width: 40%">通信上に載せる</td>
            <td style="width: 20%; text-align: center">状態の保存</td>
            <td style="width: 40%">Server-side アプリケーションが記憶</td>
        </tr>
        <tr>
            <td style="width: 40%">Server が状態を記憶する必要がなく，通信相手を区別する仕組みも不要</td>
            <td style="width: 20%; text-align: center">利点</td>
            <td style="width: 40%">通信量が扱う状態のデータサイズに依存しにくい</td>
        </tr>
        <tr>
            <td style="width: 40%">扱う状態のデータサイズに依存して通信料が増える</td>
            <td style="width: 20%; text-align: center">欠点</td>
            <td style="width: 40%">複数 Client からの並行アクセスに対し通信相手を弁別する仕組みが必要</td>
        </tr>
    </tbody>
</table>
</div>
<div class="memo">
「ステートレス方式」および「セッション方式」という名称は便宜上のものであり，一般的な呼称ではないことに注意．
</div>
<p>今回は特に「ステートレス方式」について実装を進め，次回「セッション方式」を扱います．</p>
<h2 id="状態管理手法-1-ステートレス方式"><a class="header" href="#状態管理手法-1-ステートレス方式">状態管理手法 (1): ステートレス方式</a></h2>
<p>ステートレス方式は，Server-side アプリケーションが状態を持たない (= ステートレス) ことから，このような名称を便宜上与えています．
Server-side アプリケーションが情報を持たない代わりに，ステートレス方式では毎回の通信にこれまでのすべての状態を載せることで，複数の通信間での状態の引き継ぎを実現しています．</p>
<p>formapp.go におけるステートレス方式を図示すると以下のようになります．</p>
<p><img src="img/formapp_stateless.png" alt="Stateless communication in formapp.go" /></p>
<p>図中に示すように，各通信に前の通信で得た情報を毎回しつこく載せ続けることによって，Server-side が記憶を持っていなくとも，<strong>通信の内容を見ればすべての状態を把握可能</strong>な仕組みを作ることができます．</p>
<p>それでは実際にステートレス方式で formapp.go を実装してみましょう．</p>
<h3 id="仮ルーティングの設定"><a class="header" href="#仮ルーティングの設定">仮ルーティングの設定</a></h3>
<p>はじめに formapp.go/main.go 内にルーティングのみ先に定義してしまいましょう．
formapp.go の仕様において最低限必要なルーティング設定は以下の 5 つです．</p>
<ul>
<li>スタート画面を表示 (GET) するルート</li>
<li>スタート画面からのPOSTを受け取るルート</li>
<li>名前入力画面からのPOSTと受け取るルート</li>
<li>生年月日入力画面からのPOSTを受け取るルート</li>
<li>メッセージ入力画面からのPOSTを受け取るルート</li>
</ul>
<p>ここで，名前入力画面，生年月日入力画面，メッセージ入力画面，確認画面を表示するルートは不要である点に注意してください．
これらの画面は，前の画面からのPOSTリクエストに対するレスポンスとして返すことができるため，別途GETメソッドによるアクセスを考える必要がありません．
また，確認画面からスタート画面に戻る際は，form タグでスタート画面への GET メソッドを送信するか，単にリンクとすることで対応可能です．</p>
<p>これらのルーティングを先に設定してしまいましょう．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.GET(&quot;/stateless/start&quot;, notImplemented)
    engine.POST(&quot;/stateless/start&quot;, notImplemented)
    engine.POST(&quot;/stateless/name&quot;, notImplemented)
    engine.POST(&quot;/stateless/birthday&quot;, notImplemented)
    engine.POST(&quot;/stateless/message&quot;, notImplemented)
    ...
}

func notImplemented(ctx *gin.Context) {
    msg := fmt.Sprintf(&quot;%s to %s is not implemented yet&quot;, ctx.Request.Method, ctx.Request.URL)
    ctx.String(http.StatusNotImplemented, msg)
}
</code></pre>
<p>ルーティングを設定する際，10行目のような未実装であることを通知するだけの関数などを仮配置しておくと便利です．</p>
<h3 id="スタート画面"><a class="header" href="#スタート画面">スタート画面</a></h3>
<p>仕様書に従って 1. スタート画面 を作成します．
この画面はステートレス方式とセッション方式でほとんど共通ですので，templates/start.html などとして以下のボタンを設置したページを配置します．
なお，<code>&lt;body&gt;</code> タグなどは省略していますので，各自で適宜記述してください．</p>
<p><span class="filename">formapp.go/templates/start.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;{{ .Target }}&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;アンケート開始&lt;/label&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;start&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p>ここで，1行目において <code>action=&quot;{{ .Target }}&quot;</code> としてPOST先を変更できるようにしています．
こうすることで，ステートレス方式でもセッション方式でも，このテンプレートを使い回せるようにしています．</p>
<p>次にスタート画面へのGETアクセスを受ける関数を作成します．</p>
<p>ここからステートレス方式の実装を進めるにあたり，次回セッション方式を実装する際と関数名の衝突が発生しないよう新しいパッケージを作成しておきます．
ここでは先ほど作成した formapp.go/service ディレクトリの下に stateless ディレクトリを作成し，<code>stateless</code> パッケージとして機能を実装していくこととします．</p>
<p>Go言語 のソースファイルとして先ほど作成した stateless ディレクトリに適当な名前のファイルを作成します．
ここでは formapp.go/service/stateless/handler.go としておきましょう．</p>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">package stateless

import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

func Start(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;start.html&quot;, gin.H{ &quot;Target&quot;: &quot;/stateless/start&quot; })
}
</code></pre>
<p>ここではスタート画面における POST 先を /stateless/start としています．</p>
<p>formapp.go/main.go を修正し，スタート画面への GET リクエストを飛ばせるようにしてみましょう．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">import (
    ...
    &quot;formapp.go/service/stateless&quot;  // statelessパッケージを使用
)
func main() {
    ...
    engine.GET(&quot;/stateless/start&quot;, stateless.Start)
    engine.POST(&quot;/stateless/start&quot;, notImplemented)
    ...
}
</code></pre>
<p>3 行目の記述によって，<code>stateless</code> パッケージを呼び出せるようにしています．
<code>stateless</code> パッケージ内の関数などを使用する場合は，Javaのように <code>service.stateless.Start</code> とするのではなく，単に <code>stateless.Start</code> で呼び出すことができます (7行目参照)．
このルールでは別々のモジュールで定義された同じパッケージ名で衝突が容易に発生するように思いますが，Go言語では import 時にパッケージに別名をつけることができるため，それほど問題にはなりません．</p>
<p>アプリケーションを起動し，Web ブラウザから http://localhost:8000/stateless/start へアクセスしてみましょう．
スタート画面が表示されれば成功です．</p>
<h3 id="名前入力画面"><a class="header" href="#名前入力画面">名前入力画面</a></h3>
<p>ここではまだ前のページから引き継ぐべき状態がありません．
したがって，スタート画面と同様にセッション方式でも使用できるよう名前入力画面を作成します．</p>
<p><span class="filename">formapp.go/templates/name-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;{{ .Target }}&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;名前: &lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/input&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;next&quot;&gt;&lt;input&gt;
&lt;/form&gt;
</code></pre>
<p>関数を追加します．
少しわかりづらいですが，ここはスタート画面からの POST を受け取って名前入力画面を返す部分なので，まだ特に情報は送られてきません．
<code>Target</code> の設定に注意してください．</p>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">...

func NameForm(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;name-form.html&quot;, gin.H{ &quot;Target&quot;: &quot;/stateless/name&quot; })
}
</code></pre>
<p>ルーティングも更新します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/stateless/start&quot;, stateless.NameForm)
    ...
}
</code></pre>
<p>ここでも一度，動作確認をしてみましょう．</p>
<h3 id="生年月日入力画面"><a class="header" href="#生年月日入力画面">生年月日入力画面</a></h3>
<p>ここからは前の画面で入力した情報を状態として引き継いでいく必要があります．</p>
<p>まずはこれまで通り素直に生年月日入力画面を作ってみましょう．
ただし，ここからはセッション方式とやや記述内容が異なってくるため，区別できるようなファイル名としておきます．</p>
<p><span class="filename">templates/stateless-birthday-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;/stateless/birthday&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;生年月日: &lt;/label&gt;
    &lt;input type=&quot;date&quot; name=&quot;birthday&quot; value=&quot;2011-10-22&quot;&gt;&lt;/input&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p><code>input[type=date]</code> は日付を扱うための input タグです．
また，一般に input タグは <code>value=&quot;...&quot;</code> とすることで初期値を設定でき，<code>input[type=date]</code> の場合は <code>&quot;2011-10-22&quot;</code> と記述しておくと 2022年10月22日 が初期値として設定されます．</p>
<p>さて，ステートレス方式では通信に状態を載せるのですが，このままでは名前情報を載せておく場所がありません．
状態を引き継ぐためには状態を載せる場所を確保する必要があるため，その場所を <code>input[type=hidden]</code> タグによってつくります．
上記のテンプレートファイルを以下のように修正します．</p>
<p><span class="filename">templates/stateless-birthday-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;/stateless/birthday&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;生年月日: &lt;/label&gt;
    &lt;input type=&quot;date&quot; name=&quot;birthday&quot; value=&quot;2011-10-22&quot;&gt;&lt;/input&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;{{ .Name }}&quot;&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p>変更点は 4 行目です．
この記述により，生年月日入力画面に名前情報を埋め込むことができました．
<code>input[type=hidden]</code> は，HTML における通常の input タグのように情報を送信することができますが，Webブラウザ上には表示されません．
したがって，このように通信に情報を載せるための手段として活用することができます．</p>
<p>名前入力を受け取り，生年月日入力フォームを返す関数を formapp.go/service/stateless/handler.go へ追加します．
この関数は /stateless/name への POST を受け取って生年月日入力画面を返す関数なので，以下の 2 つのタスクを実行します．</p>
<ol>
<li>リクエストから名前情報を抜き出す</li>
<li>名前情報を埋め込んだ生年月日入力画面を返す</li>
</ol>
<p><span class="filename">formapp.go/service/stateless/handler.go</span></p>
<pre><code class="language-go">...

func BirthdayForm(ctx *gin.Context) {
    name, exist := ctx.GetPostForm(&quot;name&quot;)
    if !exist {
        ctx.String(http.StatusBadRequest, &quot;parameter 'name' is not provided&quot;)
        return
    }
    ctx.HTML(http.StatusOK, &quot;stateless-birthday-form.html&quot;, gin.H{ &quot;Name&quot;: name })
}
</code></pre>
<p>念のためエラー処理 (5--8行目) を挟んでいますが，本質的には POST されたデータから名前情報を抜き取り，templates/stateless-birthday-form.html に埋め込んで Client へ返すという動作を実行するものです．</p>
<p>ルーティングを更新します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/stateless/name&quot;, stateless.BirthdayForm)
    ...
}
</code></pre>
<p>ここまでの動作確認を行いましょう．
前述の通り <code>input[type=hidden]</code> は通常 Webブラウザ 上では表示されません．
たしかに名前情報が状態として埋め込まれていることを確認するには，HTMLソースを確認する必要があります．
多くの Webブラウザ では，右クリックで出現するメニューから「ページのソースを表示」などの項目を選択することで，HTMLソースを確認することができます．</p>
<p>基本的にはこれを繰り返すだけですので，ステートレス方式での残りのページの実装は練習問題とします．
注意点として，生年月日入力画面では名前情報のみを引き継ぎましたが，メッセージ入力画面では当然ながら名前情報と生年月日情報の2つを引き継がなければなりません．
すなわち，メッセージ入力画面では <code>input[type=hidden]</code> フィールドが2つ存在することとなります．</p>
<p>このようにステートレス方式は，扱う情報が増えると情報を引き継ぐためのフィールドが増加し，結果として通信量が増える性質を持っています．
小さなデータを少しだけ引き継ぐ場合には問題にはなりませんが，大きなデータや大量のデータを引き継ぐには不向きだと言えます．</p>
<h5 id="練習問題-4-1"><a class="header" href="#練習問題-4-1">練習問題 4-1</a></h5>
<p>ここまでの内容をもとに，<a href="https://cs-sysdes.github.io/formapp.html">formapp.goの仕様</a>を満たすアプリケーションを開発してみましょう．
なお，複数行の文字列入力欄は <code>&lt;textarea&gt;</code> タグを使うことで実現できます．</p>
<h5 id="練習問題-4-2"><a class="header" href="#練習問題-4-2">練習問題 4-2</a></h5>
<p>追加機能として，各画面に一つ前の画面に戻る「back」ボタンを実装し，前画面での入力を修正できるようにしてみましょう．</p>
<h2 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h2>
<p>今回はWebアプリケーションにおける状態管理について，HTTP通信の制約からくる課題とその解決方法の一つとして「ステートレス方式」を扱いました．
次回は，もう一つの方法である「セッション方式」について扱います．</p>
<p>今回の内容は以上になります．
おつかれさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-http通信における状態管理-2"><a class="header" href="#05-http通信における状態管理-2">05: HTTP通信における状態管理 (2)</a></h1>
<p><a href="04_state_management_v1.html">前回</a>に引き続いてHTTP通信における状態管理の方法を扱います．</p>
<p>前回扱った<a href="04_state_management_v1.html#%E7%8A%B6%E6%85%8B%E7%AE%A1%E7%90%86%E6%89%8B%E6%B3%95-1-%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%83%AC%E3%82%B9%E6%96%B9%E5%BC%8F">ステートレス方式</a>では，毎回の通信にすべての情報を載せることで，Server-sideアプリケーションに状態を記憶する機能を追加せずに，複数の通信間で状態を管理することができました．
一方で，通信にまたがって管理すべき状態の大きさに依存して通信量が増加するという欠点があり，これはアプリケーションの応答時間を増加させるなどユーザにとって好ましくない動作の原因にもなり得ます．</p>
<p>今回扱うセッション方式では，Server-side アプリケーションが状態を記憶することを許容します．
Server-side アプリケーションは当然ながら複数の Client-side アプリケーション (ユーザ) からのアクセスを同時に受けるため，自身の記憶している状態がどのアクセスに対応した状態であるのかを区別する必要があります．
そのための仕組みの理解と実装が今回の演習内容になります．</p>
<p>今回の流れは以下の通りです．</p>
<ol>
<li><a href="05_state_management_v2.html#%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86">セッション管理</a></li>
<li><a href="05_state_management_v2.html#%E7%8A%B6%E6%85%8B%E7%AE%A1%E7%90%86%E6%89%8B%E6%B3%95-2-%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E6%96%B9%E5%BC%8F">状態管理手法 (2): セッション方式</a></li>
</ol>
<p>引き続き formapp.go を演習素材として使用します．
前回実装したステートレス方式とは別にセッション方式を実装しますので，プロジェクトを初期化する必要はありません．</p>
<h2 id="セッション管理"><a class="header" href="#セッション管理">セッション管理</a></h2>
<p><a href="02_http_and_routing.html#web%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E5%8B%95%E4%BD%9C">第2回資料</a>より，HTTP通信を用いたWebアプリケーションは以下の流れで処理を進めます．</p>
<ol>
<li>Client-side アプリケーションが Server-side アプリケーションとの (TCP) 接続を確立する．</li>
<li>Client-side アプリケーションから Server-side アプリケーションへ<strong>リクエスト</strong>を送信する．</li>
<li>Server-side アプリケーションはリクエストを処理し，Client-side アプリケーションへ<strong>レスポンス</strong>を送信する．</li>
</ol>
<p>この一連の Client-Server 間の通信の流れを一般に<strong>HTTPセッション</strong>と呼び，HTTPのステートレス性とはHTTPセッションの独立性を意味しています．
アプリケーションが何もしなければ，複数の相異なるユーザからのアクセスは当然独立した相異なるセッションとしてみなされますが，同一ユーザからの複数のアクセスもすべて独立した相異なるセッションとなるわけです．</p>
<p>Server-side アプリケーション上で状態を管理する場合，それぞれの状態がどのセッションに結びついたものであるのかを識別できる必要があります．
ここではとりあえず，それぞれのセッションがどの Client との間に張られたものであるのかを識別できれば，Client 毎の状態を Server-side で個別に管理できそうです．
すなわち，特定のユーザからのアクセスを識別できれば，各ユーザとユーザが入力した内容の紐づけができるでしょう，ということです．</p>
<p><img src="img/formapp_session.png" alt="Sessions in formapp.go" /></p>
<p>このセッションと状態の紐づけを行うために，Client-side アプリケーションと Server-side アプリケーションとの間で<strong>合言葉</strong>のようなものを決めておけば，Server-side アプリケーションは合言葉のマッチングによって通信相手の同一性を確認できます．
この合言葉を一般に <strong>セッション ID</strong> あるいは <strong>セッションキー</strong> などと呼びます．</p>
<p>Client-Server 間でセッション ID を共有する方法として，1) URL書き換えを使用する方法，2) Cookie を使用する方法，が一般的に使用されます．
両手法の概要を以下に示しますが，本演習では 2) Cookie を使用する方法 を主に扱います．</p>
<h3 id="url書き換えを使用したセッションidの保存"><a class="header" href="#url書き換えを使用したセッションidの保存">URL書き換えを使用したセッションIDの保存</a></h3>
<p>セッション ID を URL 上にパラメータとして載せる，あるいはパスの一部として載せることによって Client-side から Server-side へセッション識別情報を送る方法です．
次に示す Cookie が有効化されていない，あるいは法令的に使用できないケースでもセッション管理を行うことができます．</p>
<p>本演習では詳細を扱わず，こうした方法もあるという程度の紹介にとどめます．</p>
<h3 id="cookieを使用したセッションidの保存"><a class="header" href="#cookieを使用したセッションidの保存">Cookieを使用したセッションIDの保存</a></h3>
<p><a href="https://developer.mozilla.org/docs/Web/HTTP/Cookies">Cookie</a> と呼ばれる小容量データを Client-side アプリケーションに保存し，HTTP Request header を使って Server-side にセッションを識別するための情報を送る方法です．</p>
<p>Cookie は Server-side アプリケーションからの HTTP Response header に <code>Set-Cookies: key=value</code> のような形式で指定される Cookie 情報の設定指令によって有効化されます．
これを受け取った Client-side アプリケーションは次の通信から HTTP Request header に <code>Cookie: key=value</code> の形式で Cookie 情報を記載し，Server-side アプリケーションがこれを読み取ることでセッションを識別します．</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>役割</th></tr></thead><tbody>
<tr><td>&lt;NAME&gt;=&lt;Value&gt;</td><td>そのCookieの名前とその値 (必須項目)</td></tr>
<tr><td>Expires=&lt;DATE&gt;</td><td>そのCookieの有効期間 (日付で指定)</td></tr>
<tr><td>Max-Age=&lt;SEC&gt;</td><td>そのCookieの残存期間 (秒数で指定)</td></tr>
<tr><td>Path=&lt;PATH&gt;</td><td>Cookieの適用対象となるパス</td></tr>
<tr><td>Domain=&lt;DOMAIN&gt;</td><td>Cookieの適用対象となるドメイン</td></tr>
<tr><td>Secure</td><td>HTTPSの場合のみCookieを有効化するフラグ</td></tr>
<tr><td>HttpOnly</td><td>JavaScriptによるCookieへのアクセスを禁止するフラグ</td></tr>
</tbody></table>
</div>
<p>これらの属性のうち，<code>&lt;NAME&gt;=&lt;VALUE&gt;</code> は必ず設定しなければいけないものです．
たとえば Server-side アプリケーションが <code>Set-Cookie: id=XXXXX-XXXXXXX</code> を HTTP headers に持つレスポンスを返した場合，Webブラウザは次以降のリクエストには必ず <code>Cookie: id=XXXXX-XXXXXXX</code> を HTTP headers に設定します．
<code>Expires</code> または <code>Max-Age</code> が指定された場合は，その指定期間内のみWebブラウザはCookieの送信を行います．
<code>Expires</code> と <code>Max-Age</code> が同時に指定された場合は，<code>Max-Age</code> の値が優先されます．</p>
<p>以降は，Cookie を用いたセッション方式の実装について扱い，セッション方式による formapp.go の開発を行っていきます．</p>
<h2 id="状態管理手法-2-セッション方式"><a class="header" href="#状態管理手法-2-セッション方式">状態管理手法 (2): セッション方式</a></h2>
<p>セッション方式の具体的な実装に移る前に，Client-side からのアクセスを弁別するためのセッション ID の付け方を考えます．
当然それぞれのセッションを区別するために，独立した，すなわち重複しない ID を与える必要があります．</p>
<p>素朴なアイデアとしては，整数値を ID として新たな接続が来るたびにインクリメントしていく方法が考えられます．
これは同時アクセスに対する排他制御さえしっかり行えば，区別するという役割においては ID として有効そうです．
一方で，この方法ではたとえば <code>ID=10</code> などとすることで簡単に他人のセッションに割り込んだり，他人のセッションを横取りしたりできてしまいます．
この点においては，あまり良い方法ではなさそうです．</p>
<p>以上から，セッション ID は単純に重複しないだけでなく<strong>重複した ID を生成しづらい</strong>必要がありそうです．
こうした性質を持つ識別子として，ここでは <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier"><strong>UUID (Universally Unique Identifier)</strong></a> を使用することとします．</p>
<p>Go言語において UUID を扱うパッケージとして，<a href="https://github.com/google.uuid">github.com/google/uuid</a> が提供されています．
これを使用するため，依存パッケージとして追加する処理を以下のコマンドから実行します．</p>
<pre><code class="language-sh">$ docker-compose exec app go get -u github.com/google/uuid
</code></pre>
<p>これを実行すると，go.mod 中に github.com/google/uuid が依存パッケージとして追加されます．</p>
<pre><code class="language-config">mod formapp.go

go 1.17

require (
    ...
	github.com/google/uuid v1.3.0 // indirect
    ...
)
</code></pre>
<p>プログラム中で使用する際は，Gin の import と同様に <code>import &quot;github.com/google/uuid&quot;</code> として import したうえで，<code>uuid.NewRandom</code> 関数によって重複しづらいランダムな UUID を生成できます．
具体的な使用例は後ほど記載します．</p>
<h3 id="仮ルーティングの設定-1"><a class="header" href="#仮ルーティングの設定-1">仮ルーティングの設定</a></h3>
<p>ステートレス方式を実装した時と同様にルーティングのみ先に定義してしまいます．
<a href = "04_state_management_v1.html#仮ルーティングの設定">前回の資料</a>より，最低限必要なルーティング設定は以下の 5 つでした．</p>
<ul>
<li>スタート画面を表示 (GET) するルート</li>
<li>スタート画面からのPOSTを受け取るルート</li>
<li>名前入力画面からのPOSTと受け取るルート</li>
<li>生年月日入力画面からのPOSTを受け取るルート</li>
<li>メッセージ入力画面からのPOSTを受け取るルート</li>
</ul>
<p>これらのルーティングを以下のように main.go ファイルへ追加します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.GET(&quot;/session/start&quot;, notImplemented)
    engine.POST(&quot;/session/start&quot;, notImplemented)
    engine.POST(&quot;/session/name&quot;, notImplemented)
    engine.POST(&quot;/session/birthday&quot;, notImplemented)
    engine.POST(&quot;/session/message&quot;, notImplemented)
    ...
}
</code></pre>
<p>前回は /stateless/ の下にそれぞれのページを配置しましたが，今回は /session/ の下に配置しています．
すなわち，ルーティングのレベルにおいて /stateless/ および /session/ の部分を名前空間として利用し，各方式で実装したページへのアクセスを区別しています．</p>
<p>コールバックとして登録している <code>notImplemented</code> 関数は前回定義したものをそのまま利用します．</p>
<h3 id="スタート画面-1"><a class="header" href="#スタート画面-1">スタート画面</a></h3>
<p>HTMLテンプレートは<a href="04_state_management_v1.html#%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E7%94%BB%E9%9D%A2">前回</a>作成した templates/start.html がそのまま使用可能です．
したがって，ここではスタート画面へのGETアクセスを受ける関数を新たに作成し，ルーティング設定を更新するだけで，スタート画面の表示が完了するはずです．</p>
<p>今回開発するセッション方式に関わるプログラムは，新たに formapp.go/service/session ディレクトリに作成した <code>session</code> パッケージ内に配置します．
前回までと同様にプログラムファイルは formapp.go/service/session/handler.go としておきましょう．</p>
<p><span class="filename">formapp.go/service/session/handler.go</span></p>
<pre><code class="language-go">package session

import (
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

func Start(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;start.html&quot;, gin.H{ &quot;Target&quot;: &quot;/session/start&quot; })
}
</code></pre>
<p><code>session.Start</code> 関数では，<code>&quot;Target&quot;</code> の値が <code>&quot;/session/start&quot;</code> となることに注意してください．</p>
<p>formapp.go/main.go を修正し，スタート画面への GET リクエストを飛ばせるようにしてみましょう．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">import (
    ...
    &quot;formapp.go/service/stateless&quot;  // statelessパッケージを使用
    &quot;formapp.go/service/session&quot;    // sessionパッケージを使用
)
func main() {
    ...
    engine.GET(&quot;/session/start&quot;, session.Start)
    engine.POST(&quot;/session/start&quot;, notImplemented)
    ...
}
</code></pre>
<p>アプリケーションを起動し，Web ブラウザから http://localhost:8000/session/start へアクセスしてみましょう．
スタート画面が表示されれば成功です．</p>
<h3 id="名前入力画面-1"><a class="header" href="#名前入力画面-1">名前入力画面</a></h3>
<p>こちらも，HTMLテンプレートは<a href="04_state_management_v1.html#%E5%90%8D%E5%89%8D%E5%85%A5%E5%8A%9B%E7%94%BB%E9%9D%A2">前回</a>作成した templates/name-form.html を使い回すことができます．
したがって，スタート画面からの POST を受け取って名前入力画面を返す関数として <code>session.NameForm</code> を定義して…</p>
<p><span class="filename">formapp.go/service/session/handler.go</span></p>
<pre><code class="language-go">...

func NameForm(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;name-form.html&quot;, gin.H{ &quot;Target&quot;: &quot;/session/name&quot; })
}
</code></pre>
<p>…としたいところですが，これでは不十分です．
セッション方式で状態を保存するために，このセッションを識別するCookieを設定する必要があります．</p>
<p>ここで，セッションに紐づく情報を保存する仕組みを別のファイルで予め作っておくこととします．
ファイル名はわかりやすければなんでもよいので formapp.go/service/session/sessions.go とでもしましょう．
以下のようなプログラムを配置します．</p>
<p><span class="filename">formapp.go/service/session/sessions.go</span></p>
<pre><code class="language-go">package session

import (
    &quot;fmt&quot;
    &quot;github.com/google/uuid&quot;
)

type State struct {
    Name string
    Birthday string
    Message string
}

var store = make(map[string]*State)

type Session struct {
    id string
}

func NewSession() (Session, error) {
    id, err := uuid.NewRandom()
    if err != nil {
        return Session{}, err
    }
    session := Session{ id.String() }
    return session, nil
}

func (s *Session) ID() string {
    return s.id
}

func (s *Session) GetState() (State, error) {
    if _, err := uuid.Parse(s.ID()); err != nil {
        return State{}, fmt.Errorf(&quot;Invalid session ID&quot;)
    }
    state, exist := store[s.ID()]
    if !exist {
        state = new(State)
        store[s.ID()] = state
    }
    return *state, nil
}

func (s *Session) SetState(ns State) error {
    state, exist := store[s.ID()]
    if !exist {
        return fmt.Errorf(&quot;State corresponds to %s does not exist&quot;, s.ID())
    }
    *state = ns
    return nil
}

func (s *Session) Close() {
    delete(store, s.ID())
    s.id = &quot;&quot;
}
</code></pre>
<p>このプログラムについて詳しい説明は省略しますが，<code>NewSession</code> 関数で開始した新しいセッションについて，セッションIDを <code>Session.ID</code> メソッドで取得できます．
セッションに紐づいた状態は <code>Session.GetState</code> メソッドで取得，<code>Session.SetState</code> メソッドで更新することができ，<code>Session.Close</code> メソッドによってセッションを終了 = 記憶の消去を行うことができます．</p>
<p>これを利用して，<code>session.NameForm</code> 関数を修正します．</p>
<p><span class="filename">formapp.go/service/session/handler.go</span></p>
<pre><code class="language-go">...

func NameForm(ctx *gin.Context) {
    session, err := NewSession()
    if err != nil {
        ctx.String(http.StatusInternalServerError, &quot;Fail to create a new session&quot;)
        return
    }
    ctx.SetCookie(&quot;userid&quot;, session.ID(), 600, &quot;/session/&quot;, &quot;localhost:8000&quot;, false, false)
    ctx.HTML(http.StatusOK, &quot;name-form.html&quot;, gin.H{ &quot;Target&quot;: &quot;/session/name&quot; })
}
</code></pre>
<p>4 行目にて先ほど定義した <code>NewSession</code> 関数を呼び出し，セッションIDを取得 = セッションを開始しています．
<code>NewSession</code> 関数は別のファイルですが同一のパッケージ内で定義されているので，パッケージ名を付けずに呼ぶことができます．</p>
<p>5～8 行目はエラー処理です．
おそらくここでエラーが起こることはありませんが，万が一 UUID の生成に失敗した場合に備えています．</p>
<p>9 行目にてHTTPレスポンスのヘッダー情報として <code>Set-Cookie</code> を設定しています．
これを受け取ったWebブラウザは，ここで指定された Cookie 情報を次のリクエストから自動で送信するようになります．
ここでは恣意的に10分間 (600秒) の有効期間を設けていますが，本来はアプリケーションの要求に応じて適切な値を設定すべき場所であることに注意してください．</p>
<p>ルーティングを更新し，名前入力画面への遷移を可能にします．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/session/start&quot;, session.NameForm)
    ...
}
</code></pre>
<p>一度，動作確認をしてみましょう．</p>
<div class="memo">
最近のWebブラウザの多くは保持しているCookie情報を閲覧する機能を持っています．
使用するブラウザによって方法が異なるため詳しくは各自で調べてもらいたいですが，そうした機能を使用することでここでたしかにCookieが登録されていることを確認できるかもしれません．
興味のある人は自分の良く使うWebブラウザの開発者向け機能を触ってみると良いでしょう．
</div>
<h3 id="生年月日入力画面-1"><a class="header" href="#生年月日入力画面-1">生年月日入力画面</a></h3>
<p>ここからは前の画面で入力した情報を状態として引き継いでいく必要があります．</p>
<p>まずはこれまで通り素直に生年月日入力画面を作ってみましょう．
ただし，ここからはセッション方式とやや記述内容が異なってくるため，区別できるようなファイル名としておきます．</p>
<p><span class="filename">templates/session-birthday-form.html</span></p>
<pre><code class="language-html">&lt;form action=&quot;/session/birthday&quot; method=&quot;post&quot;&gt;
    &lt;label&gt;生年月日: &lt;/label&gt;
    &lt;input type=&quot;date&quot; name=&quot;birthday&quot; value=&quot;2011-10-22&quot;&gt;&lt;/input&gt;
    &lt;br&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;
&lt;/form&gt;
</code></pre>
<p>templates/stateless-birthday-form.html では，状態を引き継ぐために <code>input[type=hidden]</code> によって名前入力画面で入力された名前情報を埋め込んでいました．
セッション方式では状態は Server-side アプリケーションによって管理されており，セッションと状態を結びつけるセッション ID は HTTP header に載せられる Cookie によって共有されるため，ページ内に明示的に情報を埋め込む必要がなくなります．</p>
<p>名前入力を受け取り，生年月日入力フォームを返す関数 <code>BirthdayForm</code> を formapp.go/service/session/handler.go へ追加します．
この関数は /session/name への POST を受け取って生年月日入力画面を返す関数であり，以下の 4 つのタスクを実行します．</p>
<ol>
<li>リクエストに設定された Cookie 情報からセッションを構築 (復元)</li>
<li>リクエストから名前情報を抜き出す</li>
<li>セッションに紐づいた状態を更新</li>
<li>生年月日入力画面を返す</li>
</ol>
<p><span class="filename">formapp.go/service/session/handler.go</span></p>
<pre><code class="language-go">...

func BirthdayForm(ctx *gin.Context) {
    id, err := ctx.Cookie(&quot;userid&quot;)
    if err != nil {
        ctx.String(http.StatusBadRequest, &quot;invalid access&quot;)
        return
    }
    session := Session{ id }
    name, exist := ctx.GetPostForm(&quot;name&quot;)
    if !exist {
        ctx.String(http.StatusBadRequest, &quot;parameter 'name' is not provided&quot;)
        return
    }
    state, _ := session.GetState()
    state.Name = name
    session.SetState(state)
    ctx.HTML(http.StatusOK, &quot;session-birthday-form.html&quot;, nil)
}
</code></pre>
<p>4--9 行目にてセッションの復元を行っています．
リクエストに設定された Cookie 情報は，<code>gin.Context.Cookie</code> メソッドによって取り出すことができます．
<a href="05_state_management_v2.html#%E5%90%8D%E5%89%8D%E5%85%A5%E5%8A%9B%E7%94%BB%E9%9D%A2">先ほど</a> Cookie として <code>userid=&lt;UUID&gt;</code> を設定したため，ここでは <code>Cookie(&quot;userid&quot;)</code> とすることでセッションを特定する <code>&lt;UUID&gt;</code> に相当する文字列を取得しています．
Cookie が設定されていない場合は，おそらく不正なページ遷移が発生していることが想定されるため，BadRequest を返すようエラー処理を加えています．
9 行目で取得した UUID 文字列からsession オブジェクトを構築しています．</p>
<p>10--14 行目は前回と同様の処理ですので説明を割愛します．</p>
<p>15--17 行目で，セッションに対応する状態を更新します．
ここでは特に名前入力画面から送信された名前情報を記憶領域へ保存する処理を行っています．
煩雑になるため <code>GetState</code> および <code>SetState</code> 時のエラー判定を省略していますが，本来はセッション ID の有効性を検証するためにエラー処理を記述すべきです．</p>
<p>18 行目にて生年月日入力画面を返しています．
templates/session-birthday-form.html は埋め込み変数を持たないので，第 3 引数に <code>nil</code> を設定しています．</p>
<p>最後にルーティングを更新し，名前入力画面からのPOSTリクエストを有効化します．</p>
<p><span class="filename">formapp.go/main.go</span></p>
<pre><code class="language-go">func main() {
    ...
    engine.POST(&quot;/session/name&quot;, session.BirthdayForm)
    ...
}
</code></pre>
<p>ここまでの動作確認を行いましょう．</p>
<h5 id="練習問題-5"><a class="header" href="#練習問題-5">練習問題 5</a></h5>
<p>ここまでの内容をもとに，<a href="https://cs-sysdes.github.io/formapp.html">formapp.goの仕様</a>を満たすアプリケーションを<strong>セッション方式で</strong>開発してみましょう．</p>
<h2 id="まとめ-4"><a class="header" href="#まとめ-4">まとめ</a></h2>
<p>前回と今回の 2 回を通して，HTTP通信における状態管理の方法を扱いました．
ステートレス方式およびセッション方式はそれぞれ長所・短所があるため，場合によって適切に使い分けられると良いでしょう．</p>
<p>ここでは例として複数ページに跨った入力フォームを扱いましたが，実際のところこうした入力フォームは 1 ページで完結する場合が多いです．
一方で，最も頻繁に利用される状態管理は，やはりログイン状態の管理だと思います．
ログイン状態を複数ページに跨って管理するためには，すべてのページに <code>input[type=hidden]</code> を仕込むわけにもいかないので，今回扱ったセッション方式による管理が主流になるでしょう．</p>
<p>今回はセッション方式の仕組みについて理解してもらうことを目的としたため，Server-side アプリケーション内で状態を保存する部分はかなり素朴なつくりになっています．
たとえば，適切に <code>session.Session.Close</code> メソッドが呼ばれなければ使用済みの記憶領域が解放されず，どんどんメモリを消費し続けてしまうようなプログラムになっているなど，実用上問題となる部分が多く存在します．
こうした部分をきちんと実装するのは非常に大変な作業ですし，ミスも起こりやすいです．
したがって，実用的なアプリケーションを開発する際は，<a href="https://github.com/gin-contrib/sessions">gin-contrib/sessions</a> のようなプラグインライブラリを使用する方が良いでしょう．</p>
<p>今回で前半の基礎編が終了です．
次回からは実践編として簡単なタスク管理アプリケーションの開発を行います．
具体的なアプリケーションの仕様は以下のページに掲載していますが，演習資料では主に<strong>基本仕様</strong>の実装のみを扱います．</p>
<p><a href="https://cs-sysdes.github.io/todolist.html">https://cs-sysdes.github.io/todolist.html</a></p>
<p>今回の内容は以上です．
おつかれさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-タスク管理アプリケーション"><a class="header" href="#06-タスク管理アプリケーション">06: タスク管理アプリケーション</a></h1>
<p>ここからは実践編として簡単なタスク管理アプリケーションの開発に取り組みます．
開発するアプリケーションの仕様は以下のページにまとめてあります．</p>
<p><a href="https://cs-sysdes.github.io/todolist.html">https://cs-sysdes.github.io/todolist.html</a></p>
<p>演習資料では主に基本仕様に関する実装を扱います．
追加仕様に関しては資料中では扱いませんが，余裕のある人は実装に挑戦してみると良いでしょう．
また，仕様書に記載のない独自機能やアレンジを加えても構いません．</p>
<p>今回は特に以下の内容を通して，今後使用するプロジェクト <a href="https://github.com/cs-sysdes/todolist.go">todolist.go</a> の説明と簡単な実装練習を行います．</p>
<ol>
<li><a href="06_todolist.html#todolistgo-%E6%A6%82%E8%A6%B3">todolist.go 概観</a></li>
<li><a href="06_todolist.html#%E3%82%BF%E3%82%B9%E3%82%AF%E8%A1%A8%E7%A4%BA%E7%94%BB%E9%9D%A2%E3%81%AE%E4%BD%9C%E6%88%90">タスク表示画面の作成</a></li>
</ol>
<p>実践編では，基礎編以上に説明を簡略化している部分があります．
不明点があれば遠慮せず Slack より質問を投げてください．</p>
<p>基礎編と同様に，提示するコードに関して以下に注意してください．</p>
<ul>
<li>package 宣言を省略するなど，ソースコードの一部を抜粋している場合があります．</li>
<li>表記中の <code>...</code> は特に断らない限りコードの省略を意味します．</li>
<li>提示したコードの n 行目などと指定した場合は，本資料上での行数を意味しています．
多くの場合，実際のソースコード上での行数と一致するものではありません．</li>
</ul>
<h2 id="todolistgo-概観"><a class="header" href="#todolistgo-概観">todolist.go 概観</a></h2>
<p>実践編は以下のプロジェクトをベースとして演習を進めます．
ダウンロードをした上で作業ディレクトリに配置してください．
ダウンロード方法を忘れた場合は <a href="01_preliminary.html#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%8F%96%E5%BE%97">第1回資料</a> を参照してください．</p>
<p><a href="https://github.com/cs-sysdes/todolist.go">https://github.com/cs-sysdes/todolist.go</a></p>
<p>ここではこのプロジェクトの構成，主要なファイルとパッケージの役割および内容の簡単な説明を行います．
コードを書いて開発を進めるようなパートではありませんが，開発を進めるうえで重要な内容ですので，実際にファイルを開いて当該箇所を確認する．あるいはプログラムを起動して動作を確認するなどして下さい．</p>
<h3 id="アプリケーション構成"><a class="header" href="#アプリケーション構成">アプリケーション構成</a></h3>
<p>todolist.go は Go言語 で記述された Server-side アプリケーション (app) に加え，データベースとして<a href="https://mysql.com">MySQL</a>を使用しています．
それぞれのサービスはこれまで通り Docker コンテナ上で動くよう docker-compose.yml に設定を記述していますので，データベースアプリケーションを個別に準備してもらう必要はありません．
一方で，プログラムは Docker コンテナに依存しないよう記述しているので，適切に環境設定を行えばローカルで動かすことも可能です．</p>
<p>アプリケーションの全体構成を以下に示します．</p>
<p><img src="img/todolist_structure.png" alt="todolist.go: application structure" /></p>
<p>Go言語で記述された Server-side アプリケーション (app) が Docker 上で動いており，これが Client-side アプリケーションと通信を行って目的の処理を実行する点はこれまでと変わりません．
アプリケーションを起動した状態でWebブラウザなどから http://localhost:8000 へアクセスすると，タスク管理アプリケーションを使用できます．
ただし，データベースの初期化などに時間がかかるため，初回起動時のみ <code>docker-compose exec</code> コマンドの反応がやや鈍い場合があります．</p>
<pre><code class="language-sh">$ cd ~/sysdes/tutorial.go                 # プロジェクトディレクトリは各自の環境で置き換えてください
$ docker-compose up -d                    # Dockerコンテナの起動
$ docker-compose exec app go run main.go  # アプリケーションの起動
</code></pre>
<p>Server-side アプリケーション (app) と データベース (db) は Docker 上に構築されたネットワークにより接続されています．
データベース接続に関わる設定やデータベースアクセスのための仕組みはすでに実装済みであり，app から適切なメソッドを通してSQLクエリを発行することで db 内のデータを操作可能です．</p>
<p>おまけとして db の状態を監視するために <a href="https://docs.phpmyadmin.net/en/latest">phpmyadmin</a> を導入しています．
Webブラウザから http://localhosty:8080 へアクセスすることでMySQLサーバをブラウザ上で操作可能です．
データベース内のデータを確認したり，SQLクエリを実行してどのような結果が返ってくるかを確かめたりできますが，演習内で明示的に使用することはありません．</p>
<p>ここから実装済みのいくつかのファイルおよびパッケージについて説明したのち，アプリケーションを起動して挙動を確認していきます．</p>
<h3 id="todolistgomaingo"><a class="header" href="#todolistgomaingo">todolist.go/main.go</a></h3>
<p>todolist.go/main.go はタスク管理アプリケーションのエントリポイントです．
内容は formapp.go/main.go とほとんど同じなので，相違点のみ説明します．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">func main() {
    // initialize DB connection
    dsn := db.DefaultDSN(
        os.Getenv(&quot;DB_HOST&quot;),
        os.Getenv(&quot;DB_PORT&quot;),
        os.Getenv(&quot;DB_USER&quot;),
        os.Getenv(&quot;DB_PASSWORD&quot;),
        os.Getenv(&quot;DB_NAME&quot;))
    if err := db.Connect(dsn); err != nil {
        log.Fatal(err)
    }
    ...
    // routing
    engine.Static(&quot;/assets&quot;, &quot;./assets&quot;)
    engine.GET(&quot;/&quot;, service.Home)
    engine.GET(&quot;/list&quot;, service.TaskList)
    engine.GET(&quot;/task/:id&quot;, service.ShowTask) // &quot;:id&quot; is a parameter
    ...
</code></pre>
<p>3～8 行目は，MySQLサーバとの接続に必要な設定を環境変数から読み込む処理です．
docker-compose.yml 内で Docker コンテナ上における環境変数それぞれの値を設定しています．
ローカルで動かしたい場合には，適切な環境変数を設定することでプログラムを変更することなく接続先データベースを変更できます．</p>
<p>9～11 行目においてデータベースとの接続を行っています．
接続に失敗した場合 <code>err != nil</code> が <code>true</code> となるため，<code>log.Fatal</code> 関数によってプログラムが異常停止します．</p>
<p>14～17 行目に，初期状態でのルーティングをいくつか設定しています．
14 行目の <code>engine.Static</code> メソッドは，Go言語 で書かれたプログラムではなく，画像ファイルなどの静的データを扱うための設定です．
使用したい静的データがあれば，todolist.go/assets ディレクトリ下に配置することで，アクセスが可能になります．</p>
<p>17 行目の記述はここまでで説明していない Gin の機能ですが，パスの一部をパラメータとして使用する記述法になります．
たとえばこのように &quot;task/:id&quot; と記述した場合，&quot;:id&quot; の部分は &quot;:id&quot; という文字列そのものに一致するのではなく，&quot;task/1&quot; などのように指定された値を <code>id=1</code> として受け取れるようになります．
詳細は <a href="06_todolist.html#%E3%82%BF%E3%82%B9%E3%82%AF%E8%A1%A8%E7%A4%BA%E7%94%BB%E9%9D%A2%E3%81%AE%E4%BD%9C%E6%88%90">タスク表示画面の作成</a> にて説明します．</p>
<h3 id="todolistgoservice-パッケージ"><a class="header" href="#todolistgoservice-パッケージ">todolist.go/service パッケージ</a></h3>
<p>役割は formapp.go/service パッケージと同じです．
基本的にはルーティングに対応する処理を提供します．</p>
<p>todolist.go/service/default.go にはルート (&quot;/&quot;) へのアクセスや formapp.go における<a href="04_state_management_v1.html#%E4%BB%AE%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AE%E8%A8%AD%E5%AE%9A">仮ルーティングの実装</a>に使用した <code>NotImplemented</code> 関数などを定義しています．
<code>Error</code> 関数はエラー処理を行う際の共通コードを括り出したもので，<code>NotImplemeted</code> 関数内でも使用しています．
Go言語 ではこのように<strong>関数を返す関数</strong>を使用することで，汎用性の高い処理を部品化し，再利用性を高めることができます．</p>
<p><span class="filename">todolist.go/service/default.go</span></p>
<pre><code class="language-go">...
// Home renders index.html
func Home(ctx *gin.Context) {
	ctx.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{&quot;Title&quot;: &quot;HOME&quot;})
}

// NotImplemented renders error.html with 501 Not Implemented
func NotImplemented(ctx *gin.Context) {
	msg := fmt.Sprintf(&quot;%s access to %s is not implemented yet&quot;, ctx.Request.Method, ctx.Request.URL)
	ctx.Header(&quot;Cache-Contrl&quot;, &quot;no-cache&quot;)
	Error(http.StatusNotImplemented, msg)(ctx)
}

// Error returns a handler which renders error.html
func Error(code int, message string) gin.HandlerFunc {
	return func(ctx *gin.Context) {
		ctx.HTML(code, &quot;error.html&quot;, gin.H{&quot;Code&quot;: code, &quot;Error&quot;: message})
	}
}
</code></pre>
<p>todolist.go/service/task.go は，このアプリケーションの管理するタスクに関わる処理を集めいたファイルです．
基本仕様 S-1.1 および S-1.2 については，基本的にこのファイルに適切な処理を定義することで実装を進めていきます．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">package service

import (
	&quot;net/http&quot;
	&quot;strconv&quot;

	&quot;github.com/gin-gonic/gin&quot;
	database &quot;todolist.go/db&quot;
)

// TaskList renders list of tasks in DB
func TaskList(ctx *gin.Context) {
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}

	// Get tasks in DB
	var tasks []database.Task
	err = db.Select(&amp;tasks, &quot;SELECT * FROM tasks&quot;) // Use DB#Select for multiple entries
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}

	// Render tasks
	ctx.HTML(http.StatusOK, &quot;task_list.html&quot;, gin.H{&quot;Title&quot;: &quot;Task list&quot;, &quot;Tasks&quot;: tasks})
}
...
</code></pre>
<p>ここでは <code>TaskList</code> 関数の実装について解説を加えます．
この関数は，&quot;/list&quot; への GET リクエストに対して呼ばれ，データベース中に保存されたタスクを一覧表示します．</p>
<p>14～18 行目において，データベースへアクセスするための接続を取得しています．
今後ほとんどの関数で使用するコードなので覚えておいて下さい．</p>
<p>14 行目で使用している <code>database</code> 識別子はパッケージ名であり，変数名として <code>db</code> を使用したかったので，8 行目の import 宣言にて todolist.go/db パッケージに別名として <code>database</code> を与えています．</p>
<p>21～26 行目でデータベースからタスクのデータを取り出しています．</p>
<p>21 行目において取り出したデータを格納するための変数 <code>tasks</code> を定義しています．
変数 <code>tasks</code> の型は <code>database.Task</code> のスライスであり，<code>database.Task</code> はデータベース中のタスクデータに対応した構造体です (詳細は<a href="06_todolist.html#todolistgodb-%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8">後述</a>)．</p>
<p>22 行目においてSQLクエリを発行し，データを取得しています．
<code>database.Getconnection</code> 関数によって取得できる変数 <code>db</code> は，<code>sqlx.DB</code> 型の構造体です．
<code>sqlx.DB.Select</code> メソッドは，データベースから複数のデータを取り出す際に使用するメソッドであり，第1引数としてデータに対応する構造体のスライスを指定することで，<strong>半自動的</strong>に取り出したデータを構造体へ束縛してくれます．
ここで「半自動的」と書いたのは，構造体宣言時に構造体のフィールドとデータの属性を結びつける<strong>タグ</strong>を付与する必要があるためです．</p>
<p>22 行目について，<code>err := ...</code> ではなく，<code>err = ...</code> である点に注意してください．
これは 14 行目においてすでに <code>err</code> 変数が定義されており，かつ，22 行目の <code>err</code> 変数は単体での代入操作を受けているため <code>:=</code> が使用できません．</p>
<p>29 行目はこれまでと同様に HTML テンプレートを使用してレスポンスを生成するコードです．
todolist.go/main.go 内の記述を見るとわかるように，今回は HTML テンプレートのディレクトリとして todolist.go/views を指定しています．
したがって，ここでは todolist.go/views/task_list.html にページタイトルとデータベースから取得したタスクを埋め込み，HTML ページとして返す処理を行います．</p>
<div class="memo">
Go言語 の標準パッケージには database/sql というデータベース操作用の機能が存在します．
github.com/jmoiron/sqlx パッケージは，標準ライブラリの database/sql パッケージを拡張したモジュールであり，内部的には標準ライブラリの機能を使用しています．
標準ライブラリをそのまま使用しても良いのですが，sqlx の方がより便利な拡張機能を備えており，多くのプロジェクトで採用されています．
たとえばここに示した構造体への束縛機能も，sqlx で提供される拡張機能です．
</div>
<h3 id="todolistgoviews"><a class="header" href="#todolistgoviews">todolist.go/views</a></h3>
<p>todolist.go/views ディレクトリは formapp.go/templates と同じくHTMLテンプレートを配置するディレクトリです．
今回はHTMLテンプレートの新たな機能を使用しているため，その部分についてのみ説明を加えます．</p>
<p>以下に todolist.go/views/task_list.html を示します．
このテンプレートは複数のタスクを一覧表示するためのものです．</p>
<p><span class="filename">todolist.go/views/task_list.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;List of tasks&lt;/h1&gt;
{{ if not .Tasks }}
&lt;p&gt;登録データがありません．&lt;/p&gt;
{{ else }}
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;ID&lt;/th&gt;
        &lt;th&gt;タイトル&lt;/th&gt;
        &lt;th&gt;登録日&lt;/th&gt;
        &lt;th&gt;状態&lt;/th&gt;
    &lt;/tr&gt;
    {{ range $task := .Tasks }}
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&quot;/task/{{ $task.ID }}&quot;&gt;{{ $task.ID }}&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;{{ $task.Title }}&lt;/td&gt;
        &lt;td&gt;{{ $task.CreatedAt }}&lt;/td&gt;
        &lt;td&gt;{{ if $task.IsDone }}済{{ end }}&lt;/td&gt;
    &lt;/tr&gt;
    {{ end }}
&lt;/table&gt;
{{ end }}
{{ template &quot;footer&quot; }}
</code></pre>
<p>1 行目および 23 行目の記述は，他のテンプレートファイルにおいて定義した部分テンプレートを使用するための記述です．
ここではそれぞれ <code>&quot;header&quot;</code> と <code>&quot;footer&quot;</code> テンプレートを呼び出していますが，これらはそれぞれ以下のように定義されています．</p>
<p><span class="filename">todolist.go/views/_header.html</span></p>
<pre><code class="language-html">{{ define &quot;header&quot; }}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;{{ .Title }} | todolist.go&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/style.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/assets/script.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
{{ end }}
</code></pre>
<p><span class="filename">todolist.go/views/_footer.html</span></p>
<pre><code class="language-html">{{ define &quot;footer&quot; }}
&lt;/body&gt;
&lt;/html&gt;
{{ end }}
</code></pre>
<p>これらはそれぞれHTML文書の開始部および終了部であり，ほぼどのようなHTMLであっても共通するパーツとなることが多い部分です．
したがって，このように共有パーツとしてあらかじめ定義しておき，使用時には単純にこれらの定義を呼び出すことで再利用性を高めています．
一方で，共有パーツはこの他にも比較的自由に定義できますが，todolist.go/views/_header.html のように共有パーツ側に変数が存在する場合，Go言語 プログラム中から呼び出す際に渡すべき変数がわかりづらくなるため，多用は避けるべきかもしれません．</p>
<p>todolist.go/views/task_list.html の説明に戻ります．</p>
<p>3 行目や 18 行目では，<code>{{ ... }}</code> の内部で <code>if</code> キーワードによる条件分岐を使用しています．
同様に，13 行目では <code>range</code> キーワードを使用した繰り返し表現を使用しています．
またそれぞれの効果範囲は <code>{{ else }}</code> や <code>{{ end }}</code> によって明示されます．</p>
<p>Go言語 のテンプレート機能では，このように <code>{{ ... }}</code> ブロックを使用することで変数の埋め込みだけでなく条件分岐や簡単なループ表現も扱うことができます．
これにより生成するHTML文書を柔軟に表現できるようになっています．
一方で，テンプレート記法はやや独特な文法となっているため，ある程度の慣れが必要かもしれません．
特に Go言語 とは異なりスコープの区切りをキーワード (<code>{{ end }}</code>など) で指定する方式となっているため，インデントを適切に設定するなどして効果範囲がわかりやすいよう工夫する必要があります．
慣れるまでは todolist.go/views/task_list.html の書き方を真似すると良いでしょう．</p>
<p>テンプレート機能のより詳細な使い方は <a href="https://pkg.go.dev/text/template">公式ドキュメント</a> を参照してください．</p>
<h3 id="todolistgodb-パッケージ"><a class="header" href="#todolistgodb-パッケージ">todolist.go/db パッケージ</a></h3>
<p>ここからは formapp.go までは扱ってこなかったデータベース周りの話になります．</p>
<p>todolist.go/db/conn.go は，データベースとの接続まわりをサポートする機能を実装したファイルのため，今後特に編集する必要性は生じないと思います．
このファイルには <code>GetConnection</code> 関数が定義されており，先にも説明した通りデータベースへのアクセスを行うためにはこの関数を通して <code>sqlx.DB</code> 構造体 (へのポインタ) を取得する必要があることだけ覚えておいてください．
なお，ファイルの内容自体は非常にオーソドックスな実装ですので，処理の内容は簡単に追うことができるのではないでしょうか．</p>
<p>一方で，todolist.go/db/entity.go ファイルは，開発を進めるにあたって編集 (機能追加) する機会が多くなるかと思います．
初期実装を以下に示します．
初期実装では，データベース内にすでに存在するタスクデータに対応する構造体のみが定義されています．</p>
<p><span class="filename">todolist.go/db/entity.go</span></p>
<pre><code class="language-go">package db

// schema.go provides data models in DB
import (
	&quot;time&quot;
)

// Task corresponds to a row in `tasks` table
type Task struct {
	ID        uint64    `db:&quot;id&quot;`
	Title     string    `db:&quot;title&quot;`
	CreatedAt time.Time `db:&quot;created_at&quot;`
	IsDone    bool      `db:&quot;is_done&quot;`
}
</code></pre>
<p><a href="06_todolist.html#todolistgoservice-%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8">serviceパッケージ</a> の説明において，以下のように<strong>構造体のフィールドとデータの属性を結びつけるタグ</strong>について触れました．</p>
<blockquote>
<p><code>sqlx.DB.Select</code> メソッドは，データベースから複数のデータを取り出す際に使用するメソッドであり，第1引数としてデータに対応する構造体のスライスを指定することで，<strong>半自動的</strong>に取り出したデータを構造体へ束縛してくれます．
ここで「半自動的」と書いたのは，構造体宣言時に構造体のフィールドとデータの属性を結びつける<strong>タグ</strong>を付与する必要があるためです．</p>
</blockquote>
<p>9～14 行目の構造体の定義において，型の後についている <code class="hljs">`db:&quot;...&quot;`</code> の部分が<strong>タグ</strong>になり，<code>...</code> にデータベース上でのデータの属性名を指定します．
たとえば 10 行目の <code class="hljs">ID uint64 `db:&quot;id&quot;`</code> は，<code>uint64</code> 型のフィールド <code>ID</code> を，データベース中のタスクテーブル内のデータの <code>id</code> 属性と対応させることを意味します．</p>
<p>次に，ここで定義した構造体に対応するデータを保存するためのデータベースの設定について説明します．</p>
<h3 id="データベースのテーブル定義"><a class="header" href="#データベースのテーブル定義">データベースのテーブル定義</a></h3>
<p>データベースの設定は，todolist.go/docker/db ディレクトリ内に配置しています．
開発時には主に todolist/docker/db/sql ディレクトリ内のファイルを編集することになるかと思います．</p>
<p>todolist.go/docker/db/sql/01_create_tables.sql はテーブルの定義を記述したファイルになります．
初期状態では以下の通りタスクデータを保存する tasks テーブルのみを定義しています．
データベースに新たなテーブルを追加したい場合には，このファイルを編集するとよいでしょう．</p>
<p><span class="filename">todolist.go/docker/db/sql/01_create_tables.sql</span></p>
<pre><code class="language-sql">-- Table for tasks
DROP TABLE IF EXISTS `tasks`;

CREATE TABLE `tasks` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `title` varchar(50) NOT NULL,
    `is_done` boolean NOT NULL DEFAULT b'0',
    `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) DEFAULT CHARSET=utf8mb4;
</code></pre>
<p>この定義の通り，タスクは属性として id, title, is_done, created_at を持ちます．
todolist.go/db/entity.go 内の構造体 <code>Task</code> は，ここに定義したデータの属性名および型と対応するよう定義しています．</p>
<p>ここに示した定義において，id はデータ登録時に重複しない値が自動で付与されるよう設定しており，このテーブルにおける id の一意性 (同じ id を持つデータが同じテーブル内に存在しない性質) を保証しています．
また特に指定がなければ，is_done 属性はデフォルト値として false，created_at 属性はデフォルト値として現在時刻が設定されるようにしています．
したがって，データ登録時に必ず指定しなければいけない属性は title のみということになります．</p>
<p>todolist.go/docker/db/sql/02_initial_data.sql には，初期データとしていくつかのタスクを登録するためのクエリを記述しています．
初期データを登録したい場合は，こちらのファイルへデータ登録のためのクエリを追記すると良いでしょう．</p>
<p><span class="filename">todolist.go/docker/db/sql/02_initial_data.sql</span></p>
<pre><code class="language-sql">INSERT INTO `tasks` (`title`) VALUES (&quot;sample-task-01&quot;);
INSERT INTO `tasks` (`title`) VALUES (&quot;sample-task-02&quot;);
INSERT INTO `tasks` (`title`) VALUES (&quot;sample-task-03&quot;);
INSERT INTO `tasks` (`title`) VALUES (&quot;sample-task-04&quot;);
INSERT INTO `tasks` (`title`, `is_done`) VALUES (&quot;sample-task-05&quot;, true);
</code></pre>
<p>これら2 つのファイルは，データベースの Docker コンテナをはじめて起動した際に読み込まれ，データベースを構築します．
したがって，これらのファイルを編集した場合には，編集した結果を反映するために一度データベースを完全に初期化する必要があります．</p>
<p>初期化処理が必要になったときに再び説明しますが，データベースコンテナを初期化したうえで再起動するには以下のコマンドを実行する必要があります．</p>
<pre><code class="language-sh">$ docker-compose down --rmi all --volumes --remove-orphans
$ docker-compose up -d
</code></pre>
<h3 id="画面構成"><a class="header" href="#画面構成">画面構成</a></h3>
<p>プロジェクトの構成を概観したところで，動作確認をしてみましょう．
まずは Docker コンテナを起動します．
初回はコンテナイメージのダウンロードおよびビルドを行うため，少し時間がかかります．</p>
<pre><code class="language-sh">$ docker-compose up -d
</code></pre>
<p>前回までとは異なり，今回はこのコマンド 1 つで app, db, phpmyadmin の 3 つのサービスを同時に起動しています．
app および phpmyadmin は db コンテナを参照するサービスですので，これらの間には依存関係が存在します．
こうした依存関係は docker-copmpose.yml において自動的に解決するよう設定を記述していますので，特にコンテナの起動順序について気にする必要はありません．</p>
<p>コンテナが起動したら，以下のコマンドで app を起動します．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
</code></pre>
<p>コマンド自体はこれまでと同様ですが，db コンテナとの接続の関係で反応が鈍い場合があります．
準備ができたら以下のようなログが表示されますので，気長にお待ちください．</p>
<pre><code class="language-sh">$ docker-compose exec app go run main.go
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] Loaded HTML Templates (7): 
        - header
        - error.html
        - task_list.html
        - _header.html
        - _footer.html
        - footer
        - index.html

[GIN-debug] GET    /assets/*filepath         --&gt; github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (3 handlers)
[GIN-debug] HEAD   /assets/*filepath         --&gt; github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (3 handlers)
[GIN-debug] GET    /                         --&gt; todolist.go/service.Home (3 handlers)
[GIN-debug] GET    /list                     --&gt; todolist.go/service.TaskList (3 handlers)
[GIN-debug] GET    /task/:id                 --&gt; todolist.go/service.ShowTask (3 handlers)
[GIN-debug] Listening and serving HTTP on :8000
</code></pre>
<p>app が起動したらWebブラウザから <a href="http://localhost:8000">http://localhost:8000</a> へアクセスし，以下のページが表示されることを確認してください．</p>
<p><img src="img/todolist_index.png" alt="todolist.go home" /></p>
<p>表示されている「登録済みタスク一覧」のリンクをクリックすると，以下のページへ遷移します．</p>
<p><img src="img/todolist_task_list.png" alt="todolist.go task list" /></p>
<p>このページは登録されているタスクを一覧表示するものです．
表示に至るまでの処理を追えば，/list に対する GET リクエストが飛ばされ，<code>service.TaskList</code> 関数が実行されて views/task_list.html がレンダリングされた状態となります．</p>
<p>タスクの一覧表示では，ID にリンクを設定しています．
それぞれのリンクは /task/:id への GET アクセスを自身のID値を設定して飛ばすよう設定されており，たとえば ID = 1 のリンクをクリックした場合，以下のページに遷移します．</p>
<p><img src="img/todolist_task_default.png" alt="todolist.go task view (default)" /></p>
<p>/task/:id への GET アクセスは <code>service.ShowTask</code> 関数を呼び出しますが，現在の実装ではタスクのタイトルのみを文字列で返すプログラムとなっているため，味気ない表示が返されるのみです．
次のセクションでは，簡単な練習としてこの表示を改善してみます．</p>
<h2 id="タスク表示画面の作成"><a class="header" href="#タスク表示画面の作成">タスク表示画面の作成</a></h2>
<p>タスク表示ページの改善を行うにあたり，まずは <code>service.ShwoTask</code> 関数を理解します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...

// ShowTask renders a task with given ID
func ShowTask(ctx *gin.Context) {
    ...
	// parse ID given as a parameter
	id, err := strconv.Atoi(ctx.Param(&quot;id&quot;))
	if err != nil {
		Error(http.StatusBadRequest, err.Error())(ctx)
		return
	}

	// Get a task with given ID
	var task database.Task
	err = db.Get(&amp;task, &quot;SELECT * FROM tasks WHERE id=?&quot;, id) // Use DB#Get for one entry
	if err != nil {
		Error(http.StatusBadRequest, err.Error())(ctx)
		return
	}

	// Render task
	ctx.String(http.StatusOK, task.Title)  // Modify it!!
}
</code></pre>
<p>22 行目を修正すべきであることは明らかですが，<strong>パスパラメータ</strong>の仕組みを理解するため上から順に説明します．</p>
<p>ルーティングの設定より，<code>service.ShowTask</code> 関数は /task/:id への GET リクエストに対応する処理です．
ここで，リクエストパス中の :id の部分はパラメータであり，このようなパスの一部をパラメータとして扱う機能を<strong>パスパラメータ</strong>と呼びます．</p>
<p>Gin では <code>gin.Context.Param</code> メソッドによって設定されたパスパラメータを受け取ることができます．
今回は &quot;id&quot; を key とするパラメータが設定されているため，7 行目に示す通り <code>ctx.Param(&quot;id&quot;)</code> と記述することで，:id の部分に指定された値を文字列として取得します．
ここでは同時に ID が整数値であることを検証するため，<code>strconv.Atoi</code> 関数で文字列から整数値への変換を試しています．
仮にここで変換に失敗した場合，ID として不正な値が入力されたことを意味するので，BadRequestエラーを返すようエラー処理を実装しています．</p>
<p>14～19 行目は，指定された ID を持つタスクをデータベースから取得するコードです．
<code>service.TaskList</code> 関数では複数のタスクを受け取る可能性があったため <code>sqlx.DB.Select</code> メソッドを使用しましたが，今回は結果を 1 つのみ受け取るため <code>sqlx.DB.Get</code> メソッドを使用しています．
なお，ID の一意性はテーブル定義において保証されているため，<code>SELECT * FROM tasks WHERE id=1</code> などと ID を指定して取得クエリを発行した場合には，必ず 0 または 1 つのデータのみがクエリの結果として返されます．
もし適合するデータが 0 個の場合，すなわちテーブル内に存在しない場合，<code>err != nil</code> となりエラー処理が実行されます．</p>
<p>このままではタイトルが文字列で表示されるだけのページとなってしまうため，まずはページのテンプレートを用意します．
適当なファイルとして task.html をtodolist.go/views ディレクトリ下に配置し，以下のようなHTMLを記述します．
なお，ここで示すHTMLテンプレートの内容は実装例であり，好みに応じてアレンジを加えていただいて構いません．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Task: {{ .Title }}&lt;/h1&gt;
&lt;dl&gt;
    &lt;dt&gt;ID&lt;/dt&gt;
    &lt;dd&gt;{{ .ID }}&lt;/dd&gt;
    &lt;dt&gt;Created at&lt;/dt&gt;
    &lt;dd&gt;{{ .CreatedAt }}&lt;/dd&gt;
    &lt;dt&gt;Status&lt;/dt&gt;
    &lt;dd&gt;&lt;input type=&quot;checkbox&quot; {{ if .IsDone }}checked {{ end }}disabled/&gt;済&lt;/dd&gt;
&lt;/dl&gt;
&lt;a href=&quot;/list&quot;&gt;&lt;button type=&quot;button&quot;&gt;リストへ戻る&lt;/button&gt;&lt;/a&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>このHTMLテンプレートを呼び出すよう，<code>service.ShowTask</code> 関数の最終行を修正します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">    ...
	// Render task
	//ctx.String(http.StatusOK, task.Title)  // Modify it!!
    ctx.HTML(http.StatusOK, &quot;task.html&quot;, task)
}
</code></pre>
<p>ここでは <code>gin.H</code> を利用して連想配列をテンプレートへ渡すのではなく，<code>task</code> 変数を直接渡しています．
Go言語 は割と柔軟で，このように記述してもよしなに扱ってくれます．
ただし，渡す構造体のフィールドすべてが文字列への変換に対応している必要があります．</p>
<h5 id="練習問題-6-1"><a class="header" href="#練習問題-6-1">練習問題 6-1</a></h5>
<p>上記の修正を適用し，タスクの表示画面を改善した結果を確認してみましょう．</p>
<h5 id="練習問題-6-2"><a class="header" href="#練習問題-6-2">練習問題 6-2</a></h5>
<p>タスク一覧表示画面について，各自の裁量で見やすさなど改善を施してみましょう．</p>
<h5 id="練習問題-6-3-発展的内容"><a class="header" href="#練習問題-6-3-発展的内容">練習問題 6-3 (発展的内容)</a></h5>
<p>タスクに簡単な説明文を追加して表示できるようテーブルや構造体の定義，タスク表示画面を拡張してみましょう．
資料での説明を超える発展的内容であるため，必ずしも取り組む必要はありません．</p>
<p>【ヒント】</p>
<ul>
<li>データベース上では <code>varchar(256)</code> などとすることで，比較的長いテキストのための属性を定義できる．</li>
<li>テーブル定義などを更新した場合，データベースコンテナの初期化が必要となる．</li>
</ul>
<h2 id="まとめ-5"><a class="header" href="#まとめ-5">まとめ</a></h2>
<p>今回は実践編の初回としてベースプロジェクト todolist.go の構成を説明し，簡単なタスク表示ページの実装を行いました．
次回からは<a href="https://cs-sysdes.github.io/todolist.html">基本仕様</a>に示す機能を段階的に実装し，実用的なタスク管理アプリケーションを構築していきます．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-タスクの作成編集削除"><a class="header" href="#07-タスクの作成編集削除">07: タスクの作成・編集・削除</a></h1>
<p>今回は以下の手順に従って<a href="https://cs-sysdes.github.io/todolist.html">要求仕様</a>に示された基本仕様 S-1.1 の実装を行います．</p>
<ol>
<li><a href="07_task_management.html#%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E8%A8%AD%E5%AE%9A">ルーティング設定</a></li>
<li><a href="07_task_management.html#%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E6%96%B0%E8%A6%8F%E7%99%BB%E9%8C%B2">タスクの新規登録</a></li>
<li><a href="07_task_management.html#%E6%97%A2%E5%AD%98%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E7%B7%A8%E9%9B%86">既存タスクの編集</a></li>
<li><a href="07_task_management.html#%E6%97%A2%E5%AD%98%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%89%8A%E9%99%A4">既存タスクの削除</a></li>
</ol>
<p><a href="06_todolist.html">前回</a>から引き続いて <a href="https://github.com/cs-sysdes/todolist.go">todolist.go</a> での実装を進めます．</p>
<h2 id="ルーティング設定"><a class="header" href="#ルーティング設定">ルーティング設定</a></h2>
<p>それぞれの機能について仮ルーティングを行います．</p>
<p>まず，タスクの新規登録について一般的な処理のフローを以下に示します．</p>
<p><img src="img/register_task.png" alt="Flow to register a new task" /></p>
<p>タスクを新規登録するため，Client-side アプリケーションは Server-side アプリケーションに対して登録フォームを要求します．
このリクエストは登録フォームという画面を表示させることを目的とするので，通常は GET リクエストになります．
このとき，Server-side アプリケーションの動作としては，登録フォームを備えた画面を返すことが期待されます．</p>
<p>ユーザは表示された登録フォームに登録するタスクの情報を入力し，Server-side アプリケーションへ送信します．
これは情報の送信を目的とするため，通常は POST リクエストになるでしょう．
Server-side アプリケーションは，受け取った情報から DB 内に新規タスクを保存し，完了したことを Client-side へ通知します．</p>
<p>以上より，タスクの新規登録には 1 つの GET メソッドと 1 つの POST メソッドを受け付けるルーティングが必要そうです．
「新たなタスク」に関連する処理なので，パスは /task/new などで良いでしょう．</p>
<hr />
<p>同様に，タスクの編集について一般的な処理のフローを示します．</p>
<p><img src="img/edit_task.png" alt="Flow to edit an existing task" /></p>
<p>タスクの新規登録フローとほとんど同じですが，編集作業は「特定のタスク」に対する操作なので，編集フォームを要求する最初の GET リクエストには編集対象を指定するための ID を指定できるようにするべきでしょう．
Server-side アプリケーションは Client-side からの編集フォームの表示要求に対し，指定されたタスクを DB から取得したうえでフォーム中にタスクの情報を埋め込んで返すことが期待されます．</p>
<p>編集後の情報送信はいつも通り POST リクエストで行います．
Server-side アプリケーションは，リクエストに従って DB 内データを更新し，完了通知を返信することが期待されます．</p>
<p>以上より，タスクの編集も 1 つの GET メソッドと 1 つの POST メソッドを受け付けるルーティングを設定することとします．
このとき，タスクの新規登録時とは異なり，タスクの編集フォーム取得のための GET リクエストはパラメータ (ID) を持つことになります．
「タスクの編集」に関連する処理なので，パスは /task/edit などとしましょう．
ただし，パラメータとしてタスクの ID を受け取るため，/task/edit/:id とする方が良さそうです．</p>
<hr />
<p>タスクの削除フローは，以下に示す通り先の 2 つより単純です．</p>
<p><img src="img/delete_task.png" alt="Flow to delete an existing task" /></p>
<p>Client-side アプリケーションは Server-side アプリケーションに削除したいタスクの ID を通知します．
Server-side アプリケーションは受け取った ID に該当するタスクを DB 上から削除し，処理の完了通知を返信します．</p>
<p>この操作では特に情報を送信することはないため，GET リクエストで削除指示を直接送ることとします．
また，パラメータとして ID を持つ「タスクの削除」に関連する処理なので，パスは /task/delete/:id で良いでしょう．</p>
<hr />
<p>以上の設計方針を素直に実装すると以下のようになります．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">    ...
    // タスクの新規登録
    engine.GET(&quot;/task/new&quot;, service.NotImplemented)
    engine.POST(&quot;/task/new&quot;, service.NotImplemented)
    // 既存タスクの編集
    engine.GET(&quot;/task/edit/:id&quot;, service.NotImplemented)
    engine.POST(&quot;/task/edit/:id&quot;, service.NotImplemented)
    // 既存タスクの削除
    engine.GET(&quot;/task/delete/:id&quot;, service.NotImplemented)
    ...
</code></pre>
<p>この仮ルーティングの設定は一般的な実装例であり，必ずしもこの通りに実装する必要はありません．
本資料ではこのルーティング設定に従って実装を進めますが，明確な目的や理由をもって独自のルーティングを行うことを妨げるものではありません．</p>
<div class="memo">
タスクの編集において，編集後の情報を POST メソッドで送信すると説明しましたが，実際は処理の内容を考えると <b>PUT</b> (あるいは <b>PATCH</b>) リクエストとする方が適切です．
また，タスクの削除においても本来は <b>DELETE</b> メソッドを使用する方が適切です．
しかしながら，HTML の form タグはメソッドとして GET か POST にしか対応しておらず，また HTML 単体では他に PUT や DELETE といったメソッドのリクエストを送信する手段がないため，ここでは POST リクエストとして実装しています．
どうしても PUT や DELETE でリクエストを送信したい場合は，一般に JavaScript の力を借りることになります．
</div>
<h2 id="タスクの新規登録"><a class="header" href="#タスクの新規登録">タスクの新規登録</a></h2>
<p>タスクの新規登録フローを再掲します (<a href="07_task_management.html#%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E8%A8%AD%E5%AE%9A">ルーティング設定</a>にて示したものと同じです)．</p>
<p><img src="img/register_task.png" alt="Flow to register a new task (re-post)" /></p>
<p>タスクの新規登録において Server-side アプリケーションに求められる処理は，1) 新規登録リクエストに対して登録フォームを返す，2) POST されたタスク情報から DB に新しいタスクを登録する，の 2 つです．
それぞれについて順に実装していきます．</p>
<p>これ以降，タスクの持つフィールドは初期実装を仮定して資料を進めます．
<a href="06_todolist.html#%E7%B7%B4%E7%BF%92%E5%95%8F%E9%A1%8C-6-3-%E7%99%BA%E5%B1%95%E7%9A%84%E5%86%85%E5%AE%B9">前回の練習問題 6-3</a> などで独自のフィールドを追加している場合は，それらについても入力欄を設定するなど，適宜資料の読み替えが必要となるので注意してください．</p>
<h3 id="新規登録フォーム"><a class="header" href="#新規登録フォーム">新規登録フォーム</a></h3>
<p>まずは新しいタスクの情報を入力するための登録画面を作成します．
以下に示すタスクの初期実装では，新規登録時にユーザが入力すべき項目は <code>Title</code> のみです．
その他のフィールドは，DB が自動的に適切な値を設定してくれます．</p>
<p><span class="filename">todolist.go/db/entity.go</span></p>
<pre><code class="language-go">type Task struct {
	ID        uint64    `db:&quot;id&quot;`
	Title     string    `db:&quot;title&quot;`
	CreatedAt time.Time `db:&quot;created_at&quot;`
	IsDone    bool      `db:&quot;is_done&quot;`
}
</code></pre>
<p>したがって，以下のような登録画面を作成することとします．
入力した情報は /task/new へ POST したいので，<code>&lt;form&gt;</code> タグの属性として <code>action=&quot;/task/new&quot;</code> および <code>method=&quot;POST&quot;</code> を指定しています．</p>
<p><span class="filename">todolist.go/views/form_new_task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;タスクの新規登録&lt;/h1&gt;
&lt;form action=&quot;/task/new&quot; method=&quot;POST&quot;&gt;
    &lt;label&gt;Title&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; required&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登録&quot;&gt;
    &lt;a href=&quot;/list&quot;&gt;&lt;button type=&quot;button&quot;&gt;戻る&lt;/button&gt;&lt;/a&gt;
&lt;/form&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>5 行目の <code>&lt;br&gt;</code> タグは改行をいれるためのタグです．
本来は <code>&lt;div&gt;</code> タグなどを用いて構造化した上で見た目を調整すべきですが，ここでは最低限の機能を最低限の見た目で提供するため，このように記述しています．</p>
<p>6 行目に配置した「登録」ボタンを押すと，<code>input[name=&quot;title&quot;]</code> フィールドに入力した値を Server へ POST します．
<code>input[name=&quot;title&quot;]</code> フィールドに付与されている <code>required</code> 属性は，このフィールドを空のまま送信できないよう制約を付けるものです．
7 行目に配置した「戻る」ボタンは単純に /task/list へのリンクとなっており，新規登録を中止してタスク一覧ページへ戻る機能を提供しています．</p>
<p><a href="06_todolist.html#%E7%B7%B4%E7%BF%92%E5%95%8F%E9%A1%8C-6-3-%E7%99%BA%E5%B1%95%E7%9A%84%E5%86%85%E5%AE%B9">練習問題 6-3</a> でタスクのフィールドに説明文を追加している場合は，以下のような <code>&lt;textarea&gt;</code> を form の子要素として 6 行目あたりに追加すると良いでしょう．</p>
<pre><code class="language-html">    &lt;label&gt;Description&lt;/label&gt;
    &lt;textarea name=&quot;description&quot;&gt;&lt;/textarea&gt;
</code></pre>
<p>/task/new への GET リクエストにはこの画面を返せばよいだけなので，以下のような関数 <code>service.NewTaskForm</code> を定義します．
表示する画面 todolist.go/views/form_new_task.html は <code>{{ template header . }}</code> によってページの &quot;Title&quot; パラメータを要求する点に注意してください．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func NewTaskForm(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;form_new_task.html&quot;, gin.H{&quot;Title&quot;: &quot;Task registration&quot;})
}
</code></pre>
<p>仮ルーティングの設定を更新 (下記 3 行目) し，Webブラウザから /task/new へアクセスしたときにタスクの新規登録フォームが表示されることを確認してください．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">    ...
    // タスクの新規登録
    engine.GET(&quot;/task/new&quot;, service.NewTaskForm)
    engine.POST(&quot;/task/new&quot;, service.NotImplemented)
    ...
</code></pre>
<p>このままでは URL を直接打ち込まないとタスクの新規登録ページへ進むことができないので，どこかのページに新規登録ページへのリンクを設置する必要があります．
今回は，/list で表示されるタスク一覧の上にリンクを設定することとしましょう．</p>
<p><span class="filename">todolist.go/views/task_list.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;List of tasks&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/task/new&quot;&gt;新規登録&lt;/a&gt;&lt;/p&gt;
{{ if not .Tasks }}
&lt;p&gt;登録データがありません．&lt;/p&gt;
{{ else }}
&lt;table&gt;
    ...
</code></pre>
<p>3 行目の <code>&lt;p&gt;&lt;a href=&quot;/task/new&quot;&gt;新規登録&lt;/a&gt;&lt;/p&gt;</code> が追加したコードになります．
これでタスクの一覧表示画面から新規登録画面へ遷移可能になりました．</p>
<h3 id="登録処理"><a class="header" href="#登録処理">登録処理</a></h3>
<p>タスクの新規登録画面を表示できたので，POST されたフォームデータから新規タスクを登録する関数 <code>service.RegisterTask</code> を実装します．
POST されたデータを受け取る部分，および，DB への接続を獲得する部分は，これまでの演習より以下の通り記述できることがわかります．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func RegisterTask(ctx *gin.Context) {
    // Get task title
    title, exist := ctx.GetPostForm(&quot;title&quot;)
    if !exist {
        Error(http.StatusBadRequest, &quot;No title is given&quot;)(ctx)
        return
    }
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Create new data with given title on DB
    ...
</code></pre>
<p>DB へのデータの登録は INSERT 文で行うことができますが，<code>sqlx.DB</code> には <code>Insert</code> メソッドがありません．
したがって，<code>sqlx.DB.Exec</code> メソッドを使用して INSERT 文を発行します．</p>
<pre><code class="language-go">    ...
    // Create new data with given title on DB
    result, err := db.Exec(&quot;INSERT INTO tasks (title) VALUES (?)&quot;, title)
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Render status
    ...
</code></pre>
<p>ここまでで POST された情報に基づく新しいタスクを DB へ登録する処理が完了しました．
最後に処理の完了を通知する部分ですが，単に成功したことだけを通知するページにあまり意味はないので，登録したタスク自体を表示するページへ遷移させましょう．
つまり，/task/:id へ<strong>リダイレクト</strong>することを考えます．</p>
<p>ページのリダイレクトはよく使う機能なので，<code>gin.Context.Redirect</code> としてメソッド化されています．
また，このような特定の処理を行った結果として対応する別のページ (リソース) へリダイレクトする場合には <code>302 Found</code> のステータスが適当です．
したがって，いまリダイレクトする先のパスを変数 <code>path</code> で与えるとした場合，以下のように実装できます．</p>
<pre><code class="language-go">    ...
    // Render status
    path := ...
    ctx.Redirect(http.StatusFound, path)
}
</code></pre>
<p>さて，問題はこの変数 <code>path</code> をどのように設定するかです．
リダイレクトしたい先のパスは /task/:id であり，:id の部分は今さっき登録した新しいタスクの ID となっているべきです．
今さっき登録した新しいタスクの ID は DB が自動で割当てているため，これを取得する必要があります．</p>
<p>であれば，もう一度 DB にアクセスして最新の ID を取得して…という方法は残念ながら<strong>正しく動かない可能性があります</strong>．
たとえば，2 つ以上のタスクがほぼ同時に登録された場合，1 つの INSERT 文とそれに対応する ID 取得処理がアトミックに実行されれば問題ありませんが，それらの間に別のINSERT 文の実行が挟まってしまった場合，取得できる ID は最後に登録されたタスクの ID となってしまうため，1 つめの INSERT 文で登録されたタスクの ID  ではなくなります．</p>
<p>一部の DB アプリケーションはこうした要求に対応するため，特定のクエリによって挿入されたデータの ID を返す機能を持っています．
Go言語 の database/sql パッケージはこうした機能に対応できるよう設計されており，MySQL を使用する場合は，<code>sql.Result.LastInsertId</code> メソッドによって対応するデータの ID を取得可能です．
<code>sql.Result</code> は先ほど <code>result, err := db.Exec(...)</code> にて <code>result</code> として返されているため，<code>result.LastInsertId()</code> とすることで ID を取得します．</p>
<p><code>sql.Result.LastInsertId</code> は失敗する可能性のある処理 (<code>err</code> を返すメソッド) です．
成功した場合 (<code>err == nil</code> の場合) には取得した ID に基づいて /task/:id へ遷移するよう実装します．
一方で，失敗した場合 (<code>err != nil</code> の場合) には ID を取得することができないので，あきらめて /list へ戻ることとします．</p>
<p>以上をプログラムとして実装すると以下のようになります．
3 行目の条件分岐は，エラーがない場合に実行したい処理なので，いつもの <code>err != nil</code> ではなく <code>err == nil</code> であることに注意してください．</p>
<pre><code class="language-go">    // Render status
    path := &quot;/list&quot;  // デフォルトではタスク一覧ページへ戻る
    if id, err := result.LastInsertId(); err == nil {
        path = fmt.Sprintf(&quot;/task/%d&quot;, id)   // 正常にIDを取得できた場合は /task/&lt;id&gt; へ戻る
    }
    ctx.Redirect(http.StatusFound, path)
}
</code></pre>
<p>ここまでをまとめると，<code>service.RegisterTask</code> 関数は以下のように実装できます．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func RegisterTask(ctx *gin.Context) {
    // Get task title
    title, exist := ctx.GetPostForm(&quot;title&quot;)
    if !exist {
        Error(http.StatusBadRequest, &quot;No title is given&quot;)(ctx)
        return
    }
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Create new data with given title on DB
    result, err := db.Exec(&quot;INSERT INTO tasks (title) VALUES (?)&quot;, title)
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Render status
    path := &quot;/list&quot;  // デフォルトではタスク一覧ページへ戻る
    if id, err := result.LastInsertId(); err == nil {
        path = fmt.Sprintf(&quot;/task/%d&quot;, id)   // 正常にIDを取得できた場合は /task/&lt;id&gt; へ戻る
    }
    ctx.Redirect(http.StatusFound, path)
}
</code></pre>
<p>ルーティング設定を更新し，タスクが正常に登録できることを確認してください．</p>
<div class="memo">
<code class="hljs">sql.Result.LastInsertId</code> メソッドは，使用する DB アプリケーションによっては対応していません．
今回は対応している MySQL を使用したため，このメソッドを利用して簡単に ID を取得できましたが，MySQL と並んで有名な PostgreSQL を使用した場合にはこのメソッドを利用できません．
代わりに PostgreSQL には INSERT 後のデータを直接 INSERT 文から返す方法があり，それを使用することで同様の処理は実行可能です．
</div>
<h2 id="既存タスクの編集"><a class="header" href="#既存タスクの編集">既存タスクの編集</a></h2>
<p>既存タスクの編集フローを再掲します (<a href="07_task_management.html#%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E8%A8%AD%E5%AE%9A">ルーティング設定</a>にて示したものと同じです)．</p>
<p><img src="img/edit_task.png" alt="Flow to edit an existing task (re-post)" /></p>
<p>既存タスクの編集において Server-side アプリケーションに求められる処理は，1) 編集リクエストに応じて対応するタスクの編集フォームを返す，2) POST されたタスク情報から DB 内のデータを更新する，の 2 つです．
それぞれについて順に実装していきます．</p>
<h3 id="編集フォーム"><a class="header" href="#編集フォーム">編集フォーム</a></h3>
<p>編集フォーム画面を取得するためのリンクを作成します．
今回はタスクの個別表示ページに編集ボタンを追加する方法をとります．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Task {{ .ID }}&lt;/h1&gt;
&lt;dl&gt;
    &lt;dt&gt;Title&lt;/dt&gt;
    &lt;dd&gt;{{ .Title }}&lt;/dd&gt;
    &lt;dt&gt;Created at&lt;/dt&gt;
    &lt;dd&gt;{{ .CreatedAt }}&lt;/dd&gt;
    &lt;dt&gt;Status&lt;/dt&gt;
    &lt;dd&gt;&lt;input type=&quot;checkbox&quot; {{ if .IsDone }}checked {{ end }}disabled/&gt;済&lt;/dd&gt;
&lt;/dl&gt;
&lt;a href=&quot;/list&quot;&gt;&lt;button type=&quot;button&quot;&gt;リストへ戻る&lt;/button&gt;&lt;/a&gt;
&lt;a href=&quot;/task/edit/{{ .ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;編集&lt;/button&gt;&lt;/a&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>これは<a href="06_todolist.html#%E3%82%BF%E3%82%B9%E3%82%AF%E8%A1%A8%E7%A4%BA%E7%94%BB%E9%9D%A2%E3%81%AE%E4%BD%9C%E6%88%90">前回作成したタスク表示画面</a>に対し，12 行目に配置した編集ボタンを追加したものです．</p>
<p>次に，編集フォーム画面を作成します．
編集フォームはタスク表示画面や新規登録フォームとほとんど同じように実装できます．
ただし，新規登録フォームではタスクの Title のみ入力可能でしたが，編集フォームでは Title に加えてタスクの完了状態も編集できる必要があります．
ここでは編集フォーム画面を todolist.go/views/form_edit_task.html として以下のように実装するととします．</p>
<p><span class="filename">todolist.go/views/form_edit_task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Task {{ .Task.ID }}: edit&lt;/h1&gt;
&lt;form action=&quot;/task/edit/{{ .Task.ID }}&quot; method=&quot;POST&quot;&gt;
    &lt;label&gt;Title&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;{{ .Task.Title }}&quot; required&gt;
    &lt;br&gt;
    &lt;input type=&quot;radio&quot; name=&quot;is_done&quot; value=&quot;t&quot; {{ if .Task.IsDone }}checked{{ end }}&gt;&lt;label&gt;完了&lt;/label&gt;
    &lt;input type=&quot;radio&quot; name=&quot;is_done&quot; value=&quot;f&quot; {{ if not .Task.IsDone }}checked{{ end }}&gt;&lt;label&gt;未完了&lt;/label&gt;
    &lt;/br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登録&quot;&gt;
    &lt;a href=&quot;/task/{{ .Task.ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;戻る&lt;/button&gt;&lt;/a&gt;
&lt;/form&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>4行目，<code>input[name=&quot;title&quot;]</code> で Title の入力フィールを作成するのは新規登録画面と同じですが，編集時にはすでに設定された Title が存在するため，<code>value=&quot;{{ .Task.Title }}&quot;</code> として登録済みの値をフィールド内に挿入した状態でフォームを返しています．</p>
<p>6, 7 行目はタスクの完了状態をラジオボタンで表現しています．
<code>input[type=&quot;radio&quot;]</code> は <code>name</code> 属性が同じ複数の入力フィールドを自動的にグループ化し，排他的に選択できるようになっています．
<code>checked</code> 属性をつけることで選択された状態にできるため，ここでは編集前のタスクの状態に応じて適切なものに <code>checked</code> 属性を設定しています．</p>
<p>9, 10 行目の処理は新規登録画面と同様です．
ただし，ここでは「戻る」ボタンの遷移先として /task/:id を指定しています．</p>
<p>この画面を返す処理を行う関数 <code>service.EditTaskForm</code> を実装します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func EditTaskForm(ctx *gin.Context) {
    // ID の取得
    id, err := strconv.Atoi(ctx.Param(&quot;id&quot;))
    if err != nil {
        Error(http.StatusBadRequest, err.Error())(ctx)
        return
    }
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Get target task
    var task database.Task
    err = db.Get(&amp;task, &quot;SELECT * FROM tasks WHERE id=?&quot;, id)
    if err != nil {
        Error(http.StatusBadRequest, err.Error())(ctx)
        return
    }
    // Render edit form
    ctx.HTML(http.StatusOK, &quot;form_edit_task.html&quot;,
        gin.H{&quot;Title&quot;: fmt.Sprintf(&quot;Edit task %d&quot;, task.ID), &quot;Task&quot;: task})
}
</code></pre>
<p>ルーティング設定を更新し，動作確認をします．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">    ...
    // 既存タスクの編集
    engine.GET(&quot;/task/edit/:id&quot;, service.EditTaskForm)
    engine.POST(&quot;/task/edit/:id&quot;, service.NotImplemented)
    ...
</code></pre>
<p>確認点は，以下の通りです．</p>
<ol>
<li>個別のタスクを表示したときに「編集」ボタンが表示される</li>
<li>「編集」ボタンを押すと編集フォームが表示される</li>
<li>編集フォーム上で「更新」を押すと，処理が実装されていないため，エラーページが表示される</li>
</ol>
<h3 id="更新処理"><a class="header" href="#更新処理">更新処理</a></h3>
<p>タスクの更新処理はタスクの新規登録処理とほとんど同じです．
したがって，更新処理の実装は練習問題とします．</p>
<h5 id="練習問題-7-1"><a class="header" href="#練習問題-7-1">練習問題 7-1</a></h5>
<p>新規登録処理を行う <code>service.RegisterTask</code> 関数を参考に，更新処理を行う関数 <code>service.UpdateTask</code> を実装し，ルーティング設定を修正したうえで動作確認をしてください．</p>
<p>～実装のヒント～</p>
<ul>
<li>更新対象の ID は <code>gin.Context.Param</code> で取得できます．</li>
<li>編集フォームから POST されるデータは，<code>&quot;title&quot;</code> および <code>&quot;is_done&quot;</code> の 2 つです．これらの key に対応する値を <code>gin.Context.GetPostForm</code> メソッドで取得します．
<ul>
<li><code>&quot;is_done&quot;</code> に対応する value は，<code>strconv.ParseBool</code> 関数で bool 値に変換できます．</li>
</ul>
</li>
<li>DB 内に存在するデータの更新は UPDATE 文によって行います．
<ul>
<li>UPDATE 文は INSERT 文と同様に <code>sql.DB.Exec</code> メソッドで実行します．</li>
<li>WHERE 句で更新対象の ID を指定することで，対象のタスクのみをアップデートします．</li>
</ul>
</li>
</ul>
<h2 id="既存タスクの削除"><a class="header" href="#既存タスクの削除">既存タスクの削除</a></h2>
<p>既存タスクの削除フローを再掲します (<a href="07_task_management.html#%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E8%A8%AD%E5%AE%9A">ルーティング設定</a>にて示したものと同じです)．</p>
<p><img src="img/delete_task.png" alt="Flow to delete an existing task (re-post)" /></p>
<p>既存タスクの削除において Server-side アプリケーションに求められる処理は，削除リクエストに応じて対応するタスクを DB 上から削除することです．
一般にデータの削除を行う方法には，1) データを完全に消去する方法，2) データに削除フラグを立てる方法，の 2 つが考えられます．
ここでは 1) データを完全に消去する方法で既存タスクの削除処理を実装します．</p>
<h3 id="削除リクエストの送信"><a class="header" href="#削除リクエストの送信">削除リクエストの送信</a></h3>
<p>はじめに，削除リクエストを送信する方法を考えます．
削除リクエストは /task/delete/:id への GET リクエストとしてルーティングされているため，<code>form[method=&quot;GET&quot;]</code> あるいは <code>&lt;a&gt;</code> タグでリクエストを送信することができます．
今回は簡単のため <code>&lt;a&gt;</code> タグによる通常のページリクエストとして送信することとします．</p>
<p><a href="07_task_management.html#%E7%B7%A8%E9%9B%86%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0">編集フォーム</a>をリクエストしたときと同様に，タスク表示ページから削除リクエストを飛ばせるようにしましょう．
すなわち，todolist.go/views/task.html に削除リクエストを送信するためのボタンを追加します．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Task {{ .ID }}&lt;/h1&gt;
&lt;dl&gt;
    &lt;dt&gt;Title&lt;/dt&gt;
    &lt;dd&gt;{{ .Title }}&lt;/dd&gt;
    &lt;dt&gt;Created at&lt;/dt&gt;
    &lt;dd&gt;{{ .CreatedAt }}&lt;/dd&gt;
    &lt;dt&gt;Status&lt;/dt&gt;
    &lt;dd&gt;&lt;input type=&quot;checkbox&quot; {{ if .IsDone }}checked {{ end }}disabled/&gt;済&lt;/dd&gt;
&lt;/dl&gt;
&lt;a href=&quot;/list&quot;&gt;&lt;button type=&quot;button&quot;&gt;リストへ戻る&lt;/button&gt;&lt;/a&gt;
&lt;a href=&quot;/task/edit/{{ .ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;編集&lt;/button&gt;&lt;/a&gt;
&lt;a href=&quot;/task/delete/{{ .ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;削除&lt;/button&gt;&lt;/a&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>13 行目に削除ボタンを追加しています．
<code>&lt;button&gt;</code> タグ自体にはリクエストの送信機能がないため，<code>&lt;a&gt;</code> タグで囲って GET リクエストを送信できるようにしています．</p>
<h3 id="指定されたタスクの削除処理"><a class="header" href="#指定されたタスクの削除処理">指定されたタスクの削除処理</a></h3>
<p>リクエストを受けて指定されたタスクを削除する処理を <code>service.DeleteTask</code> 関数として実装します．
処理の手順としては，以下の通りになります．
タスクの新規登録および編集の際には，タスクページへのリダイレクトを設定しましたが，タスクの削除では遷移先ページとなるべきタスクページ (/task/:id) が存在しないため，タスクの一覧ページ (/list) へ戻るようにしています．</p>
<ol>
<li>削除リクエストは /task/delete/:id への GET リクエストなので，削除する対象のタスクの ID をパラメータとして取得</li>
<li>DB へ削除クエリを送信</li>
<li>/list へ戻る (Redirect)</li>
</ol>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">func DeleteTask(ctx *gin.Context) {
    // ID の取得
    id, err := strconv.Atoi(ctx.Param(&quot;id&quot;))
    if err != nil {
        Error(http.StatusBadRequest, err.Error())(ctx)
        return
    }
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    // Delete the task from DB
    _, err = db.Exec(&amp;task, &quot;DELETE FROM tasks WHERE id=?&quot;, id)
    if err != nil {
        Error(http.StatusInternalServerError, err.Error())(ctx)
        return
    }
    // Redirect to /list
    ctx.Redirect(http.StatusFound, &quot;/list&quot;)
}
</code></pre>
<p>ルーティングを更新し，動作確認を行なってみましょう．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">    ...
    // 既存タスクの削除
    engine.GET(&quot;/task/delete/:id&quot;, service.DeleteTask)
    ...
</code></pre>
<h3 id="発展削除リクエスト送信時に確認画面を表示"><a class="header" href="#発展削除リクエスト送信時に確認画面を表示">【発展】削除リクエスト送信時に確認画面を表示</a></h3>
<p><strong>この項目は JavaScript の記述を必要とする発展的内容です．必ずしも実装する必要はありません．</strong></p>
<p>削除リクエストを送信してタスクを削除することが可能になりましたが，現状では削除ボタンを押すと即座に削除処理が実行されてしまうためユーザに対してやや不親切です．
実際，多くの実用的なアプリケーションでは，データの削除など重要な処理の実行を行う際には<strong>確認ダイアログ</strong>を表示し，確認がとれてはじめて処理を実行するような仕組みが提供されています．</p>
<p>ここではそのような確認ダイアログを Client-side アプリケーションである Web ブラウザ上で表示し，確認作業を行なった上で削除リクエストを送信する方法を実装します．
Web ブラウザ上での処理であるため，当然 Server-side アプリケーションの側で情報を受け取って何か処理をして結果を返すなどという処理はできません．
確認作業を Web ブラウザ上で完結させるため，JavaScript を用いて HTML 文書中に処理の記述を行う必要があります．
HTML 文書中に処理を記述するため，ここでは todolist.go/views/task.html のみを変更して対処することとします．</p>
<p>まずは，削除ボタンを押したときに即座に GET リクエストを送信してしまう現在の動作を修正します．
todolist.go/views/task.html を開き，13 行目に追加した削除ボタンを囲んでいる <code>&lt;a&gt;</code> タグを削除します．
代わりに，<code>&lt;button&gt;</code> タグに <code>onclick</code> 属性を設定し，クリックされたときに対象の ID を引数として <code>confirm_delete</code> 関数を呼び出すよう設定します．
ここまでの修正を施した状態が以下のコードになります．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Task {{ .ID }}&lt;/h1&gt;
&lt;dl&gt;
    &lt;dt&gt;Title&lt;/dt&gt;
    &lt;dd&gt;{{ .Title }}&lt;/dd&gt;
    &lt;dt&gt;Created at&lt;/dt&gt;
    &lt;dd&gt;{{ .CreatedAt }}&lt;/dd&gt;
    &lt;dt&gt;Status&lt;/dt&gt;
    &lt;dd&gt;&lt;input type=&quot;checkbox&quot; {{ if .IsDone }}checked {{ end }}disabled/&gt;済&lt;/dd&gt;
&lt;/dl&gt;
&lt;a href=&quot;/list&quot;&gt;&lt;button type=&quot;button&quot;&gt;リストへ戻る&lt;/button&gt;&lt;/a&gt;
&lt;a href=&quot;/task/edit/{{ .ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;編集&lt;/button&gt;&lt;/a&gt;
&lt;button type=&quot;button&quot; onclick=&quot;confirm_delete({{ .ID }})&quot;&gt;削除&lt;/button&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>ここまでは削除ボタンを押したときに特定の関数を呼び出す仕組みの実装になります．
したがって，次は呼び出される関数を JavaScript で記述していきます．</p>
<p>JavaScript を HTML 文書中に記述するには，<code>&lt;script&gt;</code> タグを使用します．
<code>&lt;script&gt;</code> タグには，内部に記述されたものについて解釈の方法を指定する <code>type</code> 属性があり，JavaScript のプログラムとして解釈してほしい場合には <code>type=&quot;text/javascript&quot;</code> を指定します．
todolist.go/views/task.html に <code>&lt;script&gt;</code> タグを配置して <code>confirm_delete</code> 関数を定義します．
ここではとりあえずの動作確認として，削除ボタンが押されたことを通知するポップアップを出してみます．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">...
&lt;a href=&quot;/task/edit/{{ .ID }}&quot;&gt;&lt;button type=&quot;button&quot;&gt;編集&lt;/button&gt;&lt;/a&gt;
&lt;button type=&quot;button&quot; onclick=&quot;confirm_delete({{ .ID }})&quot;&gt;削除&lt;/button&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const confirm_delete = (id) =&gt; {
        alert(`Task ${id} の削除ボタンが押されました！`);
    }
&lt;/script&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>この状態で動作確認を行ってみましょう．
適当なタスクを表示し，削除ボタンを押したときに通知が表示されれば成功です．
使用環境によっては JavaScript が有効化されていない場合がありますので，うまく動作しない場合は Web ブラウザの設定から JavaScript が有効化されているかを確認してください．</p>
<p>それでは実際に確認画面を表示し，確認が取れた場合のみ削除リクエストを送信する処理を記述します．
JavaScirpt で確認画面を表示するには，<code>window.confirm</code> 関数を使用します．
<code>window.confirm</code> は通知と共に「OK」または「キャンセル」のボタンを表示し，OK が押された場合は <code>true</code>，キャンセルが押された場合は <code>false</code> を返す関数です．
なお，それぞれのボタンの文言は環境によって異なりますので，適宜読み替えてください．</p>
<p>確認が取れた場合のみ削除リクエストを送信するには，<code>window.confirm</code> 関数の戻り値によって条件分岐し，戻り値が <code>true</code> の場合のみリクエストを送信します．
パスを指定して GET リクエストを送信するには，<code>location.href</code> フィールドの書き変えを行うのが一般的ですので，今回の場合は <code class="hljs">location.href=`/task/delete/${id}`</code> と記述することになります．</p>
<p>まとめると，以下のような実装になります．</p>
<p><span class="filename">todolist.go/views/task.html</span></p>
<pre><code class="language-html">...
&lt;script type=&quot;text/javascript&quot;&gt;
    const confirm_delete = (id) =&gt; {
        if(window.confirm(`Task ${id} を削除します．よろしいですか？`)) {
            location.href = `/task/delete/${id}`;
        }
    }
&lt;/script&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>このままでも目的とする動作は実現できていますが，せっかくなのでもう一段階発展した実装を説明します．</p>
<p><code>&lt;script&gt;</code> タグはここまでで使用したようにタグ内にプログラムを直接記述して有効化する機能のほかに，外部ファイルをロードして有効化する機能があります．
たとえば，todolist.go/views/_header.html を参照すると，以下のような記述があります．</p>
<p><span class="filename">todolist.go/views/_header.html</span></p>
<pre><code class="language-html">{{ define &quot;header&quot; }}
&lt;!DOCTYPE html&gt;
    ...
    &lt;script type=&quot;text/javascript&quot; src=&quot;/assets/script.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
{{ end }}
</code></pre>
<p>これは /assets/script.js というパスで指定されるファイルを読み込む設定です．
この記述によって，このアプリケーションでは todolist.go/assets/script.js が自動で読み込まれるようになっています．
したがって，先ほど todolist.go/views/task.html 内に記述した JavaScript のコードをそのまま todolist.go/assets/script.js に移動することで，HTML 文書と JavaScript のコードを分離することができます．
todolist.go/assets/script.js は JavaScript のプログラムファイルなので，<code>&lt;script&gt;</code> タグの記述は不要です．</p>
<p><span class="filename">todolist.go/assets/script.js</span></p>
<pre><code class="language-js">const confirm_delete = (id) =&gt; {
    if(window.confirm(`Task ${id} を削除します．よろしいですか？`)) {
        location.href = `/task/delete/${id}`;
    }
}

const confirm_update = (id) =&gt; {
    // 練習問題 7-2
}
</code></pre>
<h5 id="練習問題-7-2"><a class="header" href="#練習問題-7-2">練習問題 7-2</a></h5>
<p>タスクの編集画面には編集内容を確定し送信するボタンが存在します．
こちらも既存のタスクの内容を書き換えてしまう操作であるため，確認ダイアログを出す方が親切です．
練習問題として JavaScript で <code>confirm_update</code> 関数を実装し，タスクの編集画面における送信ボタンに対し確認ダイアログを設置してみましょう．</p>
<h2 id="まとめ-6"><a class="header" href="#まとめ-6">まとめ</a></h2>
<p>今回はタスク管理アプリケーションとして必要な<a href="https://cs-sysdes.github.io/todolist.html">基本仕様 S-1.1</a> を実装しました．
発展的内容として JavaScript で確認ダイアログを表示する方法も扱いましたが，これは基本仕様では要求されていない機能なので実装ができていなくても大丈夫です．</p>
<p>次回は基本仕様 S-1.2 の検索機能を実装する予定です．</p>
<p>今回の内容は以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="08-検索機能"><a class="header" href="#08-検索機能">08: 検索機能</a></h1>
<p>今回は以下の手順に従って<a href="https://cs-sysdes.github.io/todolist.html">要求仕様</a>に示された基本仕様 S-1.2 の実装を行います．</p>
<ol>
<li>検索フォームの設置</li>
<li>検索処理の追加</li>
</ol>
<p>これまでは新たなページを作成し，ルーティング設定を行なった上で対応する処理を実装する手順で機能拡張を行なってきました．
今回は既存のページにキーワード検索用のフォームを設置し，パスパラメータを用いて検索クエリをサーバへ送信する方法で検索機能の実装を行います．</p>
<p>ここでは特に<strong>タイトルに特定の文字列が含まれるタスク</strong>を検索対象として検索機能を実装します．
すなわち，アプリケーションの動作としてユーザが入力したキーワードをタイトルに含むタスクのみを絞り込んで表示する機能を提供します．</p>
<h2 id="検索フォームの設置"><a class="header" href="#検索フォームの設置">検索フォームの設置</a></h2>
<p>検索にヒットしたタスクは一覧表示されることが期待されるので，検索フォームもタスクの一覧表示画面に配置されていると良さそうです．
したがって todolist.go/views/task_list.html に検索フォームを追加することとします．</p>
<p><span class="filename">todolist.go/views/task_list.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;List of tasks&lt;/h1&gt;
&lt;form action=&quot;/list&quot; method=&quot;GET&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;kw&quot; value=&quot;{{ .Kw }}&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;検索&quot;&gt;
&lt;/form&gt;
&lt;p&gt;&lt;a href=&quot;/task/new&quot;&gt;新規登録&lt;/a&gt;&lt;/p&gt;
{{ if not .Tasks }}
&lt;p&gt;登録データがありません．&lt;/p&gt;
{{ else }}
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;ID&lt;/th&gt;
        &lt;th&gt;タイトル&lt;/th&gt;
        &lt;th&gt;登録日&lt;/th&gt;
        &lt;th&gt;状態&lt;/th&gt;
    &lt;/tr&gt;
    {{ range $task := .Tasks }}
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&quot;/task/{{ $task.ID }}&quot;&gt;{{ $task.ID }}&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;{{ $task.Title }}&lt;/td&gt;
        &lt;td&gt;{{ $task.CreatedAt }}&lt;/td&gt;
        &lt;td&gt;{{ if $task.IsDone }}済{{ end }}&lt;/td&gt;
    &lt;/tr&gt;
    {{ end }}
&lt;/table&gt;
{{ end }}
{{ template &quot;footer&quot; }}
</code></pre>
<p>3～6 行目の <code>&lt;form&gt;</code> タグが今回追加した検索フォームです．
それ以外の部分はこれまでの実装から変更していません．</p>
<p>3 行目より，設置した検索フォームは GET リクエストを送信します．
このフォームは 4 行目の <code>&lt;input&gt;</code> タグで検索キーワードを受け取り，入力されたキーワードを <code>kw=&lt;入力されたキーワード&gt;</code> の形式で<strong>リクエストパス</strong>に載せます．
したがって，たとえば「test」などと入力して検索ボタンを押した場合，/list?kw=test をパスとする GET リクエストが送信されることになります．</p>
<p>キーワード入力欄の <code>&lt;input&gt;</code> タグには，value 属性として <code>value=&quot;{{ .Kw }}&quot;</code> を設定しています．
これは検索処理後の画面遷移時に，指定された検索キーワードを入力欄に残しておくために必要です．
この記述は必須ではありませんが，記述しない場合は画面遷移後にキーワード入力欄が空になってしまうため，やや動作としてわかりづらくなります．</p>
<p>検索フォームを設置したので，次に検索処理を実装します．</p>
<h2 id="検索処理の追加"><a class="header" href="#検索処理の追加">検索処理の追加</a></h2>
<p>設置した検索フォームは本質的に /list に対して GET リクエストを送信するものなので，対応する関数 <code>service.TaskList</code> を編集します．
検索機能を実現するために必要な追加処理は以下の 2 つです．</p>
<ol>
<li>パスパラメータから検索キーワードを取得</li>
<li>タイトルに検索キーワードを含むタスクのみを絞り込んで表示</li>
</ol>
<p>Gin フレームワークを使用する場合，<code>gin.Context.Query</code> メソッドを使用することでリクエストパスからパスパラメータを取得可能です．
今回は &quot;kw&quot; を key として検索キーワードが渡されるため，<code>ctx.Query(&quot;kw&quot;)</code> を呼び出すことで <code>TaskList</code> 関数内で検索キーワードを受け取ります．</p>
<p>タイトルに検索キーワードを含むタスクのみを絞り込むには，i) DB からタスクを全件取得してから条件に一致するタスクのみを抽出する方法，ii) DB から条件に一致するデータのみを取得する方法，の 2 通りが考えられます．
前者 (i) の方法でも悪くはないですが，DB はそもそもこうした操作を得意とするアプリケーションなので，一般には後者 (ii) の方法がより効率的です．
MySQL などにおいてデータの取得条件として特定の文字列を含むもののみを抽出するには &quot;LIKE&quot; 句を使用します．</p>
<p><code>service.TaskList</code> 関数に施す具体的な修正を以下に示します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">// TaskList renders list of tasks in DB
func TaskList(ctx *gin.Context) {
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}

    // Get query parameter
    kw := ctx.Query(&quot;kw&quot;)

	// Get tasks in DB
	var tasks []database.Task
    switch {
    case kw != &quot;&quot;:
        err = db.Select(&amp;tasks, &quot;SELECT * FROM tasks WHERE title LIKE ?&quot;, &quot;%&quot; + kw + &quot;%&quot;)
    default:
        err = db.Select(&amp;tasks, &quot;SELECT * FROM tasks&quot;)
    }
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}

	// Render tasks
	ctx.HTML(http.StatusOK, &quot;task_list.html&quot;, gin.H{&quot;Title&quot;: &quot;Task list&quot;, &quot;Tasks&quot;: tasks, &quot;Kw&quot;: kw})
}
</code></pre>
<p>修正版の <code>service.TaskList</code> 関数では，11 行目でパスパラメータを取得し，指定された検索条件に応じて 15～20 行目で適切な検索クエリを DB へ発行しています．
また，27 行目の画面表示において，変数 <code>kw</code> を検索フォームに表示するために追加で指定しています．</p>
<p>17 行目の条件付きデータ取得クエリでは，<code>WHERE title LIKE '%&lt;kw&gt;%'</code> を指定することで，&quot;&lt;kw&gt;&quot; を部分文字列としてタイトルに含むタスクのみを抽出しています．
キーワード指定時の '%' は任意の 0 文字以上の文字列にマッチする特殊文字です．
'%' を指定し忘れると，部分文字列ではなく正確に &quot;&lt;kw&gt;&quot; にマッチするタイトルを持つタスクのみしか拾えなくなる点に注意して下さい．</p>
<div class="memo">
ここで示した修正版 <code class="hljs">service.TaskList</code> 関数では，検索キーワードの有無によってクエリを変更していますが，実は検索キーワードの有無に依存せず 17 行目の記述のみでも問題なく動作します．
というのも，今回は検索キーワードをタイトルに含むタスクのみを抽出するクエリであり，検索キーワードが指定されない場合，すなわち変数 <code class="hljs">kw</code> が空文字の場合には，条件節が <code class="hljs">... WHERE title LIKE '%%'</code> となり，これはどのような文字列に対してもマッチします．
したがって，最終的な結果としては条件を何も指定しない場合と同様になります．
<p>一方で，以下の練習問題のように複数の検索条件を設定する場合には，検索条件の設定に応じて処理を分岐する必要性が出てくるため，ここでは敢えて switch 文による条件分岐を記述しています．</p>
</div>
<h4 id="練習問題-8-期末レポートに関連"><a class="header" href="#練習問題-8-期末レポートに関連">練習問題 8 (期末レポートに関連)</a></h4>
<p>「完了済みのタスク」や「未完了のタスク」のみを個別に指定する方法を考え，実装してください．
なお，検索フォームに新たなフィールドを付け加えても構いません．</p>
<h2 id="まとめ-7"><a class="header" href="#まとめ-7">まとめ</a></h2>
<p>今回は<a href="https://cs-sysdes.github.io/todolist.html">基本仕様 S-1.2</a> として要求される検索機能を実装しました．</p>
<p>次回から 2 回に分けてログイン機能およびアカウント管理機能を実装し，要求されている基本仕様の実装を一通り完了する予定です．</p>
<p>今回の内容は短いですが以上になります．
お疲れさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-アカウント管理機能-1"><a class="header" href="#09-アカウント管理機能-1">09: アカウント管理機能 (1)</a></h1>
<p>演習資料最後の 2 回は<a href="https://cs-sysdes.github.io/todolist.html">仕様書</a>に示す基本仕様 S-1.3 および S-1.4 について実装を進めます．</p>
<p>今回は特に以下の手順でアカウント登録機能について実装します．</p>
<ol>
<li>ユーザデータの定義</li>
<li>ユーザ登録機能</li>
<li>エラー表示</li>
</ol>
<h2 id="ユーザデータの定義"><a class="header" href="#ユーザデータの定義">ユーザデータの定義</a></h2>
<p>要求仕様より，<strong>ユーザは「アカウント名」により識別</strong>され，<strong>「パスワード」によって認証</strong>されることになります．
したがって，アプリケーションは少なくとも<strong>アカウント名</strong>と<strong>パスワード</strong>のペアを内部に保持している必要があります．
これらの情報を以降では<strong>ユーザ情報</strong>と呼びます．</p>
<p>はじめにアプリケーションが保持するユーザ情報のためのテーブルを DB 内に定義します．</p>
<p><span class="filename">todolist.go/docker/db/sql/01_create_tables.sql</span></p>
<pre><code class="language-sql">...
DROP TABLE IF EXISTS `users`;

CREATE TABLE `users` (
    `id`         bigint(20) NOT NULL AUTO_INCREMENT,
    `name`       varchar(50) NOT NULL UNIQUE,
    `password`   binary(32) NOT NULL,
    `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) DEFAULT CHARSET=utf8mb4;
</code></pre>
<p>ユーザ名はアカウントの識別に使用するため，重複するユーザ名の登録は禁止したい要求があります．
したがって，ユーザ名のためのフィールド <code>name</code> には UNIQUE 制約を付けています．</p>
<p>パスワードを平文のままシステム内に保存することはセキュリティリスクとなるため，ここではハッシュ化した上でバイナリデータとして保存することとします．
ハッシュ化には暗号学的ハッシュ関数の一つである <a href="https://en.wikipedia.org/wiki/SHA-2">SHA256アルゴリズム</a> を採用するため，256 bit (= 32 byte) のバイナリデータを保持するための領域 <code>binary(32)</code> を割当てます．</p>
<p>DB のテーブル定義を更新したため，更新を反映させるために Docker コンテナを初期化する必要があります．</p>
<p>次に，Go言語プログラム内でユーザ情報を扱うためのデータ構造を定義します．
フィールドの型とタグをテーブル定義に合わせて，構造体 <code>User</code> を実装します．</p>
<p><span class="filename">todolist.go/db/entity.go</span></p>
<pre><code class="language-go">...
type User struct {
    ID        uint64    `db:&quot;id&quot;`
    Name      string    `db:&quot;name&quot;`
    Password  []byte    `db:&quot;password&quot;`
}
</code></pre>
<p>DB 内でバイナリデータとして保持するデータは，Go言語上では <code>[]byte</code> 型として受け渡しを行います．
DB 内では固定長データですが，プログラムでは可変長データとして扱います．</p>
<p>ここではプログラム内で使用する最低限のフィールドのみを定義しましたが，すべてのフィールドを定義しても構いません．
ただし，<code>updated_at</code> および <code>created_at</code> の値は基本的に DB によって管理されるため，プログラム内で変更操作を加えるケースはほとんどありません．</p>
<h2 id="ユーザ登録機能"><a class="header" href="#ユーザ登録機能">ユーザ登録機能</a></h2>
<p>ユーザを登録する機能を実装していきます．
大まかな処理の流れは<a href="07_task_management.html#%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E6%96%B0%E8%A6%8F%E7%99%BB%E9%8C%B2">タスクの新規登録</a>とほぼ同じです．</p>
<p>仮ルーティングを設定し，ユーザ登録画面の表示および登録処理の実装を進めます．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">    ...
    // ユーザ登録
    engine.GET(&quot;/user/new&quot;, service.NotImplemented)
    engine.POST(&quot;/user/new&quot;, service.NotImplemented)
    ...
</code></pre>
<h3 id="登録画面"><a class="header" href="#登録画面">登録画面</a></h3>
<p>ユーザ登録のため，ユーザ名とパスワードを入力する画面を作成します．
タスクの新規登録画面を参考に，以下のような HTML テンプレートを配置します．</p>
<p><span class="filename">todolist.go/views/new_user_form.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;ユーザ登録&lt;/h1&gt;
&lt;form action=&quot;/user/new&quot; method=&quot;POST&quot;&gt;
    &lt;label&gt;ユーザ名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt;&lt;br&gt;
    &lt;label&gt;パスワード: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; required&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登録&quot;&gt;
&lt;/form&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>このフォームを返す処理を実装します．</p>
<p>ユーザ管理に関わる機能はタスク管理とは独立した機能になります．
したがって，これまでタスク管理機能を実装してきた todolist.go/service/task.go とは別に，todolist.go/service/user.go というファイルを新たに作成して処理を実装していきましょう．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">package service

import (
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
)

func NewUserForm(ctx *gin.Context) {
    ctx.HTML(http.StatusOK, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;})
}
</code></pre>
<p>ルーティング設定を修正し，画面を表示できるようにします．
このとき，トップページなど各自で適当だと思う場所に /user/new へのリンクを配置し，URL を直接打ち込まなくともユーザ登録ページへたどり着けるようにしてください．
また，使い勝手を向上させるため，ユーザ登録ページに「戻る」ボタンなどを配置しても構いません．</p>
<h3 id="登録処理-1"><a class="header" href="#登録処理-1">登録処理</a></h3>
<p>new_user_form.html を通じて Client-side から送信されたユーザ名およびパスワードに基づき，新しいユーザを登録する処理を実装します．</p>
<p>はじめに，パスワードをハッシュ化 (ダイジェスト化) する処理を関数として実装しておきます．
任意の文字列のハッシュ化には，標準パッケージ <code>crypto/sha256</code> を使用します．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">package service 

import (
    &quot;crypto/sha256&quot;
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
)

... // func NewUserForm を省略しています

func hash(pw string) []byte {
    const salt = &quot;todolist.go#&quot;
    h := sha256.New()
    h.Write([]byte(salt))
    h.Write([]byte(pw))
    return h.Sum(nil)
}
</code></pre>
<p>ここに定義した関数 <code>hash</code> は，入力として文字列 <code>pw</code> を受け取り，<strong>salt</strong> 文字列を付与したうえで 256 bit のハッシュ値を計算し，計算したハッシュ値を <code>[]byte</code> 型で返します．
返されるハッシュ値は暗号学的ハッシュ関数 SHA-2 によって計算されたものであり，ハッシュ値から元の入力を復元することが非常に困難である性質 (一方向性) を持ちます．
したがって，DB 内にハッシュ値を保存している限り，DB 内のデータが漏洩しても容易には元のパスワードがわからないようにすることができます．</p>
<p><strong>salt</strong> とは一般にセキュリティを高める目的で導入される任意の文字列です．
ここでは &quot;todolist.go#&quot; という文字列を指定していますが，実際には各自の好きな文字列を設定して良いです．
一般に複雑な salt を与えるほどパスワードの復元可能性は低くなるため，実用的なアプリケーションではユーザごとに固有のランダムな文字列を生成していたりします．</p>
<p>パスワードをハッシュ化する仕組みさえ作ってしまえば，残りの処理はほとんどタスクの新規登録処理と同じです．
<code>service.RegisterTask</code> 関数を参考に，<code>service.RegisterUser</code> 関数を作成します．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">package service 

import (
    &quot;crypto/sha256&quot;
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
    database &quot;todolist.go/db&quot;
)

... // func NewUserForm および func hash を省略しています

func RegisterUser(ctx *gin.Context) {
    // フォームデータの受け取り
    username := ctx.PostForm(&quot;username&quot;)
    password := ctx.PostForm(&quot;password&quot;)
    if username == &quot;&quot; || password == &quot;&quot; {
        Error(http.StatusBadRequest, &quot;Empty parameter&quot;)(ctx)
        return
    }
    
    // DB 接続
    db, err := database.GetConnection()
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }

    // DB への保存
    result, err := db.Exec(&quot;INSERT INTO users(name, password) VALUES (?, ?)&quot;, username, hash(password))
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }

    // 保存状態の確認
    id, _ := result.LastInsertId()
    var user database.User
    err = db.Get(&amp;user, &quot;SELECT id, name, password FROM users WHERE id = ?&quot;, id)
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }
    ctx.JSON(http.StatusOK, user)
}
</code></pre>
<p>15, 16 行目にて，POST されたフォームデータを受け取っています．
入力フォームには <code>required</code> 属性を付けたので，基本的に空文字列が <code>username</code> あるいは <code>password</code> として送られてくることはありませんが，念のため 17～20 行目の非空文字チェックを実装しています．</p>
<p>30 行目にて送信されたユーザ情報からユーザデータを DB 中に新規登録します．
パスワードはそのまま DB に保存せず，<code>hash(password)</code> としてハッシュ値を登録するようにしています．
DB中の <code>users.name</code> 属性には UNIQUE 制約を付けたため，すでに登録されているユーザ名を重複して登録しようとした場合はエラー (<code>err != nil</code>) となります．</p>
<p>ユーザの登録処理が正常に終了した場合，本来であればログインページなどに遷移するのが自然かと思います．
しかしながら，現在のところログインページをまだ実装していないため，ここではユーザが正常に登録されていることを確認するだけに留めましょう．
動作確認のためにページを作成するのも面倒なので，37～40 行目には単純にデータだけを画面に表示する方法を示しています．</p>
<p>37～40 行目のコードでは，ユーザの登録状況を手っ取り早く表示するため，追加したユーザ情報を DB から取得し，そのまま Client-side へ返しています．
文字列化して <code>gin.Context.String</code> メソッドを使用して返しても良いのですが，構造体を返すだけなら <code>gin.Context.JSON</code> メソッドを使用して JSON オブジェクトとしてしまうと早いでしょう．</p>
<p>以上でユーザ登録の処理は実装できました．
ルーティング設定を更新し，動作確認を行ってください．
また，以下の練習問題に取り組み，ユーザ登録処理の理解を深めてみましょう．</p>
<h5 id="練習問題-9-1"><a class="header" href="#練習問題-9-1">練習問題 9-1</a></h5>
<p>パスワードがたしかにハッシュ化されていることを確認してみましょう．
また，いくつかのパスワードを登録し，それぞれどのようなハッシュ値になるか，および，元のハッシュ値を推測可能そうかについて確認してみましょう．</p>
<h5 id="練習問題-9-2"><a class="header" href="#練習問題-9-2">練習問題 9-2</a></h5>
<p>同じユーザ名で複数回のユーザ登録を行い，たしかにエラーとなることを確かめてみましょう．</p>
<h2 id="エラー表示"><a class="header" href="#エラー表示">エラー表示</a></h2>
<p>ここまではアカウント管理機能を実装するための基礎としてユーザ追加機能を実装しました．
今回最後の内容として，ユーザ登録画面を少し改良し，使い勝手を良くしてみます．</p>
<p>ユーザ登録画面ではユーザ名をパスワードを入力し，Server-side アプリケーションへ送信することでユーザ登録処理を行っています．
このとき，それぞれのフィールドが非空文字列であることは <code>required</code> 属性によってチェックされていますが，ユーザ名の重複が発生した際はエラーページだけが表示される不親切な設計となっています．</p>
<p>よくある実用的なアプリケーションでは，ユーザ名の重複がある際には入力画面上にエラー文を表示し，別のユーザ名を入力するよう誘導する仕組みを備えていることが多いです．
todolist.go にもそのような機能を実装し，エラーの内容をわかりやすく表示したうえで再入力を促すフォームを作成してみます．</p>
<h3 id="エラー表示エリアの配置"><a class="header" href="#エラー表示エリアの配置">エラー表示エリアの配置</a></h3>
<p>まずはエラーを表示する場所を確保するため，todolist.go/views/new_user_form.html を以下のように修正します．
先に実装したものに対し主に 3〜5 行目の記述を追加しました．
また，各入力フィールドに <code>value</code> 属性を追加し，最後の入力値を引き継げるようにしています．</p>
<p><span class="filename">todolist.go/views/new_user_form.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;ユーザ登録&lt;/h1&gt;
{{ if .Error }}
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;{{ .Error }}&lt;/font&gt;&lt;p&gt;
{{ end }}
&lt;form action=&quot;/user/new&quot; method=&quot;POST&quot;&gt;
    &lt;label&gt;ユーザ名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ .Username }}&quot;required&gt;&lt;br&gt;
    &lt;label&gt;パスワード: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;{{ .Password }}&quot; required&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登録&quot;&gt;
&lt;/form&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>3〜5 行目は，<code>.Error</code> が値を持っていれば，4 行目に示すエラー表示エリア (<code>&lt;p&gt;</code> タグ) を有効化するものです．
すなわち，<code>.Error</code> が <code>nil</code> でない場合，あるいは <code>.Error</code> が空文字でない場合にのみ，エラー表示エリアが有効化されます．
エラー表示なので <code>&lt;font&gt;</code> タグを用いて <font color="#FF0000">赤色</font> で表示するようにしています．</p>
<p><code>value=&quot;{{ .Username }}&quot;</code> および <code>value=&quot;{{ .Password }}&quot;</code> の部分についても，値が渡されなければ空文字列，すなわち共に <code>value=&quot;&quot;</code> となるので問題ありません．</p>
<p>このように，値がある場合のみ有効化されるタグを配置しておき，エラー文やメッセージが存在する場合のみ表示する技法はたびたび需要があるので，覚えておくと良いかもしれません．</p>
<h3 id="エラーの送出"><a class="header" href="#エラーの送出">エラーの送出</a></h3>
<p>エラー表示エリアを確保したので，次はエラー文を埋め込む方法を考えます．
このフォームは /user/new への GET リクエストを処理した結果として表示される画面として作成しました．
しかしながら，初回アクセス時は単純にフォームを表示するだけなので，エラーは何も表示されないはずです．
したがって，<code>service.NewUserForm</code> 関数は特に修正する必要がありません．</p>
<p>ユーザ登録処理を追えばわかる通り，エラー文が表示されるのは /user/new への POST リクエストを処理する途中でエラーが発生した場合です．
すなわち，<code>service.RegiterUser</code> 関数実行中のエラーを補足し，エラー文を構成した上でこのフォームを送り返してあげればよさそうです．</p>
<p>以下に実装例を示します．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">...
func RegisterUser(ctx *gin.Context) {
    // フォームデータの受け取り
    username := ctx.PostForm(&quot;username&quot;)
    password := ctx.PostForm(&quot;password&quot;)
    switch {
    case username == &quot;&quot;:
        ctx.HTML(http.StatusBadRequest, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;, &quot;Error&quot;: &quot;Usernane is not provided&quot;, &quot;Username&quot;: username})
    case password == &quot;&quot;:
        ctx.HTML(http.StatusBadRequest, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;, &quot;Error&quot;: &quot;Password is not provided&quot;, &quot;Password&quot;: password})
    }
    
    // DB 接続
    db, err := database.GetConnection()
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }

    // 重複チェック
    var duplicate int
    err = db.Get(&amp;duplicate, &quot;SELECT COUNT(*) FROM users WHERE name=?&quot;, username)
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }
    if duplicate &gt; 0 {
        ctx.HTML(http.StatusBadRequest, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;, &quot;Error&quot;: &quot;Username is already taken&quot;, &quot;Username&quot;: username, &quot;Password&quot;: password})
        return
    }
    // DB への保存
    ...
</code></pre>
<p>1 つめ修正点は 6〜11 行目です．
修正前は以下のようにユーザ名かパスワードのいずれかが空文字列であればエラー画面を表示するコードでした．</p>
<pre><code class="language-go">    if username == &quot;&quot; || password == &quot;&quot; {
        Error(http.StatusBadRequest, &quot;Empty parameter&quot;)(ctx)
        return
    }
</code></pre>
<p>これを switch 文を使用してエラーの種類を識別し，以下のように適切なエラー文を表示するよう修正しています．</p>
<pre><code class="language-go">    switch {
    case username == &quot;&quot;:
        ctx.HTML(http.StatusBadRequest, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;, &quot;Error&quot;: &quot;Username is not provided&quot;, &quot;Username&quot;: username})
    case password == &quot;&quot;:
        ctx.HTML(http.StatusBadRequest, &quot;new_user_form.html&quot;, gin.H{&quot;Title&quot;: &quot;Register user&quot;, &quot;Error&quot;: &quot;Password is not provided&quot;, &quot;Password&quot;: password})
    }
</code></pre>
<p>2 つめの修正点として 21〜30 行目のコードを追加しました．
これはユーザ名の重複を確認するコードであり，変数 <code>username</code> がすでに登録されているユーザ名である場合に，<code>duplicate &gt; 0</code> が成立するためエラー文が表示される仕組みになっています．
ただし，ユーザ名の重複以外の理由でエラーになる場合は <code>err != nil</code> のブロックが有効になり，こちらは内部エラーとして処理するようにしています．
ちなみに，ここはもう少し効率的な記述方法があるかもしれませんので，もし知っている人やアイデアのある方は教えてください．
DB への保存時に UNIQUE 制約違反のエラーをキャプチャしても良いのですが，他のエラーとの区別が面倒だったのでとりあえず別処理にしています．</p>
<p>これらの機能の動作確認として，重複するユーザ名を登録した時にどのような画面表示がなされるかを確認してみましょう．</p>
<h5 id="練習問題-9-3"><a class="header" href="#練習問題-9-3">練習問題 9-3</a></h5>
<p>よくあるアカウント登録ページでは，パスワードを 2 回入力させることで，タイプミスによって認証できなくなる事態を防いでいます．
本アプリケーションでも同様の仕組みを実装し，パスワードの入力にミスがある場合にはエラーを表示するよう実装を修正してみましょう．</p>
<h5 id="練習問題-9-4-少し発展的内容"><a class="header" href="#練習問題-9-4-少し発展的内容">練習問題 9-4 (少し発展的内容)</a></h5>
<p>現在の実装ではパスワードの文字列や複雑さについて一切のチェック機能がありません．
そこで，短すぎるパスワードや数字だけのパスワードを無効化するよう <code>service.RegisterUser</code> 関数を修正し，そうしたパスワードが入力された場合にはエラーを表示してみましょう．</p>
<h2 id="まとめ-8"><a class="header" href="#まとめ-8">まとめ</a></h2>
<p>今回はユーザを扱うための基礎的な仕組みを追加しました．
また，アプリケーションのセキュリティを高める工夫として，パスワードをハッシュ化 (ダイジェスト化) して保管することでデータ漏洩への対策を組み込みました．
ここでは実装上の基礎的な考え方を学ぶために単純なパスワード保護の方法をとりましたが，実用的なアプリケーションでは多重ハッシュ化や salt のランダム化などによって，より強固な方法を実装する必要があります．
次回の内容にて触れますが，現実的には認証部分をより安全な外部サービスに委託するケースも多いので，そうしたサービスについて調べてみるのも良いかと思います．</p>
<p>次回はログイン・ログアウト処理およびタスクとユーザの紐づけを実装し，ユーザごとにタスクを管理できる実践的なアプリケーションとして todolist.go の基本仕様の開発を進めます．</p>
<p>今回の内容は以上です．
おつかれさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-アカウント管理機能-2"><a class="header" href="#10-アカウント管理機能-2">10: アカウント管理機能 (2)</a></h1>
<p><a href="09_account_management_1.html">前回</a>に引き続き<a href="https://cs-sysdes.github.io/todolist.html">仕様書</a>に示す基本仕様 S-1.3 および S-1.4 について実装を進めます．</p>
<p>今回は主にログイン・ログアウトの機能を実装し，ログイン状態に応じてページアクセスを制限する仕組みを実装します．
また，ユーザとタスクを紐づけ，ユーザ自身が登録したタスクのみを閲覧・編集可能とするようアプリケーションを修正します．</p>
<ol>
<li>ログイン・ログアウト機能</li>
<li>ユーザとタスクの紐付け</li>
<li>ユーザの削除</li>
</ol>
<p>ユーザ名やパスワードなどのユーザ情報を変更する機能については，基本仕様に含まれていますが，<a href="07_task_management.html#%E6%97%A2%E5%AD%98%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E7%B7%A8%E9%9B%86">タスクの編集機能</a>と同様ですので資料内では扱いません．
各自で実装を進めて下さい．
注意点として，パスワード変更の際には元のパスワードを同時に入力させ，たしかにユーザ自身による操作であることを確認したうえでパスワードを更新する仕組みがあると親切でしょう．</p>
<p>以下の内容は<a href="09_account_management_1.html">前回</a>実装したユーザデータを使用する機能になります．
前回の内容をまだ終えていない場合は，先にそちらに取り組んでください．</p>
<h2 id="ログインログアウト機能"><a class="header" href="#ログインログアウト機能">ログイン・ログアウト機能</a></h2>
<p>登録したユーザ情報に基づいて，アプリケーション内でログイン状態・ログアウト状態を切り替える機能を実装します．
状態管理が必要になる部分ですので，<a href="05_state_management_2.html">第5回</a>において扱った「セッション方式」を採用することとします．</p>
<h3 id="セッション管理の準備"><a class="header" href="#セッション管理の準備">セッション管理の準備</a></h3>
<p>以前と同様に自力で Cookie の管理を行っても良いのですが，ここでは特に Gin フレームワーク上でセッション管理を行うためのプラグインを使用して楽をしましょう．
以下のコマンドを実行し，依存モジュール <a href="https://pkg.go.dev/github.com/gin-contrib/sessions">github.com/gin-contrib/sessions</a> をプロジェクトに追加します．</p>
<pre><code class="language-sh">$ docker-compose exec app go get github.com/gin-contrib/sessions
</code></pre>
<p>このコマンドを実行したのち，Docker コンテナを再ビルドする際にエラーが発生する場合があります．
もし <code>docker-compose up -d</code> がうまく動かなくなった場合は，Slack に質問を投げてください．</p>
<p>アプリケーション内でセッション機能を有効化するため，todolist.go/main.go に対し以下 8～9 行目および 21～23 行目に示す追加実装を行います．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">package main

import (
    ...
	&quot;github.com/gin-gonic/gin&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;

    &quot;github.com/gin-contrib/sessions&quot;
    &quot;github.com/gin-contrib/sessions/cookie&quot;
    ...
)

const port = 8000

func main() {
    ...
	// initialize Gin engine
	engine := gin.Default()
	engine.LoadHTMLGlob(&quot;views/*.html&quot;)

    // prepare session
    store := cookie.NewStore([]byte(&quot;my-secret&quot;))
    engine.Use(sessions.Sessions(&quot;user-session&quot;, store))

	// routing
	engine.Static(&quot;/assets&quot;, &quot;./assets&quot;)
	engine.GET(&quot;/&quot;, service.Home)
    ...
</code></pre>
<p>8～9行目において，先ほどプロジェクトに追加したパッケージを import し，利用可能にしています．
それぞれ 8 行目がセッション管理機能を提供するパッケージ，9 行目がセッションの状態を Cookie で管理するためのパッケージになります．</p>
<p>22～23 行目の記述が，実際にセッション管理を有効化するコードです．
22 行目の変数 <code>store</code> は，Cookie を使用してセッション情報を保存する仕組みを提供するためのインタフェースになります．
23 行目において Gin のルーティングエンジンに対し変数 <code>store</code> を利用したセッション管理機能を追加し，有効化しています．</p>
<p>22, 23 行目に出現する文字列 <code>&quot;my-secret&quot;</code> および <code>&quot;user-session&quot;</code> は，それぞれ任意の文字列を使用することができます．
<code>&quot;my-secret&quot;</code> は Cookie を検証するための署名鍵であり，32バイトあるいは64バイトの文字列であることが推奨されていますが，ここでは特に気にせず適当な文字列を使用しています．
Cookie の値は Client-side で書き変えることが容易に可能であるため，署名鍵の検証を行うことで安全性を高めています．
<code>&quot;user-session&quot;</code> はセッション名であり，複数のセッションを並行して利用する際にセッションの識別を行うために使用しますが，今回は単一セッションなので特に気にしなくて良いです．</p>
<p>これらのコードを追加したことで，アプリケーションに対するすべての通信においてセッションの使用が可能になります．
セッションを使用する準備ができたので，ログイン機能から順に実装していきます．</p>
<h3 id="ログイン機能"><a class="header" href="#ログイン機能">ログイン機能</a></h3>
<p>ログインに必要な処理は，送信されたユーザ名およびパスワードを登録済みのユーザ情報と照らし合わせ，適切なユーザによるログインであることを認証することです．
また，ユーザアカウントの役割を考えると，セッションにユーザ ID を関連づけ，どのユーザによるセッションなのかを識別できるようにした方が良いでしょう．</p>
<p>はじめに，ログインフォームを作成します．
ログインフォームは /login に対する GET リクエストで表示するようルーティングを行うこととします．
トップページなどにリンクを配置し，ログイン画面へ誘導できるようにしておきましょう．</p>
<p>ログインページを todolist.go/views/login.html に作成します．</p>
<p><span class="filename">todolist.go/views/login.html</span></p>
<pre><code class="language-html">{{ template &quot;header&quot; . }}
&lt;h1&gt;Login&lt;/h1&gt;
{{ if .Error }}
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;{{ .Error }}&lt;/font&gt;&lt;/p&gt;
{{ end }}
&lt;form action=&quot;/login&quot; method=&quot;POST&quot;&gt;
    &lt;label&gt;ユーザ名: &lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ .Username }}&quot; required&gt;&lt;br&gt;
    &lt;label&gt;パスワード: &lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt;&lt;/br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;ログイン&quot;&gt;
&lt;/form&gt;
&lt;p&gt;&lt;a href=&quot;/user/new&quot;&gt;ユーザ登録&lt;/a&gt;&lt;/p&gt;
{{ template &quot;footer&quot; }}
</code></pre>
<p>ログインページはユーザ登録ページとほぼ同じ構造なので詳しい説明は省略します．
一つ新しい要素として，ここでは <code>input[type=&quot;password&quot;]</code> を使用することで，下記のように入力値を隠すよう実装しています．</p>
<div style="margin: auto 20pt">
<label>パスワード: </label><input type="password" value="test">
</div>
<p>次に todolist.go/service/user.go を編集し，/login への POST リクエストに対してログイン処理を実行する関数 <code>Login</code> を追加します．</p>
<p>ログイン状態の判別は，セッションにユーザ ID が割当てられているかによって行うこととします．
すなわち，セッションがユーザ ID を持っていれば当該 ID を持つユーザによってログインされている状態，ユーザ ID を持っていなければ非ログイン状態であると判定します．
したがって，関数 <code>Login</code> が行うべき処理は，以下の 4 つになります．</p>
<ol>
<li>送信されたユーザ名およびパスワードの取得</li>
<li>該当するユーザの検索</li>
<li>パスワードの一致判定</li>
<li>セッションへのユーザ ID の保存</li>
</ol>
<p>2 および 3 の処理において，たとえば該当するユーザが存在しない，あるいはパスワードが一致しないなどのエラーを検出した場合，ログインページにエラーの内容を表示して再入力を促すようにします．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">package service

import (
    &quot;crypto/sha256&quot;
    &quot;encoding/hex&quot;
    &quot;net/http&quot;
    
    &quot;github.com/gin-gonic/gin&quot;
    &quot;github.com/gin-contrib/sessions&quot;
    database &quot;todolist.go/db&quot;
)

...

const userkey = &quot;user&quot;

func Login(ctx *gin.Context) {
    username := ctx.PostForm(&quot;username&quot;)
    password := ctx.PostForm(&quot;password&quot;)

    db, err := database.GetConnection()
    if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }

    // ユーザの取得
    var user database.User
    err = db.Get(&amp;user, &quot;SELECT id, name, password FROM users WHERE name = ?&quot;, username)
    if err != nil {
        ctx.HTML(http.StatusBadRequest, &quot;login.html&quot;, gin.H{&quot;Title&quot;: &quot;Login&quot;, &quot;Username&quot;: username, &quot;Error&quot;: &quot;No such user&quot;})
        return
    }

    // パスワードの照合
    if hex.EncodeToString(user.Password) != hex.EncodeToString(hash(password)) {
        ctx.HTML(http.StatusBadRequest, &quot;login.html&quot;, gin.H{&quot;Title&quot;: &quot;Login&quot;, &quot;Username&quot;: username, &quot;Error&quot;: &quot;Incorrect password&quot;})
        return
    }

    // セッションの保存
    session := sessions.Default(ctx)
    session.Set(userkey, user.ID)
    session.Save()

    ctx.Redirect(http.StatusFound, &quot;/list&quot;)
}
</code></pre>
<p>ハッシュ値の比較 (等価判定) のために，パッケージ <code>encoding/hex</code> の import を追加しています．
また，ログイン状態をセッションに記録するため，パッケージ <code>github.com/gin-contrib/sessions</code> も import します．</p>
<p>DB から取得する <code>user.Password</code> は，パスワード文字列をダイジェスト化したものです．
したがって，パスワードを照合する場合は，入力されたパスワードも <code>hash</code> 関数を通してダイジェスト化した上で一致判定を行う必要があります．
ダイジェスト化に使用している一方向性関数 SHA-256 は決定的関数であり，同じ入力に対して常に同じハッシュ値を返すため，パスワードが一致するならハッシュ値も一致します．
ただし，逆は一般に成立しません (ハッシュ値の衝突が起こり得ます)．</p>
<p><code>user.Password</code> は <code>[]byte</code> 型の変数として定義されており，関数 <code>hash</code> の戻り値も <code>[]byte</code> 型です．
直接 <code>user.Password == hash(password)</code> として比較してしまうと，これはスライスの比較となるため正常にパスワードの一致判定をすることができません．
したがって，ここでは <code>hex.EncodeToString</code> 関数を使用して文字列にエンコードした上で比較を行っています．</p>
<p>セッションへのユーザ ID の保存は以下の手順で行います．</p>
<ol>
<li>いま処理している通信のセッションを習得</li>
<li>セッションに key-value ペアの形式で保存したい情報 (ユーザ ID) を記入</li>
<li>セッション情報の更新 (保存)</li>
</ol>
<p><a href="10_account_management_2.html#%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86%E3%81%AE%E6%BA%96%E5%82%99">セッション管理の準備</a> において todolist.go/main.go に記述したセッション管理を有効化するコードにより，すべての通信には接続元に応じてセッションが紐づけられるようになっています．
したがって，いま処理している通信のセッションは，42 行目に示すように <code>sessions.Default</code> 関数で取得可能となっています．</p>
<p>適当な名前 <code>userkey := &quot;user&quot;</code> を定義し，セッション中に <code>user=&lt;user ID&gt;</code> の形式でユーザ ID を記入します (43 行目)．
最後に <code>sessions.Session.Save</code> メソッドを呼びセッション情報に加えた更新を有効化します (44 行目)．</p>
<p>以上の処理によりセッション上にユーザ ID が載るため，次回以降の接続ではセッション中のユーザ ID の値を確認することで，どのユーザによってログインされているセッションであるかを識別できます．
また，セッション中にユーザ ID が保存されていなければ，未ログイン状態のユーザによるアクセスであることを判別できます．</p>
<p>ログインページの表示およびログイン処理に関して適切なルーティングを設定し，またトップページなどにログインページへのリンクを設置し，ログイン機能が適切に動作することを確認しましょう．
ログインに成功した場合は /list へリダイレクトされ，失敗した場合はエラーが表示されるはずです．
ユーザ名やパスワードをわざと間違えてみて，想定通りの動作を行うか調べてみるとよいでしょう．</p>
<p>ここまででユーザアカウントを用いたログイン処理ができるようになりました．
しかしながら，現在のアプリケーションはログイン状態に依らず誰しもがすべてのページへアクセス可能になっています．
これではログイン機能の意味がないので，いくつかのページにアクセス制限をかけてログイン状態でなければページを表示できないようにしてみます．</p>
<h3 id="アクセス制限"><a class="header" href="#アクセス制限">アクセス制限</a></h3>
<p>ここではタスクの表示機能にアクセス制限をかけることとします．
すなわち，ログインしているユーザはタスクの一覧表示や登録機能，編集機能を使用できますが，ログインしていないユーザはログインページへ誘導されてしまうような仕組みの実装を目指します．</p>
<p>本資料ではセッションにユーザ ID が割当てられているかによってログイン状態を判別するよう実装を進めてきました．
したがって，セッション上のユーザ ID を検査し，割当てがある場合のみタスクの一覧表示などの処理を正常に行うことで，アクセス制限を実現することができます．
セッションにユーザ ID 割当てがない場合は，即座にログインページへリダイレクトすることで，リクエストを弾いていきます．</p>
<p>素朴な実装を考えれば，アクセス制限をかけたいリクエスト対象すべての関数の冒頭においてセッションにユーザ ID が含まれるかを確認するコードを実装するとよいでしょう．
たとえば以下のようになります (これは例ですので実装する必要はありません)．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">func TaskList(ctx *gin.Context) {
    // アクセス制限の例
    userID := session.Default(ctx).Get(&quot;user&quot;)
    if userID == nil {
        ctx.Redirect(http.StatusFound, &quot;/login&quot;)
        return
    }
    ...
</code></pre>
<p>実装自体は単純ですが，これを該当するすべての関数に追加するのは面倒ではないでしょうか．
また，今後アクセス制限をかけたい処理が増える可能性を考えると，まとめて管理できる仕組みがほしくなります．</p>
<p>この要求に応えるため，ここでは Gin フレームワークのもつ <strong>middleware</strong> という機能を利用して，よりアクセス制限を管理しやすい実装を行います．
Gin における <strong>middleware</strong> とは，実際に処理を行う関数 (ハンドラ) と同じ形式を持つ関数 (<code>func(*gin.Context)</code> 型) によって定義される共通処理を意味します．
middleware を使用することで，リクエストに応じた個々の処理の手前で実行すべき共通処理を，ルーティング時に (まとめて) 挿入することができます．</p>
<h4 id="middleware-の実装"><a class="header" href="#middleware-の実装">middleware の実装</a></h4>
<p>ログイン処理を担当する middleware を以下に示す <code>LoginCheck</code> 関数として実装します．
ログイン処理はユーザ関連の処理であり，また変数 <code>userkey</code> にアクセスしたいため，todolist.go/service/user.go ファイル内に定義しています．
本来であれば，todolist.go/service/auth.go などとして，認証処理だけでファイルを分割する方が設計上は良いかもしれません．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">func LoginCheck(ctx *gin.Context) {
    if sessions.Default(ctx).Get(userkey) == nil {
        ctx.Redirect(http.StatusFound, &quot;/login&quot;)
        ctx.Abort()
    } else {
        ctx.Next()
    }
}
</code></pre>
<p>ログイン処理自体は，セッション上のユーザ ID を検査するだけなので，それほど難しくはないと思います．
２行目に示すように，セッションを取得し，セッション中に <code>userkey</code> に該当する値が存在することを確認できればログイン状態，そうでなければ (= <code>nil</code> であれば) 非ログイン状態となります．
非ログイン状態の場合，ログインページへのリダイレクトを指定します (3行目)．</p>
<p>middleware は中間処理を記述するものなので，次の middleware あるいは最終処理を継続して実行すべきか指示する必要があります．
非ログイン状態では，ログインページへリダイレクトした後の処理はすべてスキップしたい (リクエストをここで弾きたい) ので，<code>gin.Context.Abort</code> メソッドを呼び出して処理の終了を明示します (4 行目)．
一方，ログイン状態では，そのまま処理を継続してほしいので，<code>gin.Context.Next</code> メソッドによってその旨を明示します (6 行目)．</p>
<p>このように，middleware を定義する際は基本的に <code>Abort</code> メソッドか <code>Next</code> メソッドを最後に呼び出す必要がある点に注意してください．</p>
<h4 id="middleware-の適用"><a class="header" href="#middleware-の適用">middleware の適用</a></h4>
<p>定義した middleware を実際に使用していきます．
現状のルーティング設定に対し middleware を追加していくよう実装を進めます．
以下に現状のルーティング設定を示しますが，各自で追加定義したルーティングなどがあれば適宜補いながら進めてください．</p>
<p><span class="filename">todolist.go/main.go</span></p>
<pre><code class="language-go">...
	// routing
	engine.Static(&quot;/assets&quot;, &quot;./assets&quot;)
	engine.GET(&quot;/&quot;, service.Home)

    engine.GET(&quot;/list&quot;, service.TaskList)

    engine.GET(&quot;/task/:id&quot;, service.ShowTask) // &quot;:id&quot; is a parameter
    engine.GET(&quot;/task/new&quot;, service.NewTaskForm)
    engine.POST(&quot;/task/new&quot;, service.RegisterTask)
    engine.GET(&quot;/task/edit/:id&quot;, service.EditTaskForm)
    engine.POST(&quot;/task/edit/:id&quot;, service.NotImplemented)
    engine.GET(&quot;/task/delete/:id&quot;, service.DeleteTask)

    engine.GET(&quot;/user/new&quot;, service.NewUserForm)
    engine.POST(&quot;/user/new&quot;, service.RegisterUser)

	engine.GET(&quot;/login&quot;, service.LoginForm)
	engine.POST(&quot;/login&quot;, service.Login)
...
</code></pre>
<p>はじめに，パッケージの一覧表示に対し middleware を追加します．
middleware の追加方法は大きく分けて 2 つ存在しますが，ここでは単純にリクエストに対する処理として追加する方法をとります．</p>
<p>6 行目のルーティング設定を以下のように変更し，middleware を適用します．
Gin フレームワークのルーティング設定では，このように複数の処理をリクエストに紐づけることができます．
リクエストを処理する関数と middleware は同じ型を持っているため，このような指定が可能となっています．</p>
<pre><code class="language-go">...
    engine.GET(&quot;/list&quot;, service.LoginCheck, service.TaskList)
...
</code></pre>
<p>上記のように複数の処理を同一リクエストに結び付けた場合，それぞれ先頭から順に処理が適用されます．
一般に一番末尾の処理がリクエストに対して行いたい処理になるため，その前に middleware を挟むイメージとなります．</p>
<p>今回の場合は，まず middleware である <code>service.LoginCheck</code> 関数が呼ばれ，ログイン済みのセッションであれば <code>service.TaskList</code> を呼び出すよう処理が進みます．
非ログイン状態のセッションであった場合は，middleware 内でリダイレクトの設定がなされたうえで処理が中断されるため，<code>service.TaskList</code> は呼び出されません．</p>
<p>次に middleware を追加する方法の 2 つ目として，ルーティングの<strong>グループ化</strong>による一括追加を行います．
対象はタスクの表示・新規登録・編集・削除など，タスクに関連するリクエスト処理に対し一括してアクセス制限をかけます．</p>
<p><strong>グループ化</strong>は Gin フレームワークの持つ機能の一つであり，複数のパスの一括管理を可能にします．
たとえば，8～13 行目に記述されたタスク関連のルーティングはすべて /task という共通パスを持っていますが，こうした共通パスを持つルーティングをグループ化できます．</p>
<p>8～13 行目のルーティング設定に対し，グループ化を用いて middleware の設定を行うと以下のようになります．</p>
<pre><code class="language-go">...
    taskGroup := engine.Group(&quot;/task&quot;)
    taskGroup.Use(service.LoginCheck)
    {
        taskGroup.GET(&quot;/:id&quot;, service.ShowTask)
        taskGroup.GET(&quot;/new&quot;, service.NewTaskForm)
        taskGroup.POST(&quot;/new&quot;, service.RegisterTask)
        taskGroup.GET(&quot;/edit/:id&quot;, service.EditTaskForm)
        taskGroup.POST(&quot;/edit/:id&quot;, service.NotImplemented)
        taskGroup.GET(&quot;/delete/:id&quot;, service.DeleteTask)
    }
...
</code></pre>
<p><code>Group</code> メソッドによって /task をプレフィックスパスとするグループを定義し，タスク関連のリクエスト処理をグループ化します．
middleware は <code>Use</code> メソッドで一括適用が可能であり，上記のコードではグループ内のすべてのルーティング設定に対し，<code>service.LoginCheck</code> を middleware として追加しています．</p>
<p>グループ内のルーティング設定では，いま /task をプレフィックスパスとして設定したため，すべてのパスから /task を削除する必要があります．
たとえば上記 5 行目は，これだけでは /:id へのルーティングに見えますが，/task を上位パスとして持つグループへのルーティングであるため，実際には /task/:id へのルーティングを意味します．
その他のパスも同様に /task を明示的に指定されていませんが，グループ全体で上位パス /task を共有しているため，これまでと同様のパス設定となっています．</p>
<p>グループ内のすべてのパスは <code>service.LoginCheck</code> を middleware として設定されているので，どのパスにアクセスしてもユーザ ID の検査が実行されます．
すなわち，こられのパスに対するアクセス制限が一括で適用できているということになります．</p>
<hr />
<p>さて，ここまででアクセス制限の適用が完了しているので，非ログイン状態では /list や /task/new にアクセスできないことを確認してみましょう．
非ログイン状態でこれらのページへアクセスした場合，ログインページへリダイレクトされれば成功です．
また，ログイン後はこれらのページに遷移可能であることも確かめてみましょう．</p>
<p>なお，現状ではログアウト機能がないため，一旦ログインしてしまうと簡単に非ログイン状態に戻る方法がありません．
ログイン状態と非ログイン状態を手軽に切り替えたい場合は，2 つの異なるブラウザでアプリケーションを開くか，ブラウザのプライベートモードを使用してください．
また，ブラウザの開発者モードに慣れている人であれば，Cookie からセッション情報を削除する機能がありますので，そちらを使用すると良いでしょう．</p>
<div class="memo">
ここに示した middleware の記述・実装方法は Gin フレームワーク固有のものです．
Go 言語で実装された多くの有名な Web フレームワークには，middleware を記述・実装する同様の仕組みがありますが，それぞれ表現方法は異なるかもしれません．
<p>また，他のプログラミング言語で実装された Web フレームワークなどには，middleware に相当する機能がない場合もあります．
しかしながら，共通処理を後から挟みこむ middleware の考え方は，プログラム設計の一般論として有用なテクニックだと思いますので，ここで扱うこととしました．</p>
</div>
<h3 id="ログアウト機能"><a class="header" href="#ログアウト機能">ログアウト機能</a></h3>
<p>ログアウトできないのは不便なので，ログアウト機能をつけます．</p>
<p>ログイン状態はセッションにユーザ ID が保存されているか否かによって判定しています．
したがってログアウト処理では，セッションからユーザ ID を削除すると良いことがわかります．</p>
<p>便利なことに，セッションを管理する <code>sessions.Session</code> 構造体には <code>Clear</code> という名のセッション内の情報をすべて削除するメソッドがあるため，これを利用しましょう．
以下のように <code>Logout</code> 関数を実装します．</p>
<p><span class="filename">todolist.go/service/user.go</span></p>
<pre><code class="language-go">...
func Logout(ctx *gin.Context) {
    session := sessions.Default(ctx)
    session.Clear()
    session.Options(sessions.Options{MaxAge: -1})
    session.Save()
    ctx.Redirect(http.StatusFound, &quot;/&quot;)
}
</code></pre>
<p><code>Logout</code> 関数は，セッションを取得 (3 行目) し，セッション上の情報を削除する (4 行目) のが主な動作になります．
５ 行目は Cookie の有効期間を -1 に設定することで即座に Cookie をリセットするようブラウザに通知するための記述です．
セッションの状態を更新したので忘れずに <code>Save</code> メソッドを呼び，適当なページへリダイレクトします．
当然ながら，リダイレクト先にはアクセス制限のかかったページ以外を指定します．</p>
<p>適切なルーティング設定を行った上で，ログアウトが可能であることを確かめましょう．
なお，ログアウトはログイン状態でのみ実行され得る処理なので，ログイン状態の時のみログアウトボタンを表示するなどの工夫をすると良いかもしれません</p>
<h2 id="ユーザとタスクの紐付け"><a class="header" href="#ユーザとタスクの紐付け">ユーザとタスクの紐付け</a></h2>
<p>ログイン・ログアウト機能およびアクセス制限が可能となりましたが，タスクの閲覧および登録・編集機能は未だにユーザと紐づいていません．
したがって，ログインさえできてしまえば誰でもタスクを閲覧できるし，他人が登録したタスクを勝手に編集することも可能です．
これではユーザごとにログインできる意味があまりないので，ここからはユーザとタスクを紐づけ，個々のユーザが自分のタスクのみ閲覧・編集できる仕組みを実装します．</p>
<p>ユーザとタスクを紐づけるには，主に以下に挙げる 2 通りの方法が考えられます．</p>
<ol>
<li>タスクテーブルに所有ユーザを示すカラムを追加し，どのユーザのタスクであるかを管理する</li>
<li>ユーザとタスクを関連付けるテーブルを用意し，対応関係を管理する</li>
</ol>
<p>どちらもメリット・デメリットを持ちますが，今回のように多対多の関係性を DB で管理する場合，2 の方法をとることがベターとされています．
というのも，仮に<a href="https://cs-sysdes.github.io/todolist.html">追加仕様 S-2.4</a> に取り組むことを考えた場合，1 の方法ではひとつのタスクに対して複数のユーザを紐づけることが難しくなってしまうためです．</p>
<p>2 の方法を実装するためには，ユーザとタスクを関連付けて保持するためのテーブルを別に用意する必要があります．
こうしたテーブルは一般に<strong>連想テーブル</strong> (あるいは<strong>交差テーブル</strong>，<strong>中間テーブル</strong>，<strong>結合テーブル</strong> etc.) と呼び，DB におけるテーブル設計の推奨例として定着しています．</p>
<h3 id="所有関係を保存する連想テーブルの定義"><a class="header" href="#所有関係を保存する連想テーブルの定義">所有関係を保存する連想テーブルの定義</a></h3>
<p>ユーザとタスクを関連付けるため，ユーザ ID とタスク ID を紐づけた連想テーブルを作成します．
関連付けにはユーザ名とタスク名のような属性を使用することも可能ですが，こうした属性は重複や変更が発生する可能性があるため，あまり適しているとは言えません．
一方で，ID はそれぞれのテーブルの主キーであり，同じ ID 値を持つ異なるユーザやタスクは存在しないことが保証されています．
また，ID は基本的に変化しない値なので，ユーザやタスクの実体を指し示す参照値として適しているといえます．</p>
<p>ユーザ ID とタスク ID からなる連想テーブル <code>ownership</code> を以下のように定義します．</p>
<p><span class="filename">todolist.go/docker/db/sql/01_create_tables.sql</span></p>
<pre><code class="language-sql">...
DROP TABLE IF EXISTS `ownership`;

CREATE TABLE `ownership` (
    `user_id` bigint(20) NOT NULL,
    `task_id` bigint(20) NOT NULL,
    PRIMARY KEY (`user_id`, `task_id`)
) DEFAULT CHARSET=utf8mb4;
</code></pre>
<p>ユーザやタスクを管理するテーブルでは ID やデータの作成日時などの情報を付与していましたが，連想テーブルではそういった属性の付与は必要がない限り行いません．
ここでは，連想データの作成日時はタスクの作成日時と同一とみなせば良いため，特に設定していません．
また ID については，ユーザ ID とタスク ID からなる<strong>複合主キー</strong> (7 行目) を用いることで重複するユーザ ID とタスク ID のペアを挿入することができなくなり，これによってデータの唯一性は保証できるため設定していません．</p>
<p>テーブル構造を更新しているため，変更をアプリケーションに反映するためには Docker コンテナの初期化・再構築が必要になります．</p>
<h3 id="タスク表示処理の変更"><a class="header" href="#タスク表示処理の変更">タスク表示処理の変更</a></h3>
<p>連想テーブルにしたがって，各ユーザが自身の登録したタスクのみを表示できるよう変更を加えます．
ここでは特に一覧表示ページ /list に表示されるタスクが自身の登録タスクのみになるよう，<code>service.TaskList</code> 関数を修正します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func TaskList(ctx *gin.Context) {
    userID := sessions.Default(ctx).Get(&quot;user&quot;)
    ...
	// Get tasks in DB
	var tasks []database.Task
    query := &quot;SELECT id, title, created_at, is_done FROM tasks INNER JOIN ownership ON task_id = id WHERE user_id = ?&quot;
    switch {
    case kw != &quot;&quot;:
        err = db.Select(&amp;tasks, query + &quot; AND title LIKE ?&quot;, userID, &quot;%&quot; + kw + &quot;%&quot;)
    default:
        err = db.Select(&amp;tasks, query, userID)
    }
    ...
}
</code></pre>
<p>まずはじめにセッション情報からログインユーザの ID を取得します (3 行目)．
ログインユーザの ID がセッション情報に含まれていることは middleware で確認済みなので，特にエラー処理は実装していません．
不正なユーザ ID を弾くため，可能であれば middleware 内でユーザ ID が整数値に変換可能であることくらいは検証しても良いでしょう．
なお，<code>sessions</code> パッケージを使用するため，import ブロックへ <code>github.com/gin-contrib/sessions</code> を追加するのを忘れないようにしてください．</p>
<p><code>service.TaskList</code> 関数は，<a href="08_search.html">検索キーワードの有無</a>によって DB へ発行するクエリが異なりますが，重複している部分もあるため変数 <code>query</code> として括り出します (7 行目)．
このクエリでは，<code>INNER JOIN</code> によって <code>tasks</code> テーブルと <code>ownership</code> テーブルを<strong>結合</strong> (特に<strong>内部結合</strong>) し，該当するユーザ ID を持つデータだけを抽出しています．
<code>INNER JOIN ownership ON task_id = id</code> は，<code>tasks</code> テーブルの <code>id</code> と <code>ownership</code> テーブルの <code>user_id</code> を関連付け，条件に合うデータのみを積集合 \(\mathrm{tasks} \cap \mathrm{ownership}\) から抽出します．
これにより，DB から取得できるタスクデータはログインユーザに関連付けられたもののみとなり，一覧画面には自身の登録したタスクのみが表示されるようになります．</p>
<p>なお，変数 <code>query</code> では <code>SELECT</code> の対象として ID やタイトルなどを明示的に指定しています．
<code>task</code> テーブルと <code>ownership</code> テーブルを結合したことにより，データの持つ属性に <code>ownership</code> テーブルの情報も含まれてしまうため，<code>*</code> による全属性指定では構造体 <code>Task</code> へのデータ束縛に失敗してしまいます．
したがって，ここでは明示的に取得する属性名を指定する必要があるわけです．
ちなみに，一般論として <code>SELECT * FROM ...</code> の使用はあまり推奨されず，このように必要な属性値を明示的に指定する方がお作法が良いとされることが多いと思いますので，面倒ですが明示的指定に慣れておく必要もあります．</p>
<p>ここまでを実装し，ログイン状態でタスクの一覧表示がどのように変化するかを確認してみましょう．
いまのところユーザに紐づいたタスクは存在しないはずであるため，データが存在しない旨が表示されれば成功です．</p>
<h5 id="練習問題-10-1"><a class="header" href="#練習問題-10-1">練習問題 10-1</a></h5>
<p>タスクの一覧表示ページでは，ユーザに関連づいたタスクのみをフィルタリングできるようになりました．
一方で，現在の実装では適当な ID 値 <code>&lt;id&gt;</code> を指定して URL 欄に直接 /task/&lt;id&gt; などと打ち込むことで，他人のタスクも覗き見ることが可能になっています．
これと同様に，他人のタスクの編集・削除も可能な状態です．
こうした挙動はセキュリティリスクですので，これが不可能となるよう実装を修正してください．</p>
<h3 id="タスク登録処理の変更"><a class="header" href="#タスク登録処理の変更">タスク登録処理の変更</a></h3>
<p>現状のタスク登録処理では，ユーザとタスクの紐づけを <code>ownership</code> テーブルに書き込む処理がありません．
したがって，このままタスクの登録処理を行っても，各ユーザのタスク一覧表示画面には永遠に登録したタスクが表示されないことになります．</p>
<p>ここではタスク登録処理を行う <code>service.RegisterTask</code> 関数を修正し，タスク登録時にタスクとユーザの紐づけを行う機能を実装します．</p>
<p>タスクの登録処理がとるべき手順は以下の通りになります．</p>
<ol>
<li>セッションからユーザ ID の取得</li>
<li>送信データに基づいて新規タスクの登録</li>
<li>登録したタスクの ID とユーザ ID を <code>ownership</code> テーブルに記録</li>
</ol>
<p>この手順から，修正後のタスク登録処理では，タスクデータの登録および連想テーブルの更新という 2 回の DB 操作が必要であることがわかります．
こうした複数回の DB 操作を行うにあたって問題となるのは，途中の処理でエラーが発生した場合の処理です．</p>
<p>たとえば，いまタスクの新規登録は正常に完了したが，連想テーブルの更新に失敗した場合を考えます．
この場合，タスク自体はたしかに登録されますが，ユーザとの紐づけがなされていないため，このタスクは存在するものの決して表示・編集ができないタスクとなります．
すなわち，データとしてどこからも参照・操作されず，ただ DB の容量を圧迫するだけの存在となってしまうわけです．</p>
<p>このような状況が発生してしまうと困ったことになるため，DB 操作が途中で失敗した場合には，すべての操作を巻き戻して元の状態に戻す (<strong>Rollback</strong> する) 仕組みが必要となります．
こうした機能を実現する DB の仕組みが<strong>トランザクション</strong>です．</p>
<p>Go 言語の標準パッケージである <code>database/sql</code> は，こうした DB のトランザクションを扱うための機能を有しています．
したがって，<code>database/sql</code> をラップした <code>github.com/jmoiron/sqlx</code> パッケージでもトランザクションを容易に扱うことができます．</p>
<p>トランザクションの機能を用いた <code>service.RegisterTask</code> の実装を以下に示します．</p>
<p><span class="filename">todolist.go/service/task.go</span></p>
<pre><code class="language-go">...
func RegisterTask(ctx *gin.Context) {
    userID := sessions.Default(ctx).Get(&quot;user&quot;)
    // Get task title
    ...
	// Get DB connection
	db, err := database.GetConnection()
	if err != nil {
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    tx := db.MustBegin()
    result, err := tx.Exec(&quot;INSERT INTO tasks (title) VALUES (?)&quot;, title)
	if err != nil {
        tx.Rollback()
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
	}
    taskID, err := result.LastInsertId()
    if err != nil {
        tx.Rollback()
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }
    _, err = tx.Exec(&quot;INSERT INTO ownership (user_id, task_id) VALUES (?, ?)&quot;, userID, taskID)
    if err != nil {
        tx.Rollback()
		Error(http.StatusInternalServerError, err.Error())(ctx)
		return
    }
    tx.Commit()
    ctx.Redirect(http.StatusFound, fmt.Sprintf(&quot;/task/%d&quot;, taskID))
}
</code></pre>
<p>ユーザ ID は関数の冒頭でセッション情報より取得しています．
以前説明した部分ですなので，詳細は省略します．</p>
<p>12 行目の記述は，トランザクションの開始を宣言しています．
ここから先の DB アクセスは，変数 <code>db</code> ではなく変数 <code>tx</code> を介することで，すべてトランザクション内の処理として実行します．
トランザクション内の処理は <code>Tx.Commit</code> メソッドが呼ばれるまでは確定されません．
<code>Tx.Commit</code> メソッドによって確定される前であれば，<code>Tx.Rollback</code> メソッドによって Rollback することで，任意の段階でそれまでの処理をなかったことにできます．</p>
<p>開始したトランザクションでは，はじめに新規タスクデータの登録を行います (13～18 行目)．
失敗した場合はトランザクションを Rollback した上でエラーを表示して終了します．</p>
<p>タスクデータの登録に成功した場合，登録したタスクの ID を取得します (19～24 行目)．
タスク ID はユーザ ID との関連づけに使用するため，ここで取得しておく必要があります．
この処理も失敗する可能性があるため，失敗した場合は先ほどと同様にトランザクションを Rollback してエラーを表示します．</p>
<p>最後に，ユーザ ID とタスク ID のペアを <code>ownership</code> テーブルに登録します (25～30 行目)．
ここまで問題なく成功したことを確認出来たら，これらの処理を <code>Tx.Commit</code> メソッドにより有効化します (31 行目)．</p>
<p>以上でタスク登録処理の修正は終了です．
新しいタスクを登録し，たしかに登録したタスクのみが表示されることを確認してみましょう．
また，別のユーザでログインし，先ほど登録したタスクが表示されないことを確認しましょう．</p>
<h2 id="ユーザの削除"><a class="header" href="#ユーザの削除">ユーザの削除</a></h2>
<p>最後に，ユーザの削除について少し触れておきます．
本章は特にユーザアカウントの削除処理は少し面倒だということを理解してもらうことを目的とするため，具体的な実装については各自で取り組む課題とします．</p>
<p>ユーザデータに限らず，アプリケーションの管理するデータを削除するには主に以下の 2 通りの方法が考えられます．</p>
<ol>
<li>直接 DB 上から完全に消去してしまう方法 (物理削除)</li>
<li>削除フラグを立てるだけとし，完全には消去しない方法 (論理削除)</li>
</ol>
<p>1 の方法は一般に<strong>物理削除</strong>と呼ばれ，<a href="07_task_management.html#%E6%97%A2%E5%AD%98%E3%82%BF%E3%82%B9%E3%82%AF%E3%81%AE%E5%89%8A%E9%99%A4">タスクデータの削除</a>を実装する際に使用しました．
この方法は一見簡単に思えますが，ユーザデータを対象とする場合は少々面倒です．</p>
<p>今回開発しているアプリケーションでは，ユーザにタスクが紐づいています．
したがってユーザを削除する場合，ユーザの持つタスクも同時に削除するのが自然です．
そのためには，<code>ownership</code> テーブルから該当するタスクの ID を取得し，<code>tasks</code> テーブルから該当するタスクを削除する必要があります．
また，<code>ownership</code> テーブルのデータも参照先のタスクが削除された後には不要ですので，これも削除する必要があります．
このように，ユーザアカウントのようなアプリケーションの動作の根幹に関わるデータを削除しようとすると，連鎖的に複数のデータの削除を行う必要性が生じるため，設計をしっかりしていないとかなり苦労します．
連想テーブルではカスケード規則を設定することで少し楽ができる部分もありますが，テーブル設計時にカスケード規則の動作への深い理解と適切な適用方法の考慮が必要になります．</p>
<p>2 の方法は一般に<strong>論理削除</strong>と呼ばれ，イメージとしては多くの OS で採用されている削除されたファイルを一時的にゴミ箱に移動する動作が該当します．
この方法ではユーザを削除したことを示すデータ (フラグ情報) を保存する領域を用意する必要がありますが，ユーザは実際には削除されていないため，ユーザに紐づいたタスクデータなどを削除する必要はなくなります．
また，削除したことにしているだけなので，万が一ユーザが復帰したいと申し出た場合でも，即座にユーザアカウントの回復処理を行うことができます．</p>
<p>一方で，ユーザデータは残ったままなので，恒久的に復帰する可能性がないユーザにとってはセキュリティリスクが高まります．
また，ユーザが復帰しなければ，そのユーザに関連付けられたタスクは参照も編集もされない「死にデータ」となってしまうため，サービスの継続稼働に伴って不要な記憶領域を圧迫していく原因となり得ます．
したがって，論理削除したデータに対し一定期間後に物理削除処理を実行するようなシステムの存在は自然であり，結局 1 の方法を実装することになってしまうわけです．</p>
<p>ここでは特にユーザデータを対象としたデータ削除の方法として 2 つの主な手法を紹介しました．
どちらも長所と短所を持った方法ですので，目的に合わせて適切な削除処理の実装を考える必要があります．
冒頭でも述べた通り，<a href="https://cs-sysdes.github.io/todolist.html">基本仕様</a>に示されたユーザ削除処理の具体的な実装については，以下の通り練習問題とします．</p>
<h5 id="練習問題-10-2"><a class="header" href="#練習問題-10-2">練習問題 10-2</a></h5>
<p>ユーザの削除機能を実装してみましょう．
上述したどちらの方法を採用しても構いません．
また，ユーザに紐づいたタスクを削除するか残しておくかについても，各自でルールを定めて構いません．</p>
<h2 id="まとめ-9"><a class="header" href="#まとめ-9">まとめ</a></h2>
<p>本演習の資料は以上です．
<a href="https://cs-sysdes.github.io/report.html">期末レポート課題</a>を出題していますので，単位取得を希望する方は期日までに提出をお願いします，
おつかれさまでした．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考サイト"><a class="header" href="#参考サイト">参考サイト</a></h1>
<h2 id="package-document"><a class="header" href="#package-document">package document</a></h2>
<p>Go言語のパッケージに関するドキュメントはおおむね <a href="https://pkg.go.dev">https://pkg.go.dev</a> に集約されています．
本演習で使用したパッケージに関してリンクを以下に示します．</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/gin-gonic/gin">gin</a>: Web framework</li>
<li><a href="https://pkg.go.dev/github.com/jmoiron/sqlx">sqlx</a>: DB library</li>
<li><a href="https://pkg.go.dev/text/template">text/template</a>: 標準ライブラリ text/template</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>






        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/highlight-line-numbers.js"></script>
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
